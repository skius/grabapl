<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Graph Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            height: 100%;
            width: 100%;
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
        }
        #main-container {
            position: relative;
            width: 100%;
            height: 100%;
        }
        canvas {
            display: block;
            cursor: default;
        }
        .node-cursor { cursor: grab; }
        .node-cursor-grabbing { cursor: grabbing; }
        .panning-cursor { cursor: grabbing; }
        input[type="color"] {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            width: 4rem; height: 2.5rem; padding: 0.25rem;
            background-color: transparent; border: 1px solid #d1d5db;
            border-radius: 0.5rem; cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border: none; border-radius: 0.375rem; }
        input[type="color"]::-moz-color-swatch { border: none; border-radius: 0.375rem; }
    </style>
</head>
<body>

<div id="main-container">
    <canvas id="graph-canvas"></canvas>

    <!-- Controls Panel -->
    <div class="absolute top-4 left-4 w-full max-w-sm">
        <div class="bg-white rounded-xl shadow-lg p-6 h-fit max-h-[calc(100vh-2rem)] overflow-y-auto">
            <h2 class="text-xl font-semibold mb-4 border-b pb-2">Controls</h2>

            <div id="node-form" class="mb-6">
                <h3 id="node-form-title" class="font-semibold text-lg mb-2">Add Node</h3>
                <div class="flex flex-col space-y-3">
                    <div class="flex items-center justify-between">
                        <label for="node-color" class="font-medium text-gray-700">Node Color</label>
                        <input type="color" id="node-color" value="#3b82f6">
                    </div>
                    <input type="text" id="node-value" placeholder="Node Value (e.g., A)" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 transition">
                    <button id="node-action-btn" class="w-full font-semibold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-200 shadow-md">Add Node</button>
                    <button id="delete-single-btn" class="w-full font-semibold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-200 shadow-md bg-red-600 text-white hover:bg-red-700 focus:ring-red-500 hidden">Delete Node</button>
                </div>
            </div>

            <div id="multi-select-form" class="hidden mb-6">
                <h3 class="font-semibold text-lg mb-2">Selection Actions</h3>
                <div class="flex flex-col space-y-3">
                    <p class="text-center text-gray-600"><span id="selection-count">0</span> items selected</p>
                    <div class="flex items-center justify-between">
                        <label for="multi-node-color" class="font-medium text-gray-700">Group Color</label>
                        <input type="color" id="multi-node-color" value="#3b82f6">
                    </div>
                    <button id="apply-color-btn" class="w-full font-semibold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-200 shadow-md bg-sky-600 text-white hover:bg-sky-700 focus:ring-sky-500">Apply Color</button>
                    <button id="duplicate-btn" class="w-full font-semibold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-200 shadow-md bg-emerald-600 text-white hover:bg-emerald-700 focus:ring-emerald-500">Duplicate Selection</button>
                    <button id="delete-multi-btn" class="w-full font-semibold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-200 shadow-md bg-red-600 text-white hover:bg-red-700 focus:ring-red-500">Delete Selection</button>
                </div>
            </div>

            <div class="border-t pt-6 mb-6">
                <h3 class="font-semibold text-lg mb-2">Save & Load Graph</h3>
                <div class="flex flex-col space-y-3">
                    <textarea id="graph-data-input" placeholder="Paste graph data here to load..." class="w-full h-24 p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 transition"></textarea>
                    <div class="grid grid-cols-2 gap-3">
                        <button id="import-text-btn" class="w-full bg-indigo-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition shadow-md">Load from Text</button>
                        <button id="import-file-btn" class="w-full bg-teal-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-teal-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-teal-500 transition shadow-md">Load from File</button>
                    </div>
                    <div class="grid grid-cols-2 gap-3">
                        <button id="export-btn" class="w-full bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-purple-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-purple-500 transition shadow-md">Save Graph</button>
                        <button id="clear-btn" class="w-full bg-red-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition shadow-md">Clear Canvas</button>
                    </div>
                    <input type="file" id="file-picker" class="hidden" accept=".json,application/json">
                </div>
            </div>

            <div class="border-t pt-6">
                <h3 class="font-semibold text-lg mb-2">Instructions</h3>
                <ul class="list-disc list-inside text-gray-600 space-y-1">
                    <li>Hold <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Space</kbd> and drag to pan.</li>
                    <li>Drag on empty space to multi-select.</li>
                    <li>Press <kbd class="px-2 py-1.5 text-xs font-semibold text-gray-800 bg-gray-100 border border-gray-200 rounded-lg">Del</kbd> to delete selection.</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<!-- Modals -->
<div id="message-modal" class="fixed inset-0 bg-gray-900 bg-opacity-60 hidden items-center justify-center z-50">
    <div class="relative mx-auto p-6 border w-full max-w-sm shadow-xl rounded-xl bg-white">
        <div class="mt-3 text-center">
            <h3 class="text-xl leading-6 font-bold text-gray-900" id="modal-title">Notification</h3>
            <div class="mt-2 px-7 py-4"><p class="text-base text-gray-600" id="modal-message"></p></div>
            <div class="items-center px-4 py-2"><button id="modal-close-btn" class="w-full px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700">OK</button></div>
        </div>
    </div>
</div>
<div id="prompt-modal" class="fixed inset-0 bg-gray-900 bg-opacity-60 hidden items-center justify-center z-50">
    <div class="relative mx-auto p-6 border w-full max-w-sm shadow-xl rounded-xl bg-white">
        <h3 class="text-xl leading-6 font-bold text-gray-900 text-center" id="prompt-title"></h3>
        <div class="mt-4"><p class="text-sm text-gray-500 mb-2" id="prompt-subtitle"></p><input type="text" id="prompt-input" class="w-full px-4 py-2 border border-gray-300 rounded-lg"></div>
        <div class="flex items-center justify-end mt-4 space-x-3"><button id="prompt-cancel-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg">Cancel</button><button id="prompt-ok-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg">OK</button></div>
    </div>
</div>
<div id="export-modal" class="fixed inset-0 bg-gray-900 bg-opacity-60 hidden items-center justify-center z-50">
    <div class="relative mx-auto p-6 border w-full max-w-lg shadow-xl rounded-xl bg-white">
        <h3 class="text-xl leading-6 font-bold text-gray-900">Save Graph Data</h3>
        <div class="mt-4"><textarea id="export-output" readonly class="w-full h-48 p-2 border bg-gray-100 rounded-lg font-mono text-sm"></textarea></div>
        <div class="mt-4 flex flex-wrap justify-end gap-3"><button id="download-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg">Download</button><button id="copy-btn" class="px-4 py-2 bg-green-600 text-white rounded-lg">Copy</button><button id="export-close-btn" class="px-4 py-2 bg-gray-200 text-gray-800 rounded-lg">Close</button></div>
    </div>
</div>
<div id="confirm-modal" class="fixed inset-0 bg-gray-900 bg-opacity-60 hidden items-center justify-center z-50">
    <div class="relative mx-auto p-6 border w-full max-w-sm shadow-xl rounded-xl bg-white">
        <h3 class="text-xl leading-6 font-bold text-gray-900 text-center" id="confirm-title">Are you sure?</h3>
        <div class="mt-2 px-7 py-4"><p class="text-base text-gray-600" id="confirm-message"></p></div>
        <div class="flex items-center justify-center space-x-4 px-4 py-2"><button id="confirm-cancel-btn" class="w-1/2 px-4 py-2 bg-gray-200 rounded-lg">Cancel</button><button id="confirm-ok-btn" class="w-1/2 px-4 py-2 bg-red-600 text-white rounded-lg">OK</button></div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvas = document.getElementById('graph-canvas');
        const ctx = canvas.getContext('2d');

        // --- Camera/Viewport State ---
        let camera = { x: 0, y: 0 };
        let isPanning = false;
        let spacebarPressed = false;

        // --- Graph Data ---
        let nodes = [], edges = [], nodeIdCounter = 0;

        // --- UI Elements & State ---
        const nodeForm=document.getElementById('node-form'), multiSelectForm=document.getElementById('multi-select-form'), selectionCountSpan=document.getElementById('selection-count'), multiNodeColorInput=document.getElementById('multi-node-color'), applyColorBtn=document.getElementById('apply-color-btn'), duplicateBtn=document.getElementById('duplicate-btn'), nodeFormTitle=document.getElementById('node-form-title'), nodeValueInput=document.getElementById('node-value'), nodeColorInput=document.getElementById('node-color'), nodeActionBtn=document.getElementById('node-action-btn'), deleteSingleBtn=document.getElementById('delete-single-btn'), deleteMultiBtn=document.getElementById('delete-multi-btn'), graphDataInput=document.getElementById('graph-data-input'), importTextBtn=document.getElementById('import-text-btn'), importFileBtn=document.getElementById('import-file-btn'), filePicker=document.getElementById('file-picker'), exportBtn=document.getElementById('export-btn'), clearBtn=document.getElementById('clear-btn');
        const NODE_RADIUS = 30;
        let selection = { nodes: new Set(), edges: new Set() };
        let selectionBox = null;

        // --- Modal Elements ---
        const messageModal=document.getElementById('message-modal'), modalMessage=document.getElementById('modal-message'), modalCloseBtn=document.getElementById('modal-close-btn'), promptModal=document.getElementById('prompt-modal'), promptTitle=document.getElementById('prompt-title'), promptSubtitle=document.getElementById('prompt-subtitle'), promptInput=document.getElementById('prompt-input'), promptOkBtn=document.getElementById('prompt-ok-btn'), promptCancelBtn=document.getElementById('prompt-cancel-btn'), exportModal=document.getElementById('export-modal'), exportOutput=document.getElementById('export-output'), copyBtn=document.getElementById('copy-btn'), downloadBtn=document.getElementById('download-btn'), exportCloseBtn=document.getElementById('export-close-btn'), confirmModal=document.getElementById('confirm-modal'), confirmTitle=document.getElementById('confirm-title'), confirmMessage=document.getElementById('confirm-message'), confirmOkBtn=document.getElementById('confirm-ok-btn'), confirmCancelBtn=document.getElementById('confirm-cancel-btn');
        let promptResolver=null, confirmResolver=null;

        // --- Modal Logic ---
        function showMessage(msg) { modalMessage.textContent=msg; messageModal.classList.remove('hidden'); messageModal.classList.add('flex'); }
        modalCloseBtn.addEventListener('click',()=>messageModal.classList.add('hidden'));
        function showCustomPrompt(title, subtitle='') { promptTitle.textContent=title; promptSubtitle.textContent=subtitle; promptInput.value=''; promptModal.classList.remove('hidden'); promptModal.classList.add('flex'); setTimeout(()=>promptInput.focus(),50); return new Promise(r=>{promptResolver=r;}); }
        function closePrompt(v){ if(promptResolver){promptResolver(v);promptResolver=null;} promptModal.classList.add('hidden');}
        promptOkBtn.addEventListener('click',()=>closePrompt(promptInput.value));promptCancelBtn.addEventListener('click',()=>closePrompt(null));promptInput.addEventListener('keydown',e=>{if(e.key==='Enter')closePrompt(promptInput.value);if(e.key==='Escape')closePrompt(null);});
        function showConfirm(title, msg){confirmTitle.textContent=title;confirmMessage.textContent=msg;confirmModal.classList.remove('hidden');confirmModal.classList.add('flex');return new Promise(r=>{confirmResolver=r;});}
        function closeConfirm(v){if(confirmResolver){confirmResolver(v);confirmResolver=null;}confirmModal.classList.add('hidden');}
        confirmOkBtn.addEventListener('click',()=>closeConfirm(true));confirmCancelBtn.addEventListener('click',()=>closeConfirm(false));
        exportCloseBtn.addEventListener('click',()=>exportModal.classList.add('hidden'));copyBtn.addEventListener('click',()=>{exportOutput.select();document.execCommand('copy');copyBtn.textContent='Copied!';setTimeout(()=>{copyBtn.textContent='Copy';},2000);});downloadBtn.addEventListener('click',()=>{const t=exportOutput.value,b=new Blob([t],{type:'application/json'}),u=URL.createObjectURL(b),a=document.createElement('a');a.href=u;a.download=`graph-${Date.now()}.json`;document.body.appendChild(a);a.click();document.body.removeChild(a);URL.revokeObjectURL(u);});

        // --- UI Control Logic ---
        function updateControlPanel() { const s=selection.nodes.size; if(s===1){const n=findNodeById(selection.nodes.values().next().value);setControlMode('edit',n);}else if(s>1){setControlMode('multi');}else{setControlMode('add');}}
        function setControlMode(m,n=null){
            nodeForm.classList.toggle('hidden',m==='multi');
            multiSelectForm.classList.toggle('hidden',m!=='multi');
            deleteSingleBtn.classList.toggle('hidden', m !== 'edit');
            if(m==='edit'){nodeFormTitle.textContent='Edit Node';nodeActionBtn.textContent='Update';nodeActionBtn.className='w-full font-semibold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-200 shadow-md bg-amber-500 text-white hover:bg-amber-600';nodeValueInput.value=n.value;nodeColorInput.value=n.color;}
            else if(m==='add'){nodeFormTitle.textContent='Add Node';nodeActionBtn.textContent='Add';nodeActionBtn.className='w-full font-semibold py-2 px-4 rounded-lg focus:outline-none focus:ring-2 focus:ring-offset-2 transition duration-200 shadow-md bg-blue-600 text-white hover:bg-blue-700';nodeValueInput.value='';}
            else if(m==='multi'){selectionCountSpan.textContent=selection.nodes.size;}
        }

        // --- Drawing Functions ---
        function draw() {
            ctx.save();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawGrid();
            ctx.translate(camera.x, camera.y);
            edges.forEach(edge => drawEdge(edge));
            nodes.forEach(node => drawNode(node));
            ctx.restore();
            if (selectionBox) drawSelectionBox();
        }

        function drawGrid() {
            const gridSize = 50;
            ctx.beginPath();
            ctx.strokeStyle = '#e5e7eb';
            let startX = camera.x % gridSize;
            while (startX < 0) startX += gridSize;
            let startY = camera.y % gridSize;
            while (startY < 0) startY += gridSize;
            for (let x = startX; x < canvas.width; x += gridSize) { ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); }
            for (let y = startY; y < canvas.height; y += gridSize) { ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); }
            ctx.stroke();
        }

        function drawNode(node) {
            const isSelected=selection.nodes.has(node.id),nodeColor=node.color||'#3b82f6';
            ctx.beginPath();ctx.arc(node.x,node.y,NODE_RADIUS,0,Math.PI*2);ctx.fillStyle=nodeColor;ctx.fill();
            ctx.strokeStyle=isSelected?'#f59e0b':darkenColor(nodeColor,30);ctx.lineWidth=isSelected?5:3;
            ctx.stroke();ctx.closePath();ctx.fillStyle=getContrastColor(nodeColor);ctx.font='bold 16px Inter';
            ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(node.value,node.x,node.y);
        }
        function drawEdge(edge) {
            const fromNode=findNodeById(edge.from),toNode=findNodeById(edge.to);if(!fromNode||!toNode)return;
            const isSelected=selection.edges.has(edge),reciprocal=edges.some(e=>e.from===toNode.id&&e.to===fromNode.id),headlen=10;
            let angle,endX,endY,controlX,controlY;ctx.strokeStyle=isSelected?'#f59e0b':'#4b5563';ctx.fillStyle=isSelected?'#f59e0b':'#4b5563';ctx.lineWidth=isSelected?4:2;
            if(reciprocal){const c=20,dx=toNode.x-fromNode.x,dy=toNode.y-fromNode.y,lA=Math.atan2(dy,dx),mX=(fromNode.x+toNode.x)/2,mY=(fromNode.y+toNode.y)/2;controlX=mX+c*Math.cos(lA+Math.PI/2);controlY=mY+c*Math.sin(lA+Math.PI/2);const sA=Math.atan2(controlY-fromNode.y,controlX-fromNode.x),eA=Math.atan2(toNode.y-controlY,toNode.x-controlX),sX=fromNode.x+NODE_RADIUS*Math.cos(sA),sY=fromNode.y+NODE_RADIUS*Math.sin(sA);endX=toNode.x-NODE_RADIUS*Math.cos(eA);endY=toNode.y-NODE_RADIUS*Math.sin(eA);ctx.beginPath();ctx.moveTo(sX,sY);ctx.quadraticCurveTo(controlX,controlY,endX,endY);ctx.stroke();angle=Math.atan2(endY-controlY,endX-controlX);}else{const dx=toNode.x-fromNode.x,dy=toNode.y-fromNode.y;angle=Math.atan2(dy,dx);const sX=fromNode.x+NODE_RADIUS*Math.cos(angle),sY=fromNode.y+NODE_RADIUS*Math.sin(angle);endX=toNode.x-NODE_RADIUS*Math.cos(angle);endY=toNode.y-NODE_RADIUS*Math.sin(angle);ctx.beginPath();ctx.moveTo(sX,sY);ctx.lineTo(endX,endY);ctx.stroke();}
            ctx.beginPath();ctx.moveTo(endX,endY);ctx.lineTo(endX-headlen*Math.cos(angle-Math.PI/6),endY-headlen*Math.sin(angle-Math.PI/6));ctx.lineTo(endX-headlen*Math.cos(angle+Math.PI/6),endY-headlen*Math.sin(angle+Math.PI/6));ctx.lineTo(endX,endY);ctx.fill();
            if(edge.value){ctx.save();const lP=reciprocal?{x:controlX,y:controlY}:{x:(fromNode.x+toNode.x)/2,y:(fromNode.y+toNode.y)/2};ctx.translate(lP.x,lP.y);const tA=Math.atan2(toNode.y-fromNode.y,toNode.x-fromNode.x);ctx.rotate(tA);if(Math.abs(tA)>Math.PI/2)ctx.rotate(Math.PI);ctx.fillStyle='#111827';ctx.font='14px Inter';ctx.textAlign='center';ctx.textBaseline='bottom';ctx.fillText(edge.value,0,-5);ctx.restore();}
        }
        function drawSelectionBox(){
            ctx.fillStyle='rgba(147, 197, 253, 0.3)';
            ctx.strokeStyle='rgba(59, 130, 246, 1)';
            ctx.lineWidth=1;
            ctx.fillRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h);
            ctx.strokeRect(selectionBox.x,selectionBox.y,selectionBox.w,selectionBox.h);
        }

        // --- Helper Functions ---
        const findNodeById=(id)=>nodes.find(n=>n.id===id);
        function darkenColor(h,p){h=h.replace('#','');let r=parseInt(h.substring(0,2),16),g=parseInt(h.substring(2,4),16),b=parseInt(h.substring(4,6),16);r=parseInt(r*(1-p/100));g=parseInt(g*(1-p/100));b=parseInt(b*(1-p/100));return `#${((1<<24)+(r<<16)+(g<<8)+b).toString(16).slice(1).padStart(6,'0')}`;}
        function getContrastColor(h){const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16);return((r*299)+(g*587)+(b*114))/1000>=128?'#000':'#fff';}
        const getMousePos=(c,e)=>({x:e.clientX-c.getBoundingClientRect().left,y:e.clientY-c.getBoundingClientRect().top});
        const screenToWorld=(x,y)=>({x:x-camera.x,y:y-camera.y});

        // --- Sizing Logic ---
        const resizeObserver=new ResizeObserver(e=>{const{width,height}=e[0].contentRect;canvas.width=width;canvas.height=height;draw();});
        resizeObserver.observe(canvas.parentElement);

        // --- Save/Load & Persistence Logic ---
        function saveState() { localStorage.setItem('graphBuilderSave', JSON.stringify({ nodes, edges, camera })); }
        function loadStateFromStorage() { const s=localStorage.getItem('graphBuilderSave');if(s){try{const l=JSON.parse(s);if(!l.nodes||!l.edges||!Array.isArray(l.nodes)||!Array.isArray(l.edges))return;nodes=l.nodes;edges=l.edges;camera=l.camera||{x:0,y:0};nodeIdCounter=nodes.length>0?Math.max(...nodes.map(n=>n.id))+1:0;}catch(e){console.error("Failed to load from local storage:",e);}}}
        exportBtn.addEventListener('click', () => { if (nodes.length === 0) return showMessage("Graph empty."); exportOutput.value = JSON.stringify({ nodes, edges, camera }, null, 2); exportModal.classList.remove('hidden'); });
        async function loadGraphState(s) { if (nodes.length > 0) { const c = await showConfirm('Replace Graph?', 'This will replace your current work.'); if (!c) return; } try { const l = JSON.parse(s); if (!l.nodes || !l.edges || !Array.isArray(l.nodes) || !Array.isArray(l.edges)) { throw new Error("Invalid format."); } nodes = l.nodes; edges = l.edges; nodeIdCounter = nodes.length > 0 ? Math.max(...nodes.map(n => n.id)) + 1 : 0; camera = l.camera || { x: 0, y: 0 }; clearSelection(); draw(); saveState(); showMessage(`Loaded ${nodes.length} nodes and ${edges.length} edges.`); } catch (e) { showMessage("Failed to load: " + e.message); } }
        importTextBtn.addEventListener('click', () => { const s = graphDataInput.value.trim(); if (!s) return showMessage("Text area is empty."); loadGraphState(s); });
        importFileBtn.addEventListener('click', () => filePicker.click());
        filePicker.addEventListener('change', e => { const f = e.target.files[0]; if (!f) return; const r = new FileReader(); r.onload = e => loadGraphState(e.target.result); r.readAsText(f); e.target.value = null; });
        clearBtn.addEventListener('click', async () => {const c=await showConfirm('Clear Canvas?','This will delete all nodes and edges. This action cannot be undone.');if(c){nodes=[];edges=[];camera={x:0,y:0};nodeIdCounter=0;clearSelection();saveState();draw();}});

        // --- Selection, Deletion, and Duplication Logic ---
        function clearSelection() { selection.nodes.clear(); selection.edges.clear(); updateControlPanel(); }
        function selectItemsInRect(rect) { const wS=screenToWorld(rect.x,rect.y),wE=screenToWorld(rect.x+rect.w,rect.y+rect.h);const x1=Math.min(wS.x,wE.x),y1=Math.min(wS.y,wE.y),x2=Math.max(wS.x,wE.x),y2=Math.max(wS.y,wE.y);clearSelection();nodes.forEach(n=>{if(n.x>x1&&n.x<x2&&n.y>y1&&n.y<y2){selection.nodes.add(n.id);}});edges.forEach(e=>{if(selection.nodes.has(e.from)&&selection.nodes.has(e.to)){selection.edges.add(e);}});updateControlPanel(); }
        async function deleteSelection(){const c=selection.nodes.size;if(c===0)return;const d=await showConfirm(`Delete ${c} Node(s)?`,`This will also remove connected edges and cannot be undone.`);if(d){const ids=new Set(selection.nodes);nodes=nodes.filter(n=>!ids.has(n.id));edges=edges.filter(e=>!ids.has(e.from)&&!ids.has(e.to));clearSelection();saveState();draw();}}
        duplicateBtn.addEventListener('click', () => { if (selection.nodes.size === 0) return; const o = 30, idMap = new Map(), newSel = new Set(); selection.nodes.forEach(id => { const oN = findNodeById(id), nN = { ...oN, id: nodeIdCounter++, x: oN.x + o, y: oN.y + o }; nodes.push(nN); idMap.set(id, nN.id); newSel.add(nN.id); }); selection.edges.forEach(e => { const nF = idMap.get(e.from), nT = idMap.get(e.to); if (nF !== undefined && nT !== undefined) { edges.push({ ...e, from: nF, to: nT }); } }); clearSelection(); newSel.forEach(id => selection.nodes.add(id)); edges.forEach(e => { if (selection.nodes.has(e.from) && selection.nodes.has(e.to)) { selection.edges.add(e); } }); updateControlPanel(); draw(); saveState(); });
        applyColorBtn.addEventListener('click', () => { const c = multiNodeColorInput.value; selection.nodes.forEach(id => { const n = findNodeById(id); if (n) n.color = c; }); draw(); saveState(); });
        deleteSingleBtn.addEventListener('click', deleteSelection);
        deleteMultiBtn.addEventListener('click', deleteSelection);


        // --- Event Handlers ---
        nodeActionBtn.addEventListener('click', () => { const v = nodeValueInput.value.trim(); if (!v) return showMessage('Node value required.'); const c = nodeColorInput.value; if (selection.nodes.size === 1) { const n = findNodeById(selection.nodes.values().next().value); if (n) { n.value = v; n.color = c; } clearSelection(); } else { const wP = screenToWorld(canvas.width / 2, canvas.height / 2); nodes.push({ id: nodeIdCounter++, value: v, color: c, x: wP.x, y: wP.y, radius: NODE_RADIUS }); nodeValueInput.value = ''; } draw(); saveState(); });
        canvas.addEventListener('dblclick', async e => {
            const mP = getMousePos(canvas, e); const wP = screenToWorld(mP.x, mP.y);
            if (nodes.some(n => Math.sqrt((wP.x - n.x) ** 2 + (wP.y - n.y) ** 2) < n.radius)) return;
            const v = await showCustomPrompt('New Node Value'); if (v && v.trim()) { nodes.push({ id: nodeIdCounter++, value: v.trim(), color: nodeColorInput.value, x: wP.x, y: wP.y, radius: NODE_RADIUS }); draw(); saveState(); }
        });

        // --- Click, Drag, Pan Logic ---
        let nodeUnderCursor = null, isDragging = false, dragStartPos = { x: 0, y: 0 }, panStartPos = { x: 0, y: 0 }, nodeStartPositions = new Map();

        window.addEventListener('keydown', e => {
            if (e.code === 'Space') { e.preventDefault(); spacebarPressed = true; if (!isPanning && !nodeUnderCursor && !selectionBox) canvas.classList.add('panning-cursor'); }
            const isModalOpen = document.querySelector('#message-modal:not(.hidden), #prompt-modal:not(.hidden), #export-modal:not(.hidden), #confirm-modal:not(.hidden)');
            const isTyping = document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA';
            if(isModalOpen || isTyping) return;
            if((e.key === 'Delete' || e.key === 'Backspace') && selection.nodes.size > 0){ e.preventDefault(); deleteSelection(); }
        });
        window.addEventListener('keyup', e => { if (e.code === 'Space') { spacebarPressed = false; canvas.classList.remove('panning-cursor'); } });

        canvas.addEventListener('mousedown', e => {
            if (e.button !== 0) return;
            const mP = getMousePos(canvas, e);
            dragStartPos = mP; isDragging = false; nodeUnderCursor = null;
            if (spacebarPressed) { isPanning = true; panStartPos = { x: camera.x, y: camera.y }; canvas.classList.add('panning-cursor'); return; }
            const wP = screenToWorld(mP.x, mP.y);
            canvas.classList.remove('node-cursor', 'node-cursor-grabbing'); let overNode = false;
            for (const n of nodes) { if (Math.sqrt((wP.x - n.x) ** 2 + (wP.y - n.y) ** 2) < n.radius) { nodeUnderCursor = n; overNode = true; break; } }
            if (overNode) canvas.classList.add('node-cursor');
            if (nodeUnderCursor) { if (selection.nodes.size > 1 && selection.nodes.has(nodeUnderCursor.id)) { nodeStartPositions.clear(); selection.nodes.forEach(id => { const n = findNodeById(id); nodeStartPositions.set(id, { x: n.x, y: n.y }); }); } else { nodeStartPositions.clear(); nodeStartPositions.set(nodeUnderCursor.id, { x: nodeUnderCursor.x, y: nodeUnderCursor.y }); } } else { selectionBox = { x: mP.x, y: mP.y, w: 0, h: 0 }; }
        });
        canvas.addEventListener('mousemove', e => {
            const mP = getMousePos(canvas, e); if (!dragStartPos) return;
            if (isPanning) { const dx = mP.x - dragStartPos.x, dy = mP.y - dragStartPos.y; camera.x = panStartPos.x + dx; camera.y = panStartPos.y + dy; draw(); return; }
            if (!isDragging && (Math.abs(mP.x - dragStartPos.x) > 5 || Math.abs(mP.y - dragStartPos.y) > 5)) { isDragging = true; if (nodeUnderCursor) canvas.classList.add('node-cursor-grabbing'); }
            if (isDragging) {
                if (nodeUnderCursor) { const dx = mP.x - dragStartPos.x, dy = mP.y - dragStartPos.y; if (selection.nodes.size > 1 && selection.nodes.has(nodeUnderCursor.id)) { selection.nodes.forEach(id => { const s = nodeStartPositions.get(id), n = findNodeById(id); n.x = s.x + dx; n.y = s.y + dy; }); } else { const s = nodeStartPositions.get(nodeUnderCursor.id); nodeUnderCursor.x = s.x + dx; nodeUnderCursor.y = s.y + dy; } } else if (selectionBox) { selectionBox.w = mP.x - selectionBox.x; selectionBox.h = mP.y - selectionBox.y; }
                draw();
            }
        });
        canvas.addEventListener('mouseup', async e => {
            canvas.classList.remove('node-cursor', 'node-cursor-grabbing', 'panning-cursor');
            if (isPanning) { isPanning = false; saveState(); }
            else if (nodeUnderCursor && !isDragging) { await handleNodeClick(nodeUnderCursor, e.ctrlKey || e.metaKey); }
            else if (selectionBox && isDragging) { selectItemsInRect(selectionBox); }
            else if (!nodeUnderCursor && !isDragging) { clearSelection(); }
            if (isDragging) saveState();
            dragStartPos = null; isDragging = false; selectionBox = null; draw();
        });
        canvas.addEventListener('mouseleave', () => { if (dragStartPos) { canvas.classList.remove('node-cursor', 'node-cursor-grabbing', 'panning-cursor'); dragStartPos = null; isDragging = false; isPanning = false; selectionBox = null; draw(); } });

        async function handleNodeClick(clickedNode, isCtrlClick = false) {
            if (isCtrlClick) { if (selection.nodes.has(clickedNode.id)) { selection.nodes.delete(clickedNode.id); } else { selection.nodes.add(clickedNode.id); } } else { if (selection.nodes.size <= 1 && !selection.nodes.has(clickedNode.id)) { const pId = selection.nodes.values().next().value; if (pId !== undefined) { const fN = findNodeById(pId), eE = edges.some(e => e.from === fN.id && e.to === clickedNode.id); if (eE) { showMessage(`Edge from "${fN.value}" to "${clickedNode.value}" exists.`); clearSelection(); } else { clearSelection(); draw(); const eV = await showCustomPrompt('Create Edge', `Edge: ${fN.value} â†’ ${clickedNode.value}`); if (eV !== null) { edges.push({ from: fN.id, to: clickedNode.id, value: eV.trim() }); saveState(); } } } else { clearSelection(); selection.nodes.add(clickedNode.id); } } else { clearSelection(); selection.nodes.add(clickedNode.id); } }
            selection.edges.clear(); edges.forEach(e => { if (selection.nodes.has(e.from) && selection.nodes.has(e.to)) { selection.edges.add(e); } }); updateControlPanel(); draw();
        }

        // Init
        loadStateFromStorage();
        updateControlPanel();
        draw();
    });
</script>
</body>
</html>
