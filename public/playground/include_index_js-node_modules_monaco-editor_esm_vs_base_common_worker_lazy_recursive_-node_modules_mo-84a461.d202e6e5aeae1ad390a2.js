(self["webpackChunkcreate_wasm_app"] = self["webpackChunkcreate_wasm_app"] || []).push([["index_js-node_modules_monaco-editor_esm_vs_base_common_worker_lazy_recursive_-node_modules_mo-84a461"],{

/***/ "../online-syntax-js/api/ConcreteGraph.mjs":
/*!*************************************************!*\
  !*** ../online-syntax-js/api/ConcreteGraph.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConcreteGraph: () => (/* binding */ ConcreteGraph)
/* harmony export */ });
/* harmony import */ var _EdgesIter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EdgesIter.mjs */ "../online-syntax-js/api/EdgesIter.mjs");
/* harmony import */ var _NodesIter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./NodesIter.mjs */ "../online-syntax-js/api/NodesIter.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_EdgesIter_mjs__WEBPACK_IMPORTED_MODULE_0__, _NodesIter_mjs__WEBPACK_IMPORTED_MODULE_1__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__]);
([_EdgesIter_mjs__WEBPACK_IMPORTED_MODULE_0__, _NodesIter_mjs__WEBPACK_IMPORTED_MODULE_1__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool





const ConcreteGraph_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ConcreteGraph_destroy(ptr);
});

class ConcreteGraph {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__.internalConstructor) {
            console.error("ConcreteGraph is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            ConcreteGraph_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    static new_() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ConcreteGraph_new();

        try {
            return new ConcreteGraph(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__.internalConstructor, result, []);
        }

        finally {
        }
    }

    /**
     * Returns the node key of the newly added node
     */
    addNode(value) {
        let functionCleanupArena = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__.CleanupArena();

        const valueSlice = _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__.DiplomatBuf.str8(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], value);

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ConcreteGraph_add_node(this.ffiValue, ...valueSlice.splat());

        try {
            return result;
        }

        finally {
            functionCleanupArena.free();

        }
    }

    deleteNode(key) {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ConcreteGraph_delete_node(this.ffiValue, key);

        try {}

        finally {
        }
    }

    addEdge(src, dst, weight) {
        let functionCleanupArena = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__.CleanupArena();

        const weightSlice = _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__.DiplomatBuf.str8(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"], weight);
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ConcreteGraph_add_edge(this.ffiValue, src, dst, ...weightSlice.splat());

        try {}

        finally {
            functionCleanupArena.free();

        }
    }

    getNodes() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ConcreteGraph_get_nodes(this.ffiValue);

        try {
            return new _NodesIter_mjs__WEBPACK_IMPORTED_MODULE_1__.NodesIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__.internalConstructor, result, []);
        }

        finally {
        }
    }

    getEdges() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_2__["default"].ConcreteGraph_get_edges(this.ffiValue);

        try {
            return new _EdgesIter_mjs__WEBPACK_IMPORTED_MODULE_0__.EdgesIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_3__.internalConstructor, result, []);
        }

        finally {
        }
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/Context.mjs":
/*!*******************************************!*\
  !*** ../online-syntax-js/api/Context.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Context: () => (/* binding */ Context)
/* harmony export */ });
/* harmony import */ var _ParseResult_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ParseResult.mjs */ "../online-syntax-js/api/ParseResult.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_ParseResult_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__]);
([_ParseResult_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool






class Context {
    #i;
    get i() {
        return this.#i;
    }
    set i(value){
        this.#i = value;
    }
    /** @internal */
    static fromFields(structObj) {
        return new Context(structObj);
    }

    #internalConstructor(structObj) {
        if (typeof structObj !== "object") {
            throw new Error("Context's constructor takes an object of Context's fields.");
        }

        if ("i" in structObj) {
            this.#i = structObj.i;
        } else {
            throw new Error("Missing required field i.");
        }

        return this;
    }

    // Return this struct in FFI function friendly format.
    // Returns an array that can be expanded with spread syntax (...)
    _intoFFI(
        functionCleanupArena,
        appendArrayMap
    ) {
        return [this.#i]
    }

    static _fromSuppliedValue(internalConstructor, obj) {
        if (internalConstructor !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor) {
            throw new Error("_fromSuppliedValue cannot be called externally.");
        }

        if (obj instanceof Context) {
            return obj;
        }

        return Context.fromFields(obj);
    }

    _writeToArrayBuffer(
        arrayBuffer,
        offset,
        functionCleanupArena,
        appendArrayMap
    ) {
        _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.writeToArrayBuffer(arrayBuffer, offset + 0, this.#i, Int32Array);
    }

    // This struct contains borrowed fields, so this takes in a list of
    // "edges" corresponding to where each lifetime's data may have been borrowed from
    // and passes it down to individual fields containing the borrow.
    // This method does not attempt to handle any dependencies between lifetimes, the caller
    // should handle this when constructing edge arrays.
    static _fromFFI(internalConstructor, primitiveValue) {
        if (internalConstructor !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor) {
            throw new Error("Context._fromFFI is not meant to be called externally. Please use the default constructor.");
        }
        let structObj = {};
        structObj.i = primitiveValue;

        return new Context(structObj);
    }


    static init() {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].Context_init();

        try {}

        finally {
        }
    }

    static parse(src) {
        let functionCleanupArena = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.CleanupArena();

        const srcSlice = _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.DiplomatBuf.str8(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], src);

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].Context_parse(...srcSlice.splat());

        try {
            return new _ParseResult_mjs__WEBPACK_IMPORTED_MODULE_0__.ParseResult(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
            functionCleanupArena.free();

        }
    }

    constructor(structObj) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/EdgeWrapper.mjs":
/*!***********************************************!*\
  !*** ../online-syntax-js/api/EdgeWrapper.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgeWrapper: () => (/* binding */ EdgeWrapper)
/* harmony export */ });
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__]);
_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// generated by diplomat-tool



const EdgeWrapper_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].EdgeWrapper_destroy(ptr);
});

class EdgeWrapper {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {
            console.error("EdgeWrapper is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            EdgeWrapper_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    src() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].EdgeWrapper_src(this.ffiValue);

        try {
            return result;
        }

        finally {
        }
    }

    dst() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].EdgeWrapper_dst(this.ffiValue);

        try {
            return result;
        }

        finally {
        }
    }

    weight() {
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].EdgeWrapper_weight(this.ffiValue, write.buffer);

        try {
            return write.readString8();
        }

        finally {
            write.free();
        }
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/EdgesIter.mjs":
/*!*********************************************!*\
  !*** ../online-syntax-js/api/EdgesIter.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EdgesIter: () => (/* binding */ EdgesIter)
/* harmony export */ });
/* harmony import */ var _EdgeWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EdgeWrapper.mjs */ "../online-syntax-js/api/EdgeWrapper.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_EdgeWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__]);
([_EdgeWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool




const EdgesIter_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].EdgesIter_destroy(ptr);
});

class EdgesIter {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor) {
            console.error("EdgesIter is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            EdgesIter_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    #iteratorNext() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].EdgesIter_next(this.ffiValue);

        try {
            return result === 0 ? null : new _EdgeWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__.EdgeWrapper(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    [Symbol.iterator]() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].EdgesIter_to_iterable(this.ffiValue);

        try {
            return new EdgesIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    next(){
        const out = this.#iteratorNext();

        return {
            value: out,
            done: out === null,
        };
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/LineColSpan.mjs":
/*!***********************************************!*\
  !*** ../online-syntax-js/api/LineColSpan.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineColSpan: () => (/* binding */ LineColSpan)
/* harmony export */ });
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__]);
_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// generated by diplomat-tool





class LineColSpan {
    #lineStart;
    get lineStart() {
        return this.#lineStart;
    }
    set lineStart(value){
        this.#lineStart = value;
    }
    #lineEnd;
    get lineEnd() {
        return this.#lineEnd;
    }
    set lineEnd(value){
        this.#lineEnd = value;
    }
    #colStart;
    get colStart() {
        return this.#colStart;
    }
    set colStart(value){
        this.#colStart = value;
    }
    #colEnd;
    get colEnd() {
        return this.#colEnd;
    }
    set colEnd(value){
        this.#colEnd = value;
    }
    /** @internal */
    static fromFields(structObj) {
        return new LineColSpan(structObj);
    }

    #internalConstructor(structObj) {
        if (typeof structObj !== "object") {
            throw new Error("LineColSpan's constructor takes an object of LineColSpan's fields.");
        }

        if ("lineStart" in structObj) {
            this.#lineStart = structObj.lineStart;
        } else {
            throw new Error("Missing required field lineStart.");
        }

        if ("lineEnd" in structObj) {
            this.#lineEnd = structObj.lineEnd;
        } else {
            throw new Error("Missing required field lineEnd.");
        }

        if ("colStart" in structObj) {
            this.#colStart = structObj.colStart;
        } else {
            throw new Error("Missing required field colStart.");
        }

        if ("colEnd" in structObj) {
            this.#colEnd = structObj.colEnd;
        } else {
            throw new Error("Missing required field colEnd.");
        }

        return this;
    }

    // Return this struct in FFI function friendly format.
    // Returns an array that can be expanded with spread syntax (...)
    _intoFFI(
        functionCleanupArena,
        appendArrayMap
    ) {
        return [this.#lineStart, this.#lineEnd, this.#colStart, this.#colEnd]
    }

    static _fromSuppliedValue(internalConstructor, obj) {
        if (internalConstructor !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {
            throw new Error("_fromSuppliedValue cannot be called externally.");
        }

        if (obj instanceof LineColSpan) {
            return obj;
        }

        return LineColSpan.fromFields(obj);
    }

    _writeToArrayBuffer(
        arrayBuffer,
        offset,
        functionCleanupArena,
        appendArrayMap
    ) {
        _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.writeToArrayBuffer(arrayBuffer, offset + 0, this.#lineStart, Uint32Array);
        _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.writeToArrayBuffer(arrayBuffer, offset + 4, this.#lineEnd, Uint32Array);
        _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.writeToArrayBuffer(arrayBuffer, offset + 8, this.#colStart, Uint32Array);
        _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.writeToArrayBuffer(arrayBuffer, offset + 12, this.#colEnd, Uint32Array);
    }

    // This struct contains borrowed fields, so this takes in a list of
    // "edges" corresponding to where each lifetime's data may have been borrowed from
    // and passes it down to individual fields containing the borrow.
    // This method does not attempt to handle any dependencies between lifetimes, the caller
    // should handle this when constructing edge arrays.
    static _fromFFI(internalConstructor, ptr) {
        if (internalConstructor !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {
            throw new Error("LineColSpan._fromFFI is not meant to be called externally. Please use the default constructor.");
        }
        let structObj = {};
        const lineStartDeref = (new Uint32Array(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].memory.buffer, ptr, 1))[0];
        structObj.lineStart = lineStartDeref;
        const lineEndDeref = (new Uint32Array(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].memory.buffer, ptr + 4, 1))[0];
        structObj.lineEnd = lineEndDeref;
        const colStartDeref = (new Uint32Array(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].memory.buffer, ptr + 8, 1))[0];
        structObj.colStart = colStartDeref;
        const colEndDeref = (new Uint32Array(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].memory.buffer, ptr + 12, 1))[0];
        structObj.colEnd = colEndDeref;

        return new LineColSpan(structObj);
    }


    constructor(structObj) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/LineColSpansIter.mjs":
/*!****************************************************!*\
  !*** ../online-syntax-js/api/LineColSpansIter.mjs ***!
  \****************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LineColSpansIter: () => (/* binding */ LineColSpansIter)
/* harmony export */ });
/* harmony import */ var _LineColSpan_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineColSpan.mjs */ "../online-syntax-js/api/LineColSpan.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_LineColSpan_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__]);
([_LineColSpan_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool




const LineColSpansIter_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].LineColSpansIter_destroy(ptr);
});

class LineColSpansIter {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor) {
            console.error("LineColSpansIter is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            LineColSpansIter_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    #iteratorNext() {
        const diplomatReceive = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.DiplomatReceiveBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"], 17, 4, true);


        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].LineColSpansIter_next(diplomatReceive.buffer, this.ffiValue);

        try {
            if (!diplomatReceive.resultFlag) {
                return null;
            }
            return _LineColSpan_mjs__WEBPACK_IMPORTED_MODULE_0__.LineColSpan._fromFFI(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, diplomatReceive.buffer);
        }

        finally {
            diplomatReceive.free();
        }
    }

    [Symbol.iterator]() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].LineColSpansIter_to_iterable(this.ffiValue);

        try {
            return new LineColSpansIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    next(){
        const out = this.#iteratorNext();

        return {
            value: out,
            done: out === null,
        };
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/NewNode.mjs":
/*!*******************************************!*\
  !*** ../online-syntax-js/api/NewNode.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NewNode: () => (/* binding */ NewNode)
/* harmony export */ });
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__]);
_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// generated by diplomat-tool



const NewNode_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].NewNode_destroy(ptr);
});

class NewNode {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {
            console.error("NewNode is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            NewNode_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    key() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].NewNode_key(this.ffiValue);

        try {
            return result;
        }

        finally {
        }
    }

    name() {
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].NewNode_name(this.ffiValue, write.buffer);

        try {
            return write.readString8();
        }

        finally {
            write.free();
        }
    }

    value() {
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].NewNode_value(this.ffiValue, write.buffer);

        try {
            return write.readString8();
        }

        finally {
            write.free();
        }
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/NewNodesIter.mjs":
/*!************************************************!*\
  !*** ../online-syntax-js/api/NewNodesIter.mjs ***!
  \************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NewNodesIter: () => (/* binding */ NewNodesIter)
/* harmony export */ });
/* harmony import */ var _NewNode_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NewNode.mjs */ "../online-syntax-js/api/NewNode.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_NewNode_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__]);
([_NewNode_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool




const NewNodesIter_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].NewNodesIter_destroy(ptr);
});

class NewNodesIter {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor) {
            console.error("NewNodesIter is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            NewNodesIter_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    #iteratorNext() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].NewNodesIter_next(this.ffiValue);

        try {
            return result === 0 ? null : new _NewNode_mjs__WEBPACK_IMPORTED_MODULE_0__.NewNode(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    [Symbol.iterator]() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].NewNodesIter_to_iterable(this.ffiValue);

        try {
            return new NewNodesIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    next(){
        const out = this.#iteratorNext();

        return {
            value: out,
            done: out === null,
        };
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/NodeWrapper.mjs":
/*!***********************************************!*\
  !*** ../online-syntax-js/api/NodeWrapper.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodeWrapper: () => (/* binding */ NodeWrapper)
/* harmony export */ });
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__]);
_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// generated by diplomat-tool



const NodeWrapper_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].NodeWrapper_destroy(ptr);
});

class NodeWrapper {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {
            console.error("NodeWrapper is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            NodeWrapper_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    key() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].NodeWrapper_key(this.ffiValue);

        try {
            return result;
        }

        finally {
        }
    }

    value() {
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].NodeWrapper_value(this.ffiValue, write.buffer);

        try {
            return write.readString8();
        }

        finally {
            write.free();
        }
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/NodesIter.mjs":
/*!*********************************************!*\
  !*** ../online-syntax-js/api/NodesIter.mjs ***!
  \*********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NodesIter: () => (/* binding */ NodesIter)
/* harmony export */ });
/* harmony import */ var _NodeWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NodeWrapper.mjs */ "../online-syntax-js/api/NodeWrapper.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_NodeWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__]);
([_NodeWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool




const NodesIter_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].NodesIter_destroy(ptr);
});

class NodesIter {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor) {
            console.error("NodesIter is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            NodesIter_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    #iteratorNext() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].NodesIter_next(this.ffiValue);

        try {
            return result === 0 ? null : new _NodeWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__.NodeWrapper(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    [Symbol.iterator]() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].NodesIter_to_iterable(this.ffiValue);

        try {
            return new NodesIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    next(){
        const out = this.#iteratorNext();

        return {
            value: out,
            done: out === null,
        };
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/OpCtxAndFnNames.mjs":
/*!***************************************************!*\
  !*** ../online-syntax-js/api/OpCtxAndFnNames.mjs ***!
  \***************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OpCtxAndFnNames: () => (/* binding */ OpCtxAndFnNames)
/* harmony export */ });
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__]);
_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// generated by diplomat-tool



const OpCtxAndFnNames_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].OpCtxAndFnNames_destroy(ptr);
});

class OpCtxAndFnNames {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {
            console.error("OpCtxAndFnNames is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            OpCtxAndFnNames_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/ParseResult.mjs":
/*!***********************************************!*\
  !*** ../online-syntax-js/api/ParseResult.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ParseResult: () => (/* binding */ ParseResult)
/* harmony export */ });
/* harmony import */ var _ConcreteGraph_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ConcreteGraph.mjs */ "../online-syntax-js/api/ConcreteGraph.mjs");
/* harmony import */ var _LineColSpansIter_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LineColSpansIter.mjs */ "../online-syntax-js/api/LineColSpansIter.mjs");
/* harmony import */ var _RunOperationResult_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RunOperationResult.mjs */ "../online-syntax-js/api/RunOperationResult.mjs");
/* harmony import */ var _StringError_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./StringError.mjs */ "../online-syntax-js/api/StringError.mjs");
/* harmony import */ var _StringIter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./StringIter.mjs */ "../online-syntax-js/api/StringIter.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_ConcreteGraph_mjs__WEBPACK_IMPORTED_MODULE_0__, _LineColSpansIter_mjs__WEBPACK_IMPORTED_MODULE_1__, _RunOperationResult_mjs__WEBPACK_IMPORTED_MODULE_2__, _StringError_mjs__WEBPACK_IMPORTED_MODULE_3__, _StringIter_mjs__WEBPACK_IMPORTED_MODULE_4__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__]);
([_ConcreteGraph_mjs__WEBPACK_IMPORTED_MODULE_0__, _LineColSpansIter_mjs__WEBPACK_IMPORTED_MODULE_1__, _RunOperationResult_mjs__WEBPACK_IMPORTED_MODULE_2__, _StringError_mjs__WEBPACK_IMPORTED_MODULE_3__, _StringIter_mjs__WEBPACK_IMPORTED_MODULE_4__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool








const ParseResult_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].ParseResult_destroy(ptr);
});

class ParseResult {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.internalConstructor) {
            console.error("ParseResult is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            ParseResult_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    /**
     * Writes the error message if one exists.
     */
    errorMessage() {
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].ParseResult_error_message(this.ffiValue, write.buffer);

        try {
            return write.readString8();
        }

        finally {
            write.free();
        }
    }

    /**
     * Returns an interable of error spans (if any).
     */
    errorSpans() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].ParseResult_error_spans(this.ffiValue);

        try {
            return new _LineColSpansIter_mjs__WEBPACK_IMPORTED_MODULE_1__.LineColSpansIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.internalConstructor, result, []);
        }

        finally {
        }
    }

    /**
     * Returns the DOT representation of the intermediate state named `state`.
     */
    dotOfState(state) {
        let functionCleanupArena = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.CleanupArena();

        const stateSlice = _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.DiplomatBuf.str8(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], state);
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].ParseResult_dot_of_state(this.ffiValue, ...stateSlice.splat(), write.buffer);

        try {
            return write.readString8();
        }

        finally {
            functionCleanupArena.free();

            write.free();
        }
    }

    /**
     * Lists the available states.
     */
    listStates() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].ParseResult_list_states(this.ffiValue);

        try {
            return new _StringIter_mjs__WEBPACK_IMPORTED_MODULE_4__.StringIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.internalConstructor, result, []);
        }

        finally {
        }
    }

    /**
     * Lists the available operations.
     */
    listOperations() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].ParseResult_list_operations(this.ffiValue);

        try {
            return new _StringIter_mjs__WEBPACK_IMPORTED_MODULE_4__.StringIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.internalConstructor, result, []);
        }

        finally {
        }
    }

    /**
     * Runs the operation with the given name and arguments on the provided concrete graph.
     */
    runOperation(g, opName, args) {
        let functionCleanupArena = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.CleanupArena();

        const opNameSlice = _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.DiplomatBuf.str8(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], opName);
        const argsSlice = _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.DiplomatBuf.slice(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], args, "u32");
        const diplomatReceive = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.DiplomatReceiveBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], 5, 4, true);


        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"].ParseResult_run_operation(diplomatReceive.buffer, this.ffiValue, g.ffiValue, ...opNameSlice.splat(), ...argsSlice.splat());

        try {
            if (!diplomatReceive.resultFlag) {
                const cause = new _StringError_mjs__WEBPACK_IMPORTED_MODULE_3__.StringError(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.internalConstructor, _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.ptrRead(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], diplomatReceive.buffer), []);
                throw new globalThis.Error('StringError: ' + cause.toString(), { cause });
            }
            return new _RunOperationResult_mjs__WEBPACK_IMPORTED_MODULE_2__.RunOperationResult(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.internalConstructor, _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_6__.ptrRead(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_5__["default"], diplomatReceive.buffer), []);
        }

        finally {
            functionCleanupArena.free();

            diplomatReceive.free();
        }
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/RunOperationResult.mjs":
/*!******************************************************!*\
  !*** ../online-syntax-js/api/RunOperationResult.mjs ***!
  \******************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RunOperationResult: () => (/* binding */ RunOperationResult)
/* harmony export */ });
/* harmony import */ var _NewNodesIter_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./NewNodesIter.mjs */ "../online-syntax-js/api/NewNodesIter.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_NewNodesIter_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__]);
([_NewNodesIter_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool




const RunOperationResult_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].RunOperationResult_destroy(ptr);
});

class RunOperationResult {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor) {
            console.error("RunOperationResult is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            RunOperationResult_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    [Symbol.iterator]() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].RunOperationResult_to_iterable(this.ffiValue);

        try {
            return new _NewNodesIter_mjs__WEBPACK_IMPORTED_MODULE_0__.NewNodesIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    chainedDotTrace() {
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].RunOperationResult_chained_dot_trace(this.ffiValue, write.buffer);

        try {
            return write.readString8();
        }

        finally {
            write.free();
        }
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/StringError.mjs":
/*!***********************************************!*\
  !*** ../online-syntax-js/api/StringError.mjs ***!
  \***********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringError: () => (/* binding */ StringError)
/* harmony export */ });
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__]);
_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// generated by diplomat-tool



const StringError_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].StringError_destroy(ptr);
});

class StringError {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {
            console.error("StringError is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            StringError_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    toString() {
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].StringError_to_string(this.ffiValue, write.buffer);

        try {
            return write.readString8();
        }

        finally {
            write.free();
        }
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/StringIter.mjs":
/*!**********************************************!*\
  !*** ../online-syntax-js/api/StringIter.mjs ***!
  \**********************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringIter: () => (/* binding */ StringIter)
/* harmony export */ });
/* harmony import */ var _StringWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./StringWrapper.mjs */ "../online-syntax-js/api/StringWrapper.mjs");
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_StringWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__]);
([_StringWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__, _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);
// generated by diplomat-tool




const StringIter_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].StringIter_destroy(ptr);
});

class StringIter {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor) {
            console.error("StringIter is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            StringIter_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    #iteratorNext() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].StringIter_next(this.ffiValue);

        try {
            return result === 0 ? null : new _StringWrapper_mjs__WEBPACK_IMPORTED_MODULE_0__.StringWrapper(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    [Symbol.iterator]() {

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_1__["default"].StringIter_to_iterable(this.ffiValue);

        try {
            return new StringIter(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_2__.internalConstructor, result, []);
        }

        finally {
        }
    }

    next(){
        const out = this.#iteratorNext();

        return {
            value: out,
            done: out === null,
        };
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/StringWrapper.mjs":
/*!*************************************************!*\
  !*** ../online-syntax-js/api/StringWrapper.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   StringWrapper: () => (/* binding */ StringWrapper)
/* harmony export */ });
/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ "../online-syntax-js/api/diplomat-wasm.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__]);
_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];
// generated by diplomat-tool



const StringWrapper_box_destroy_registry = new FinalizationRegistry((ptr) => {
    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].StringWrapper_destroy(ptr);
});

class StringWrapper {
    // Internal ptr reference:
    #ptr = null;

    // Lifetimes are only to keep dependencies alive.
    // Since JS won't garbage collect until there are no incoming edges.
    #selfEdge = [];

    #internalConstructor(symbol, ptr, selfEdge) {
        if (symbol !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {
            console.error("StringWrapper is an Opaque type. You cannot call its constructor.");
            return;
        }
        this.#ptr = ptr;
        this.#selfEdge = selfEdge;

        // Are we being borrowed? If not, we can register.
        if (this.#selfEdge.length === 0) {
            StringWrapper_box_destroy_registry.register(this, this.#ptr);
        }

        return this;
    }
    /** @internal */
    get ffiValue() {
        return this.#ptr;
    }


    static new_(s) {
        let functionCleanupArena = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.CleanupArena();

        const sSlice = _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.DiplomatBuf.str8(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"], s);

        const result = _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].StringWrapper_new(...sSlice.splat());

        try {
            return new StringWrapper(_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor, result, []);
        }

        finally {
            functionCleanupArena.free();

        }
    }

    toString() {
        const write = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.DiplomatWriteBuf(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]);

    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__["default"].StringWrapper_to_string(this.ffiValue, write.buffer);

        try {
            return write.readString8();
        }

        finally {
            write.free();
        }
    }

    constructor(symbol, ptr, selfEdge) {
        return this.#internalConstructor(...arguments)
    }
}
__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/api/diplomat-runtime.mjs":
/*!****************************************************!*\
  !*** ../online-syntax-js/api/diplomat-runtime.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CleanupArena: () => (/* binding */ CleanupArena),
/* harmony export */   DiplomatBuf: () => (/* binding */ DiplomatBuf),
/* harmony export */   DiplomatReceiveBuf: () => (/* binding */ DiplomatReceiveBuf),
/* harmony export */   DiplomatSlice: () => (/* binding */ DiplomatSlice),
/* harmony export */   DiplomatSlicePrimitive: () => (/* binding */ DiplomatSlicePrimitive),
/* harmony export */   DiplomatSliceStr: () => (/* binding */ DiplomatSliceStr),
/* harmony export */   DiplomatSliceStrings: () => (/* binding */ DiplomatSliceStrings),
/* harmony export */   DiplomatWriteBuf: () => (/* binding */ DiplomatWriteBuf),
/* harmony export */   GarbageCollectorGrip: () => (/* binding */ GarbageCollectorGrip),
/* harmony export */   OwnedSliceLeaker: () => (/* binding */ OwnedSliceLeaker),
/* harmony export */   enumDiscriminant: () => (/* binding */ enumDiscriminant),
/* harmony export */   exposeConstructor: () => (/* binding */ exposeConstructor),
/* harmony export */   internalConstructor: () => (/* binding */ internalConstructor),
/* harmony export */   maybePaddingFields: () => (/* binding */ maybePaddingFields),
/* harmony export */   optionToArgsForCalling: () => (/* binding */ optionToArgsForCalling),
/* harmony export */   optionToBufferForCalling: () => (/* binding */ optionToBufferForCalling),
/* harmony export */   ptrRead: () => (/* binding */ ptrRead),
/* harmony export */   readOption: () => (/* binding */ readOption),
/* harmony export */   readString16: () => (/* binding */ readString16),
/* harmony export */   readString8: () => (/* binding */ readString8),
/* harmony export */   resultFlag: () => (/* binding */ resultFlag),
/* harmony export */   withDiplomatWrite: () => (/* binding */ withDiplomatWrite),
/* harmony export */   writeOptionToArrayBuffer: () => (/* binding */ writeOptionToArrayBuffer),
/* harmony export */   writeToArrayBuffer: () => (/* binding */ writeToArrayBuffer)
/* harmony export */ });
/** For internal Diplomat use when constructing opaques or out structs.
 * This is for when we're handling items that we don't want the user to touch, like an structure that's only meant to be output, or de-referencing a pointer we're handed from WASM.
 */
const internalConstructor = Symbol("constructor");
/** For internal Diplomat use when accessing a from-fields/from-value constructor that's been overridden by a default constructor.
 * If we want to pass in arguments without also passing in internalConstructor to avoid triggering some logic we don't want, we use exposeConstructor.
 */
const exposeConstructor = Symbol("exposeConstructor");

function readString8(wasm, ptr, len) {
    const buf = new Uint8Array(wasm.memory.buffer, ptr, len);
    return (new TextDecoder("utf-8")).decode(buf)
}

function readString16(wasm, ptr, len) {
    const buf = new Uint16Array(wasm.memory.buffer, ptr, len);
    return String.fromCharCode.apply(null, buf)
}

function withDiplomatWrite(wasm, callback) {
    const write = wasm.diplomat_buffer_write_create(0);
    try {
    callback(write);
    const outStringPtr = wasm.diplomat_buffer_write_get_bytes(write);
    if (outStringPtr === null) {
        throw Error("Out of memory");
    }
    const outStringLen = wasm.diplomat_buffer_write_len(write);
    return readString8(wasm, outStringPtr, outStringLen);
    } finally {
    wasm.diplomat_buffer_write_destroy(write);
    }
}

/**
 * Get the pointer returned by an FFI function.
 *
 * It's tempting to call `(new Uint32Array(wasm.memory.buffer, FFI_func(), 1))[0]`.
 * However, there's a chance that `wasm.memory.buffer` will be resized between
 * the time it's accessed and the time it's used, invalidating the view.
 * This function ensures that the view into wasm memory is fresh.
 *
 * This is used for methods that return multiple types into a wasm buffer, where
 * one of those types is another ptr. Call this method to get access to the returned
 * ptr, so the return buffer can be freed.
 * @param {WebAssembly.Exports} wasm Provided by diplomat generated files.
 * @param {number} ptr Pointer of a pointer, to be read.
 * @returns {number} The underlying pointer.
 */
function ptrRead(wasm, ptr) {
    return (new Uint32Array(wasm.memory.buffer, ptr, 1))[0];
}

/**
 * Get the flag of a result type.
 */
function resultFlag(wasm, ptr, offset) {
    return (new Uint8Array(wasm.memory.buffer, ptr + offset, 1))[0];
}

/**
 * Get the discriminant of a Rust enum.
*/
function enumDiscriminant(wasm, ptr) {
    return (new Int32Array(wasm.memory.buffer, ptr, 1))[0]
}

/**
 * Return an array of paddingCount zeroes to be spread into a function call
 * if needsPaddingFields is true, else empty
 */
function maybePaddingFields(needsPaddingFields, paddingCount) {
    if (needsPaddingFields) {
        return Array(paddingCount).fill(0);
    } else {
        return [];
    }
}

/**
* Write a value of width `width` to a an ArrayBuffer `arrayBuffer`
* at byte offset `offset`, treating it as a buffer of kind `typedArrayKind`
* (which is a `TypedArray` variant like `Uint8Array` or `Int16Array`)
*/
function writeToArrayBuffer(arrayBuffer, offset, value, typedArrayKind) {
    let buffer = new typedArrayKind(arrayBuffer, offset);
    buffer[0] = value;
}

/**
* Take `jsValue` and write it to arrayBuffer at offset `offset` if it is non-null
* calling `writeToArrayBufferCallback(arrayBuffer, offset, jsValue)` to write to the buffer,
* also writing a tag bit.
*
* `size` and `align` are the size and alignment of T, not of Option<T>
*/
function writeOptionToArrayBuffer(arrayBuffer, offset, jsValue, size, align, writeToArrayBufferCallback) {
    // perform a nullish check, not a null check,
    // we want identical behavior for undefined
    if (jsValue != null) {
        writeToArrayBufferCallback(arrayBuffer, offset, jsValue);
        writeToArrayBuffer(arrayBuffer, offset + size, 1, Uint8Array);
    }
}

/**
* For Option<T> of given size/align (of T, not the overall option type),
* return an array of fields suitable for passing down to a parameter list.
*
* Calls writeToArrayBufferCallback(arrayBuffer, offset, jsValue) for non-null jsValues
*
* This array will have size<T>/align<T> elements for the actual T, then one element
* for the is_ok bool, and then align<T> - 1 elements for padding.
*
* See wasm_abi_quirks.md's section on Unions for understanding this ABI.
*/
function optionToArgsForCalling(jsValue, size, align, writeToArrayBufferCallback) {
    let args;
    // perform a nullish check, not a null check,
    // we want identical behavior for undefined
    if (jsValue != null) {
        let buffer;
        // We need our originator array to be properly aligned
        if (align == 8) {
            buffer = new BigUint64Array(size / align);
        } else if (align == 4) {
            buffer = new Uint32Array(size / align);
        } else if (align == 2) {
            buffer = new Uint16Array(size / align);
        } else {
            buffer = new Uint8Array(size / align);
        }


        writeToArrayBufferCallback(buffer.buffer, 0, jsValue);
        args = Array.from(buffer);
        args.push(1);
    } else {
        args = Array(size / align).fill(0);
        args.push(0);
    }

    // Unconditionally add padding
    args = args.concat(Array(align - 1).fill(0));
    return args;
}

function optionToBufferForCalling(wasm, jsValue, size, align, allocator, writeToArrayBufferCallback) {
    let buf = DiplomatBuf.struct(wasm, size, align);

    let buffer;
    // Add 1 to the size since we're also accounting for the 0 or 1 is_ok field:
    if (align == 8) {
        buffer = new BigUint64Array(wasm.memory.buffer, buf, size / align + 1);
    } else if (align == 4) {
        buffer = new Uint32Array(wasm.memory.buffer, buf, size / align + 1);
    } else if (align == 2) {
        buffer = new Uint16Array(wasm.memory.buffer, buf, size / align + 1);
    } else {
        buffer = new Uint8Array(wasm.memory.buffer, buf, size / align + 1);
    }

    buffer.fill(0);

    if (jsValue != null) {
        writeToArrayBufferCallback(buffer.buffer, 0, jsValue);
        buffer[buffer.length - 1] = 1;
    }

    allocator.alloc(buf);
}


/**
* Given `ptr` in Wasm memory, treat it as an Option<T> with size for type T,
* and return the converted T (converted using `readCallback(wasm, ptr)`) if the Option is Some
* else None.
*/
function readOption(wasm, ptr, size, readCallback) {
    // Don't need the alignment: diplomat types don't have overridden alignment,
    // so the flag will immediately be after the inner struct.
    let flag = resultFlag(wasm, ptr, size);
    if (flag) {
        return readCallback(wasm, ptr);
    } else {
        return null;
    }
}

/**
 * A wrapper around a slice of WASM memory that can be freed manually or
 * automatically by the garbage collector.
 *
 * This type is necessary for Rust functions that take a `&str` or `&[T]`, since
 * they can create an edge to this object if they borrow from the str/slice,
 * or we can manually free the WASM memory if they don't.
 */
class DiplomatBuf {
    static str8 = (wasm, string) => {
    var utf8Length = 0;
    for (const codepointString of string) {
        let codepoint = codepointString.codePointAt(0);
        if (codepoint < 0x80) {
        utf8Length += 1
        } else if (codepoint < 0x800) {
        utf8Length += 2
        } else if (codepoint < 0x10000) {
        utf8Length += 3
        } else {
        utf8Length += 4
        }
    }

    const ptr = wasm.diplomat_alloc(utf8Length, 1);

    const result = (new TextEncoder()).encodeInto(string, new Uint8Array(wasm.memory.buffer, ptr, utf8Length));
    console.assert(string.length === result.read && utf8Length === result.written, "UTF-8 write error");

    return new DiplomatBuf(ptr, utf8Length, () => wasm.diplomat_free(ptr, utf8Length, 1));
    }

    static str16 = (wasm, string) => {
    const byteLength = string.length * 2;
    const ptr = wasm.diplomat_alloc(byteLength, 2);

    const destination = new Uint16Array(wasm.memory.buffer, ptr, string.length);
    for (let i = 0; i < string.length; i++) {
        destination[i] = string.charCodeAt(i);
    }

    return new DiplomatBuf(ptr, string.length, () => wasm.diplomat_free(ptr, byteLength, 2));
    }

    static sliceWrapper = (wasm, buf) => {
        const ptr = wasm.diplomat_alloc(8, 4);
        let dst = new Uint32Array(wasm.memory.buffer, ptr, 2);

        dst[0] = buf.ptr;
        dst[1] = buf.size;
        return new DiplomatBuf(ptr, 8, () => {
            wasm.diplomat_free(ptr, 8, 4);
            buf.free();
        });
    }

    static slice = (wasm, list, rustType) => {
    const elementSize = rustType === "u8" || rustType === "i8" || rustType === "boolean" ? 1 :
        rustType === "u16" || rustType === "i16" ? 2 :
        rustType === "u64" || rustType === "i64" || rustType === "f64" ? 8 :
            4;

    const byteLength = list.length * elementSize;
    const ptr = wasm.diplomat_alloc(byteLength, elementSize);

    /**
     * Create an array view of the buffer. This gives us the `set` method which correctly handles untyped values
     */
    const destination =
        rustType === "u8" || rustType === "boolean" ? new Uint8Array(wasm.memory.buffer, ptr, byteLength) :
        rustType === "i8" ? new Int8Array(wasm.memory.buffer, ptr, byteLength) :
            rustType === "u16" ? new Uint16Array(wasm.memory.buffer, ptr, byteLength) :
            rustType === "i16" ? new Int16Array(wasm.memory.buffer, ptr, byteLength) :
                rustType === "i32" ? new Int32Array(wasm.memory.buffer, ptr, byteLength) :
                rustType === "u64" ? new BigUint64Array(wasm.memory.buffer, ptr, byteLength) :
                    rustType === "i64" ? new BigInt64Array(wasm.memory.buffer, ptr, byteLength) :
                    rustType === "f32" ? new Float32Array(wasm.memory.buffer, ptr, byteLength) :
                        rustType === "f64" ? new Float64Array(wasm.memory.buffer, ptr, byteLength) :
                        new Uint32Array(wasm.memory.buffer, ptr, byteLength);
    destination.set(list);

    return new DiplomatBuf(ptr, list.length, () => wasm.diplomat_free(ptr, byteLength, elementSize));
    }

    static strs = (wasm, strings, encoding) => {
        let encodeStr = (encoding === "string16") ? DiplomatBuf.str16 : DiplomatBuf.str8;

        const byteLength = strings.length * 4 * 2;

        const ptr = wasm.diplomat_alloc(byteLength, 4);

        const destination = new Uint32Array(wasm.memory.buffer, ptr, byteLength);

        const stringsAlloc = [];

        for (let i = 0; i < strings.length; i++) {
            stringsAlloc.push(encodeStr(wasm, strings[i]));

            destination[2 * i] = stringsAlloc[i].ptr;
            destination[(2 * i) + 1] = stringsAlloc[i].size;
        }

        return new DiplomatBuf(ptr, strings.length, () => {
            wasm.diplomat_free(ptr, byteLength, 4);
            for (let i = 0; i < stringsAlloc.length; i++) {
                stringsAlloc[i].free();
            }
        });
    }

    static struct = (wasm, size, align) => {
        const ptr = wasm.diplomat_alloc(size, align);

        return new DiplomatBuf(ptr, size, () => {
            wasm.diplomat_free(ptr, size, align);
        });
    }

    /**
     * Generated code calls one of methods these for each allocation, to either
     * free directly after the FFI call, to leak (to create a &'static), or to
     * register the buffer with the garbage collector (to create a &'a).
     */
    free;

    constructor(ptr, size, free) {
        this.ptr = ptr;
        this.size = size;
        this.free = free;
        this.leak = () => { };
        this.releaseToGarbageCollector = () => DiplomatBufferFinalizer.register(this, this.free);
    }

    splat() {
        return [this.ptr, this.size];
    }

    /**
     * Write the (ptr, len) pair to an array buffer at byte offset `offset`
     */
    writePtrLenToArrayBuffer(arrayBuffer, offset) {
        writeToArrayBuffer(arrayBuffer, offset, this.ptr, Uint32Array);
        writeToArrayBuffer(arrayBuffer, offset + 4, this.size, Uint32Array);
    }
}

/**
 * Helper class for creating and managing `diplomat_buffer_write`.
 * Meant to minimize direct calls to `wasm`.
 */
class DiplomatWriteBuf {
    leak;

    #wasm;
    #buffer;

    constructor(wasm) {
        this.#wasm = wasm;
        this.#buffer = this.#wasm.diplomat_buffer_write_create(0);

        this.leak = () => { };
    }

    free() {
        this.#wasm.diplomat_buffer_write_destroy(this.#buffer);
    }

    releaseToGarbageCollector() {
        DiplomatBufferFinalizer.register(this, this.free);
    }

    readString8() {
        return readString8(this.#wasm, this.ptr, this.size);
    }

    get buffer() {
        return this.#buffer;
    }

    get ptr() {
        return this.#wasm.diplomat_buffer_write_get_bytes(this.#buffer);
    }

    get size() {
        return this.#wasm.diplomat_buffer_write_len(this.#buffer);
    }
}

/**
 * Represents an underlying slice that we've grabbed from WebAssembly.
 * You can treat this in JS as a regular slice of primitives, but it handles additional data for you behind the scenes.
 */
class DiplomatSlice {
    #wasm;

    #bufferType;
    get bufferType() {
        return this.#bufferType;
    }

    #buffer;
    get buffer() {
        return this.#buffer;
    }

    #lifetimeEdges;

    constructor(wasm, buffer, bufferType, lifetimeEdges) {
        this.#wasm = wasm;

        const [ptr, size] = new Uint32Array(this.#wasm.memory.buffer, buffer, 2);

        this.#buffer = new bufferType(this.#wasm.memory.buffer, ptr, size);
        this.#bufferType = bufferType;

        this.#lifetimeEdges = lifetimeEdges;
    }

    getValue() {
        return this.#buffer;
    }

    [Symbol.toPrimitive]() {
        return this.getValue();
    }

    valueOf() {
        return this.getValue();
    }
}

class DiplomatSlicePrimitive extends DiplomatSlice {
    constructor(wasm, buffer, sliceType, lifetimeEdges) {
        const [ptr, size] = new Uint32Array(wasm.memory.buffer, buffer, 2);

        let arrayType;
        switch (sliceType) {
            case "u8":
            case "boolean":
                arrayType = Uint8Array;
                break;
            case "i8":
                arrayType = Int8Array;
                break;
            case "u16":
                arrayType = Uint16Array;
                break;
            case "i16":
                arrayType = Int16Array;
                break;
            case "i32":
                arrayType = Int32Array;
                break;
            case "u32":
                arrayType = Uint32Array;
                break;
            case "i64":
                arrayType = BigInt64Array;
                break;
            case "u64":
                arrayType = BigUint64Array;
                break;
            case "f32":
                arrayType = Float32Array;
                break;
            case "f64":
                arrayType = Float64Array;
                break;
            default:
                console.error("Unrecognized bufferType ", bufferType);
        }

        super(wasm, buffer, arrayType, lifetimeEdges);
    }
}

class DiplomatSliceStr extends DiplomatSlice {
    #decoder;

    constructor(wasm, buffer, stringEncoding, lifetimeEdges) {
        let encoding;
        switch (stringEncoding) {
            case "string8":
                encoding = Uint8Array;
                break;
            case "string16":
                encoding = Uint16Array;
                break;
            default:
                console.error("Unrecognized stringEncoding ", stringEncoding);
                break;
        }
        super(wasm, buffer, encoding, lifetimeEdges);

        if (stringEncoding === "string8") {
            this.#decoder = new TextDecoder('utf-8');
        }
    }

    getValue() {
        switch (this.bufferType) {
            case Uint8Array:
                return this.#decoder.decode(super.getValue());
            case Uint16Array:
                return String.fromCharCode.apply(null, super.getValue());
            default:
                return null;
        }
    }

    toString() {
        return this.getValue();
    }
}

class DiplomatSliceStrings extends DiplomatSlice {
    #strings = [];
    constructor(wasm, buffer, stringEncoding, lifetimeEdges) {
        super(wasm, buffer, Uint32Array, lifetimeEdges);

        for (let i = this.buffer.byteOffset; i < this.buffer.byteLength; i += this.buffer.BYTES_PER_ELEMENT * 2) {
            this.#strings.push(new DiplomatSliceStr(wasm, i, stringEncoding, lifetimeEdges));
        }
    }

    getValue() {
        return this.#strings;
    }
}

/**
 * A number of Rust functions in WebAssembly require a buffer to populate struct, slice, Option<> or Result<> types with information.
 * {@link DiplomatReceiveBuf} allocates a buffer in WebAssembly, which can then be passed into functions with the {@link DiplomatReceiveBuf.buffer}
 * property.
 */
class DiplomatReceiveBuf {
    #wasm;

    #size;
    #align;

    #hasResult;

    #buffer;

    constructor(wasm, size, align, hasResult) {
        this.#wasm = wasm;

        this.#size = size;
        this.#align = align;

        this.#hasResult = hasResult;

        this.#buffer = this.#wasm.diplomat_alloc(this.#size, this.#align);

        this.leak = () => { };
    }

    free() {
        this.#wasm.diplomat_free(this.#buffer, this.#size, this.#align);
    }

    get buffer() {
        return this.#buffer;
    }

    /**
     * Only for when a DiplomatReceiveBuf is allocating a buffer for an `Option<>` or a `Result<>` type.
     *
     * This just checks the last byte for a successful result (assuming that Rust's compiler does not change).
     */
    get resultFlag() {
        if (this.#hasResult) {
            return resultFlag(this.#wasm, this.#buffer, this.#size - 1);
        } else {
            return true;
        }
    }
}

/**
 * For preallocating owned slices
 *
 * Doesn't actually do anything, but helps code readability of generated code
 */
class OwnedSliceLeaker {
    constructor() {
    }

    /**
     * Leak an item
     * @param {DiplomatBuf} item
     * @returns {DiplomatBuf}
     */
    static alloc(item) {
        item.leak();
        return item;
    }
}

/**
 * For cleaning up slices inside struct _intoFFI functions.
 * Based somewhat on how the Dart backend handles slice cleanup.
 *
 * We want to ensure a slice only lasts as long as its struct, so we have a `functionCleanupArena` CleanupArena that we use in each method for any slice that needs to be cleaned up. It lasts only as long as the function is called for.
 *
 * Then we have `createWith`, which is meant for longer lasting slices. It takes an array of edges and will last as long as those edges do. Cleanup is only called later.
 */
class CleanupArena {
    #items = [];

    constructor() {
    }

    /**
     * When this arena is freed, call .free() on the given item.
     * @param {DiplomatBuf} item
     * @returns {DiplomatBuf}
     */
    alloc(item) {
        this.#items.push(item);
        return item;
    }
    /**
     * Create a new CleanupArena, append it to any edge arrays passed down, and return it.
     * @param {Array} edgeArrays
     * @returns {CleanupArena}
     */
    static createWith(...edgeArrays) {
        let self = new CleanupArena();
        for (let edgeArray of edgeArrays) {
            if (edgeArray != null) {
                edgeArray.push(self);
            }
        }
        DiplomatBufferFinalizer.register(self, self.free);
        return self;
    }

    /**
     * If given edge arrays, create a new CleanupArena, append it to any edge arrays passed down, and return it.
     * Else return the function-local cleanup arena
     * @param {CleanupArena} functionCleanupArena
     * @param {Array} edgeArrays
     * @returns {DiplomatBuf}
     */
    static maybeCreateWith(functionCleanupArena, ...edgeArrays) {
        if (edgeArrays.length > 0) {
            return CleanupArena.createWith(...edgeArrays);
        } else {
            return functionCleanupArena
        }
    }

    free() {
        this.#items.forEach((i) => {
            i.free();
        });

        this.#items.length = 0;
    }
}

/**
 * Similar to {@link CleanupArena}, but for holding on to slices until a method is called,
 * after which we rely on the GC to free them.
 *
 * This is when you may want to use a slice longer than the body of the method.
 *
 * At first glance this seems unnecessary, since we will be holding these slices in edge arrays anyway,
 * however, if an edge array ends up unused, then we do actually need something to hold it for the duration
 * of the method call.
 */
class GarbageCollectorGrip {
    #items = [];

    alloc(item) {
        this.#items.push(item);
        return item;
    }

    releaseToGarbageCollector() {
        this.#items.forEach((i) => {
            i.releaseToGarbageCollector();
        });

        this.#items.length = 0;
    }
}

const DiplomatBufferFinalizer = new FinalizationRegistry(free => free());


/***/ }),

/***/ "../online-syntax-js/api/diplomat-wasm.mjs":
/*!*************************************************!*\
  !*** ../online-syntax-js/api/diplomat-wasm.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _diplomat_config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../diplomat.config.mjs */ "../online-syntax-js/diplomat.config.mjs");
/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ "../online-syntax-js/api/diplomat-runtime.mjs");
/* harmony import */ var _wbg_online_syntax_ffi_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../wbg/online_syntax_ffi.js */ "../online-syntax-js/wbg/online_syntax_ffi.js");




const imports = {
    env: {
        diplomat_console_debug_js(ptr, len) {
            console.debug((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));
        },
        diplomat_console_error_js(ptr, len) {
            console.error((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));
        },
        diplomat_console_info_js(ptr, len) {
            console.info((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));
        },
        diplomat_console_log_js(ptr, len) {
            console.log((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));
        },
        diplomat_console_warn_js(ptr, len) {
            console.warn((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));
        },
        diplomat_throw_error_js(ptr, len) {
            throw new Error((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));
        }
    },
    wbg: _wbg_online_syntax_ffi_js__WEBPACK_IMPORTED_MODULE_2__.__wbg_get_imports().wbg
}

let wasm = await _wbg_online_syntax_ffi_js__WEBPACK_IMPORTED_MODULE_2__["default"](imports)

wasm.diplomat_init();
if (_diplomat_config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]['init'] !== undefined) {
    _diplomat_config_mjs__WEBPACK_IMPORTED_MODULE_0__["default"]['init'](wasm);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (wasm);

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "../online-syntax-js/api/index.mjs":
/*!*****************************************!*\
  !*** ../online-syntax-js/api/index.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConcreteGraph: () => (/* reexport safe */ _ConcreteGraph_mjs__WEBPACK_IMPORTED_MODULE_2__.ConcreteGraph),
/* harmony export */   Context: () => (/* reexport safe */ _Context_mjs__WEBPACK_IMPORTED_MODULE_0__.Context),
/* harmony export */   EdgeWrapper: () => (/* reexport safe */ _EdgeWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__.EdgeWrapper),
/* harmony export */   EdgesIter: () => (/* reexport safe */ _EdgesIter_mjs__WEBPACK_IMPORTED_MODULE_4__.EdgesIter),
/* harmony export */   LineColSpan: () => (/* reexport safe */ _LineColSpan_mjs__WEBPACK_IMPORTED_MODULE_1__.LineColSpan),
/* harmony export */   LineColSpansIter: () => (/* reexport safe */ _LineColSpansIter_mjs__WEBPACK_IMPORTED_MODULE_5__.LineColSpansIter),
/* harmony export */   NewNode: () => (/* reexport safe */ _NewNode_mjs__WEBPACK_IMPORTED_MODULE_6__.NewNode),
/* harmony export */   NewNodesIter: () => (/* reexport safe */ _NewNodesIter_mjs__WEBPACK_IMPORTED_MODULE_7__.NewNodesIter),
/* harmony export */   NodeWrapper: () => (/* reexport safe */ _NodeWrapper_mjs__WEBPACK_IMPORTED_MODULE_8__.NodeWrapper),
/* harmony export */   NodesIter: () => (/* reexport safe */ _NodesIter_mjs__WEBPACK_IMPORTED_MODULE_9__.NodesIter),
/* harmony export */   OpCtxAndFnNames: () => (/* reexport safe */ _OpCtxAndFnNames_mjs__WEBPACK_IMPORTED_MODULE_10__.OpCtxAndFnNames),
/* harmony export */   ParseResult: () => (/* reexport safe */ _ParseResult_mjs__WEBPACK_IMPORTED_MODULE_11__.ParseResult),
/* harmony export */   RunOperationResult: () => (/* reexport safe */ _RunOperationResult_mjs__WEBPACK_IMPORTED_MODULE_12__.RunOperationResult),
/* harmony export */   StringError: () => (/* reexport safe */ _StringError_mjs__WEBPACK_IMPORTED_MODULE_13__.StringError),
/* harmony export */   StringIter: () => (/* reexport safe */ _StringIter_mjs__WEBPACK_IMPORTED_MODULE_14__.StringIter),
/* harmony export */   StringWrapper: () => (/* reexport safe */ _StringWrapper_mjs__WEBPACK_IMPORTED_MODULE_15__.StringWrapper)
/* harmony export */ });
/* harmony import */ var _Context_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Context.mjs */ "../online-syntax-js/api/Context.mjs");
/* harmony import */ var _LineColSpan_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./LineColSpan.mjs */ "../online-syntax-js/api/LineColSpan.mjs");
/* harmony import */ var _ConcreteGraph_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ConcreteGraph.mjs */ "../online-syntax-js/api/ConcreteGraph.mjs");
/* harmony import */ var _EdgeWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EdgeWrapper.mjs */ "../online-syntax-js/api/EdgeWrapper.mjs");
/* harmony import */ var _EdgesIter_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EdgesIter.mjs */ "../online-syntax-js/api/EdgesIter.mjs");
/* harmony import */ var _LineColSpansIter_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./LineColSpansIter.mjs */ "../online-syntax-js/api/LineColSpansIter.mjs");
/* harmony import */ var _NewNode_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./NewNode.mjs */ "../online-syntax-js/api/NewNode.mjs");
/* harmony import */ var _NewNodesIter_mjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./NewNodesIter.mjs */ "../online-syntax-js/api/NewNodesIter.mjs");
/* harmony import */ var _NodeWrapper_mjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./NodeWrapper.mjs */ "../online-syntax-js/api/NodeWrapper.mjs");
/* harmony import */ var _NodesIter_mjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./NodesIter.mjs */ "../online-syntax-js/api/NodesIter.mjs");
/* harmony import */ var _OpCtxAndFnNames_mjs__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./OpCtxAndFnNames.mjs */ "../online-syntax-js/api/OpCtxAndFnNames.mjs");
/* harmony import */ var _ParseResult_mjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ParseResult.mjs */ "../online-syntax-js/api/ParseResult.mjs");
/* harmony import */ var _RunOperationResult_mjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./RunOperationResult.mjs */ "../online-syntax-js/api/RunOperationResult.mjs");
/* harmony import */ var _StringError_mjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./StringError.mjs */ "../online-syntax-js/api/StringError.mjs");
/* harmony import */ var _StringIter_mjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./StringIter.mjs */ "../online-syntax-js/api/StringIter.mjs");
/* harmony import */ var _StringWrapper_mjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./StringWrapper.mjs */ "../online-syntax-js/api/StringWrapper.mjs");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Context_mjs__WEBPACK_IMPORTED_MODULE_0__, _LineColSpan_mjs__WEBPACK_IMPORTED_MODULE_1__, _ConcreteGraph_mjs__WEBPACK_IMPORTED_MODULE_2__, _EdgeWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__, _EdgesIter_mjs__WEBPACK_IMPORTED_MODULE_4__, _LineColSpansIter_mjs__WEBPACK_IMPORTED_MODULE_5__, _NewNode_mjs__WEBPACK_IMPORTED_MODULE_6__, _NewNodesIter_mjs__WEBPACK_IMPORTED_MODULE_7__, _NodeWrapper_mjs__WEBPACK_IMPORTED_MODULE_8__, _NodesIter_mjs__WEBPACK_IMPORTED_MODULE_9__, _OpCtxAndFnNames_mjs__WEBPACK_IMPORTED_MODULE_10__, _ParseResult_mjs__WEBPACK_IMPORTED_MODULE_11__, _RunOperationResult_mjs__WEBPACK_IMPORTED_MODULE_12__, _StringError_mjs__WEBPACK_IMPORTED_MODULE_13__, _StringIter_mjs__WEBPACK_IMPORTED_MODULE_14__, _StringWrapper_mjs__WEBPACK_IMPORTED_MODULE_15__]);
([_Context_mjs__WEBPACK_IMPORTED_MODULE_0__, _LineColSpan_mjs__WEBPACK_IMPORTED_MODULE_1__, _ConcreteGraph_mjs__WEBPACK_IMPORTED_MODULE_2__, _EdgeWrapper_mjs__WEBPACK_IMPORTED_MODULE_3__, _EdgesIter_mjs__WEBPACK_IMPORTED_MODULE_4__, _LineColSpansIter_mjs__WEBPACK_IMPORTED_MODULE_5__, _NewNode_mjs__WEBPACK_IMPORTED_MODULE_6__, _NewNodesIter_mjs__WEBPACK_IMPORTED_MODULE_7__, _NodeWrapper_mjs__WEBPACK_IMPORTED_MODULE_8__, _NodesIter_mjs__WEBPACK_IMPORTED_MODULE_9__, _OpCtxAndFnNames_mjs__WEBPACK_IMPORTED_MODULE_10__, _ParseResult_mjs__WEBPACK_IMPORTED_MODULE_11__, _RunOperationResult_mjs__WEBPACK_IMPORTED_MODULE_12__, _StringError_mjs__WEBPACK_IMPORTED_MODULE_13__, _StringIter_mjs__WEBPACK_IMPORTED_MODULE_14__, _StringWrapper_mjs__WEBPACK_IMPORTED_MODULE_15__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);


































__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } });

/***/ }),

/***/ "../online-syntax-js/diplomat.config.mjs":
/*!***********************************************!*\
  !*** ../online-syntax-js/diplomat.config.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
});

/***/ }),

/***/ "../online-syntax-js/wbg/online_syntax_ffi.js":
/*!****************************************************!*\
  !*** ../online-syntax-js/wbg/online_syntax_ffi.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __wbg_get_imports: () => (/* binding */ __wbg_get_imports),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   initSync: () => (/* binding */ initSync)
/* harmony export */ });

let wasm;

const cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };

let cachedUint8ArrayMemory0 = null;

function getUint8ArrayMemory0() {
    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachedUint8ArrayMemory0;
}

function getStringFromWasm0(ptr, len) {
    ptr = ptr >>> 0;
    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}

let WASM_VECTOR_LEN = 0;

const cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length, 1) >>> 0;
        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len, 1) >>> 0;

    const mem = getUint8ArrayMemory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachedDataViewMemory0 = null;

function getDataViewMemory0() {
    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {
        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);
    }
    return cachedDataViewMemory0;
}

async function __wbg_load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

function __wbg_get_imports() {
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {
        let deferred0_0;
        let deferred0_1;
        try {
            deferred0_0 = arg0;
            deferred0_1 = arg1;
            console.error(getStringFromWasm0(arg0, arg1));
        } finally {
            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
        }
    };
    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {
        const ret = new Error();
        return ret;
    };
    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {
        const ret = arg1.stack;
        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        const len1 = WASM_VECTOR_LEN;
        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
    };
    imports.wbg.__wbindgen_init_externref_table = function() {
        const table = wasm.__wbindgen_export_3;
        const offset = table.grow(4);
        table.set(0, undefined);
        table.set(offset + 0, undefined);
        table.set(offset + 1, null);
        table.set(offset + 2, true);
        table.set(offset + 3, false);
        ;
    };

    return imports;
}

function __wbg_init_memory(imports, memory) {

}

function __wbg_finalize_init(instance, module) {
    wasm = instance.exports;
    __wbg_init.__wbindgen_wasm_module = module;
    cachedDataViewMemory0 = null;
    cachedUint8ArrayMemory0 = null;


    wasm.__wbindgen_start();
    return wasm;
}

function initSync(imports, module) {
    if (wasm !== undefined) return wasm;


    if (typeof module !== 'undefined') {
        if (Object.getPrototypeOf(module) === Object.prototype) {
            ({module} = module)
        } else {
            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')
        }
    }


    __wbg_init_memory(imports);

    if (!(module instanceof WebAssembly.Module)) {
        module = new WebAssembly.Module(module);
    }

    const instance = new WebAssembly.Instance(module, imports);

    return __wbg_finalize_init(instance, module);
}

async function __wbg_init(imports, module_or_path) {
    if (wasm !== undefined) return wasm;


    if (typeof module_or_path !== 'undefined') {
        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {
            ({module_or_path} = module_or_path)
        } else {
            console.warn('using deprecated parameters for the initialization function; pass a single object instead')
        }
    }

    if (typeof module_or_path === 'undefined') {
        module_or_path = new URL(/* asset import */ __webpack_require__(/*! online_syntax_ffi_bg.wasm */ "../online-syntax-js/wbg/online_syntax_ffi_bg.wasm"), __webpack_require__.b);
    }

    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {
        module_or_path = fetch(module_or_path);
    }

    __wbg_init_memory(imports);

    const { instance, module } = await __wbg_load(await module_or_path, imports);

    return __wbg_finalize_init(instance, module);
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__wbg_init);


/***/ }),

/***/ "../online-syntax-js/wbg/online_syntax_ffi_bg.wasm":
/*!*********************************************************!*\
  !*** ../online-syntax-js/wbg/online_syntax_ffi_bg.wasm ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "d8225a4aaa2882c15507.wasm";

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hpcc_js_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hpcc-js/wasm */ "./node_modules/@hpcc-js/wasm/dist/index.js");
/* harmony import */ var online_syntax_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! online-syntax-js */ "../online-syntax-js/api/index.mjs");
/* harmony import */ var monaco_editor_esm_vs_editor_editor_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! monaco-editor/esm/vs/editor/editor.api */ "include-loader!./node_modules/monaco-editor/esm/vs/editor/editor.api.js");
/* harmony import */ var ansi_up__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ansi_up */ "./node_modules/ansi_up/ansi_up.js");
/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3 */ "./node_modules/d3/src/index.js");
/* harmony import */ var d3_graphviz__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-graphviz */ "./node_modules/d3-graphviz/index.js");
var __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([online_syntax_js__WEBPACK_IMPORTED_MODULE_1__]);
online_syntax_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];


// import * as monaco from 'monaco-editor';
// import this to only import the features we requested from webpack.config.js:

// import 'monaco-editor/esm/vs/basic-languages/rust/rust.contribution';




// --- Initialization ---
const ansi_up = new ansi_up__WEBPACK_IMPORTED_MODULE_3__.AnsiUp();
let graphviz;
let current_res; // To store the result of a successful compilation

// --- DOM Element References ---
const outputPre = document.getElementById('output');
const svgContainer = document.getElementById('svg-container');
const stateSelector = document.getElementById('state-selector');

// --- Monaco Editor Setup ---
const initialCode = localStorage.getItem('last_code') ||
    `// Welcome! Type your Grabapl code here.
// You can find a sample bubble sort implementation to copy paste here: https://crates.io/crates/grabapl
fn foo(x: int) -> (result: int) {
    show_state(initial_state);
    // try returning a node!
    // let! new_node = add_node<1>();
    // show_state(after_adding_node_state);
    // return (result: new_node);
}`;
// TODO: add drop down with example code snippets

const editor = monaco_editor_esm_vs_editor_editor_api__WEBPACK_IMPORTED_MODULE_2__.editor.create(document.getElementById('container'), {
    value: initialCode,
    language: 'rust',
    theme: 'vs-light',
    automaticLayout: true, // Ensures the editor resizes responsively
    minimap: { enabled: false },
    roundedSelection: true,
    scrollBeyondLastLine: true,
});
window.editor = editor; // Expose editor for resizer script

let editorDecorations = editor.createDecorationsCollection();

// --- Theme Toggle Logic ---
const themeToggleBtn = document.getElementById('theme-toggle');
const themeToggleDarkIcon = document.getElementById('theme-toggle-dark-icon');
const themeToggleLightIcon = document.getElementById('theme-toggle-light-icon');
const docElement = document.documentElement;

/**
 * Sets the application theme (light/dark) and updates the UI accordingly.
 * @param {'light' | 'dark'} theme The theme to set.
 */
const setTheme = (theme) => {
    if (theme === 'dark') {
        docElement.classList.add('dark');
        themeToggleLightIcon.classList.remove('hidden');
        themeToggleDarkIcon.classList.add('hidden');
        monaco_editor_esm_vs_editor_editor_api__WEBPACK_IMPORTED_MODULE_2__.editor.setTheme('vs-dark');
        localStorage.setItem('theme', 'dark');
    } else {
        docElement.classList.remove('dark');
        themeToggleLightIcon.classList.add('hidden');
        themeToggleDarkIcon.classList.remove('hidden');
        monaco_editor_esm_vs_editor_editor_api__WEBPACK_IMPORTED_MODULE_2__.editor.setTheme('vs-light'); // Use the light theme for Monaco
        localStorage.setItem('theme', 'light');
    }
    // Re-render graphs with the new theme
    if (current_res && stateSelector.value) {
        const dot = current_res.dotOfState(stateSelector.value);
        renderGraph(dot);
    }
    updateThemeForGraph();
};

// --- Core Functions ---

/**
 * Renders a DOT string into an SVG and displays it in the preview container.
 * @param {string} dotString The DOT graph notation string.
 */
function renderGraph(dotString) {
    if (!graphviz || !dotString) {
        svgContainer.innerHTML = `<p class="text-gray-500">Could not generate graph.</p>`;
        return;
    }
    try {
        let svg = graphviz.dot(dotString);
        // replace fill="white" with fill="none" to avoid white background
        svg = svg.replace(/fill="white"/g, 'fill="none"');
        svg = svg.replace(/<text /g, '<text fill="white" ');
        // if theme is dark, set 'stroke="black"' to 'stroke="white"'
        if (docElement.classList.contains('dark')) {
            svg = svg.replace(/stroke="black"/g, 'stroke="white"');
            svg = svg.replace(/<text fill="black"/g, '<text fill="white"');
        } else {
            svg = svg.replace(/stroke="white"/g, 'stroke="black"');
            svg = svg.replace(/<text fill="white"/g, '<text fill="black"');
        }
        svgContainer.innerHTML = svg;
    } catch (error) {
        console.error("Graphviz rendering error:", error);
        svgContainer.innerHTML = `<p class="text-red-500">Error rendering graph. Check console for details.</p>`;
    }
}

/**
 * Populates the state selector dropdown with names from the compilation result.
 * @param {any} res The successful compilation result from Context.parse.
 */
function populateStateSelector(res) {
    stateSelector.innerHTML = ''; // Clear previous options

    const stateNames = [...res.listStates()].map(state => state.toString());

    if (stateNames.length === 0) {
        const option = new Option('No states found in code', '');
        option.disabled = true;
        stateSelector.add(option);
        svgContainer.innerHTML = `<p class="text-gray-500">No states were found to visualize.</p>`;
        return;
    }

    stateNames.forEach(name => stateSelector.add(new Option(name, name)));

    // Automatically render the graph for the first state
    if (stateNames.length > 0) {
        const dot = res.dotOfState(stateNames[0]);
        renderGraph(dot);
    }
}

function highlightError(line, column) {

    // Highlight the error in the editor
    editor.revealLineInCenter(line);
    editor.focus();
    editor.setPosition({ lineNumber: line, column: column });

    // show decoration
}

let MS_BETWEEN_CODE_CHANGES = 200; // Throttle code change events to avoid excessive parsing

/**
 * Wrapper around onCodeChangedInner to throttle calls.
 */
function onCodeChanged() {
    if (onCodeChanged.timeout) {
        clearTimeout(onCodeChanged.timeout);
    }
    onCodeChanged.timeout = setTimeout(onCodeChangedInner, MS_BETWEEN_CODE_CHANGES);
}

/**
 * This function is called whenever the content in the Monaco editor changes.
 * It attempts to compile the code and updates the UI accordingly.
 */
function onCodeChangedInner() {
    const current_content = editor.getValue();
    localStorage.setItem('last_code', current_content);

    try {
        // Attempt to parse/compile the code
        const res = online_syntax_js__WEBPACK_IMPORTED_MODULE_1__.Context.parse(current_content);
        current_res = res;

        // reset the error on the editor
        editorDecorations.clear()
        // now check if it was parsed successfully
        let error_msg_raw = res.errorMessage();
        if (error_msg_raw === "") {
            // Update UI for success
            outputPre.className = "w-full p-4 overflow-auto whitespace-pre-wrap text-green-400";
            outputPre.innerText = "Code compiled successfully!";
        } else {
            // error
            outputPre.className = "w-full p-4 overflow-auto whitespace-pre-wrap text-red-400";

            let error_msg = ansi_up.ansi_to_html(error_msg_raw);

            // raw error_msg text:
            // const tempDiv = document.createElement('div');
            // tempDiv.innerHTML = error_msg;
            // let error_msg_text_form = tempDiv.innerText; // Get the raw text without HTML tags
            // // delete
            // tempDiv.remove();
            //
            // let line_arr = error_msg_text_form.split("\n").map((line) => {return {value: line}});


            // for every actual span returned in the error, add a decoration
            for (const span of res.errorSpans()) {
                // console.log("Highlighting error span:", span);
                // create a range for the decoration
                const range = new monaco_editor_esm_vs_editor_editor_api__WEBPACK_IMPORTED_MODULE_2__.Range(span.lineStart, span.colStart, span.lineEnd, span.colEnd);
                editorDecorations.append([
                    {
                        range: range,
                        options: {
                            className: 'error-highlight',
                            isWholeLine: false,
                            hoverMessage: [
                                {
                                    value: "error here",
                                },
                            ],
                            // TODO: would be cool if every errorSpan had was more 'rich' in the sense that it also contained a
                            //  specific message to show. 
                            // glyphMarginHoverMessage: "glyph haha",
                        }
                    }
                ]);
            }

            // find the portion of the error message that contains the error, it's of the form input:line:column
            outputPre.innerHTML = error_msg;
            const errorMatches = error_msg.matchAll(/input:(\d+):(\d+)/g);
            let i = 0;
            const added_ids_and_spans = [];
            for (const errorMatch of errorMatches) {
                // add a link to the editor position
                const line = parseInt(errorMatch[1], 10);
                const column = parseInt(errorMatch[2], 10);

                // console.log("Replacing for match: ", errorMatch[0], "at line:", line, "column:", column);

                // replace the match in the error_msg to be a link that invokes the following function on click:
                outputPre.innerHTML = outputPre.innerHTML.replace(errorMatch[0], `<a href="#" id="error-span-link-${i}" class="text-red-400 underline">input:${line}:${column}</a>`);
                added_ids_and_spans.push({ id: `error-span-link-${i}`, line: line, column: column });
                i = i + 1;
            }
            // now attach event listeners
            for (const id_and_span of added_ids_and_spans) {
                const line = id_and_span.line;
                const column = id_and_span.column;
                // console.log(`Attaching click handler for error at line ${line}, column ${column}`);
                // find and attach a click handler to the error span
                const errorSpanLink = document.getElementById(id_and_span.id);
                i = i + 1;
                if (errorSpanLink) {
                    // console.log(`IF line ${line}, column ${column}`);

                    errorSpanLink.addEventListener('click', (e) => {
                        // console.log(`Highlighting error at line ${line}, column ${column}`);
                        e.preventDefault();
                        highlightError(line, column);
                    });
                }
            }

        }


        // Populate the dropdown with discovered states
        populateStateSelector(res);
        populateOperationSelector(res); // 
    } catch (e) {
        current_res = null; // Invalidate old results on crash

        // Update UI for error
        const errorMessage = e.cause ? e.cause.toString() : e.toString();
        outputPre.className = "w-full p-4 overflow-auto whitespace-pre-wrap font-mono text-sm text-red-400";
        outputPre.innerHTML = ansi_up.ansi_to_html(errorMessage);

        // Clear the state selector and SVG preview
        stateSelector.innerHTML = '<option value="">Fix code errors to see states</option>';
        svgContainer.innerHTML = `<p class="text-gray-500">Your state graph will appear here.</p>`;
        operationSelector.innerHTML = '<option value="">Fix code errors to see operations</option>'; // 
    }
}

// --- Event Listeners ---

// Listen for changes in the editor model
editor.onDidChangeModelContent(() => {
    onCodeChanged();
});

// Listen for changes in the state selector dropdown
stateSelector.addEventListener('change', (e) => {
    if (current_res && e.target.value) {
        renderGraph(current_res.dotOfState(e.target.value));
    }
});
themeToggleBtn.addEventListener('click', () => {
    const newTheme = docElement.classList.contains('dark') ? 'light' : 'dark';
    setTheme(newTheme);
});

//  --- DYNAMIC GRAPH BUILDER ---  //

// --- State and Variables ---
let interactiveNodes = [];
let interactiveEdges = [];
let concreteGraph = online_syntax_js__WEBPACK_IMPORTED_MODULE_1__.ConcreteGraph.new_()
let simulation, svg, svgRoot, gridG, zoomableContainer;
let selectedSourceNode = null;
let currentTransform = d3__WEBPACK_IMPORTED_MODULE_4__.zoomIdentity;
let tempNodeCoords = { x: 0, y: 0 };
let pendingEdge = null;
let currentTraceDots = [];
let rawCurrentTraceDots = [];
let currentTraceIndex = 0;
let traceGraphviz;

// --- DOM References ---
const operationSelector = document.getElementById('operation-selector');
const operationInputsContainer = document.getElementById('operation-inputs');
const addNodeInputBtn = document.getElementById('add-node-input-btn');
const runOperationBtn = document.getElementById('run-operation-btn');
const interactiveGraphContainer = document.getElementById('interactive-graph-container');
const nodeModal = document.getElementById('node-modal');
const nodeForm = document.getElementById('node-form');
const cancelNodeBtn = document.getElementById('cancel-node-btn');
const nodeNameInput = document.getElementById('node-name');
const nodeValueInput = document.getElementById('node-value');
const edgeModal = document.getElementById('edge-modal');
const edgeForm = document.getElementById('edge-form');
const cancelEdgeBtn = document.getElementById('cancel-edge-btn');
const edgeValueInput = document.getElementById('edge-value');
edgeValueInput.required = false;

const traceBox = document.getElementById('trace-box');
const prevTraceBtn = document.getElementById('prev-trace-btn');
const nextTraceBtn = document.getElementById('next-trace-btn');
const traceStepIndicator = document.getElementById('trace-step-indicator');
const traceGraphContainer = document.getElementById('trace-graph-container');
let isTraceRendering = false;

const runSimulationBtn = document.getElementById('run-simulation-btn');

// --- Delete Node Elements and Logic ---
const deleteNodeBtn = document.getElementById('delete-node-btn');
const deleteConfirmModal = document.getElementById('delete-confirm-modal');
const cancelDeleteBtn = document.getElementById('cancel-delete-btn');
const confirmDeleteBtn = document.getElementById('confirm-delete-btn');


// --- auto compile input and logic

const autoCompileInput = document.getElementById('auto-compile-timeout');
autoCompileInput.addEventListener('change', (e) => {
    const newValue = parseInt(e.target.value, 10);
    if (isNaN(newValue) || newValue < 0) {
        alert("Please enter a valid positive number for auto-compile timeout.");
        return;
    }
    MS_BETWEEN_CODE_CHANGES = newValue;
    localStorage.setItem('auto_compile_timeout', newValue);
});

// --- skip duplicate traces input
const skipDuplicateTracesInput = document.getElementById('skip-duplicate-traces');
// it's a check button
skipDuplicateTracesInput.addEventListener('change', (e) => {
    const skipDuplicates = e.target.checked;
    localStorage.setItem('skip_duplicate_traces', skipDuplicates);
    // change the label text accordingly
    if (skipDuplicates) {
        currentTraceDots = rawCurrentTraceDots.filter((dot, index, arr) => index === 0 || dot !== arr[index - 1]);
    } else {
        currentTraceDots = rawCurrentTraceDots; // Reset to raw if unchecked
    }
    currentTraceIndex = Math.min(currentTraceIndex, currentTraceDots.length - 1); // dont go out of bounds
    // render the trace graph again
    renderTraceGraph();
});

/**
 * Deletes the currently selected node and its connected edges.
 */
function deleteSelectedNode() {
    if (!selectedSourceNode) return;

    // Remove from the underlying graph representation
    concreteGraph.deleteNode(selectedSourceNode.nodeKey);

    // Filter out the node and its edges from the D3 data arrays
    interactiveNodes = interactiveNodes.filter(n => n.id !== selectedSourceNode.id);
    interactiveEdges = interactiveEdges.filter(e => e.source.id !== selectedSourceNode.id && e.target.id !== selectedSourceNode.id);

    // Reset selection state
    selectedSourceNode = null;
    deleteNodeBtn.classList.add('hidden');

    // Re-render the graph and close the modal
    updateInteractiveGraph();
    deleteConfirmModal.close();
}


// --- Core D3 Functions ---

function updateInteractiveGraph() {
    if (!svg) return;
    const isDark = docElement.classList.contains('dark');
    const nodeStrokeColor = isDark ? "#A0AEC0" : "#4A5568";
    const nodeTextColor = isDark ? "#F7FAFC" : "#1A202C";
    const edgeColor = isDark ? "#718096" : "#4A5568";

    // Edges
    const edge = svg.select(".links").selectAll("g.edge-group").data(interactiveEdges, d => `${d.source.id}-${d.target.id}`);
    edge.exit().remove();
    const edgeEnter = edge.enter().append("g").attr("class", "edge-group");
    edgeEnter.append("line").attr("stroke-width", 2).attr("marker-end", "url(#arrow)");
    edgeEnter.append("text").attr("class", "edge-label").attr("text-anchor", "middle").attr("dy", -5).style("font-size", "12px").style("pointer-events", "none");
    const edgeUpdate = edgeEnter.merge(edge);
    edgeUpdate.select("line").attr("stroke", edgeColor);
    edgeUpdate.select("text").text(d => d.value).attr("fill", nodeTextColor);

    // Nodes
    const node = svg.select(".nodes").selectAll("g.node").data(interactiveNodes, d => d.id);
    node.exit().remove();
    const nodeEnter = node.enter().append("g").attr("class", "node").call(d3__WEBPACK_IMPORTED_MODULE_4__.drag().on("start", dragstarted).on("drag", dragged).on("end", dragended));
    nodeEnter.append("circle").attr("r", 25).attr("stroke-width", 3);
    nodeEnter.append("text").attr("class", "node-value").attr("text-anchor", "middle").attr("dy", ".3em").style("font-size", "14px").style("font-weight", "bold").style("pointer-events", "none");
    nodeEnter.append("text").attr("class", "node-name").attr("text-anchor", "middle").attr("y", 40).style("font-size", "12px").style("pointer-events", "none");
    const nodeUpdate = nodeEnter.merge(node);
    nodeUpdate.select("circle").attr("fill", d => d.id === selectedSourceNode?.id ? "#63B3ED" : (isDark ? "#2D3748" : "#E2E8F0")).attr("stroke", nodeStrokeColor);
    nodeUpdate.select(".node-value").text(d => d.value).attr("fill", nodeTextColor);
    nodeUpdate.select(".node-name").text(d => d.name).attr("fill", nodeTextColor);
    nodeUpdate.on("click", (event, d) => {
        event.stopPropagation();
        if (!selectedSourceNode) {
            selectedSourceNode = d;
            deleteNodeBtn.classList.remove('hidden'); // Show delete button
        } else {
            if (selectedSourceNode.id !== d.id) {
                pendingEdge = { source: selectedSourceNode, target: d };
                edgeValueInput.value = "";
                edgeModal.showModal();
                edgeValueInput.focus();
            }
            selectedSourceNode = null;
            deleteNodeBtn.classList.add('hidden'); // Hide delete button
        }
        updateInteractiveGraph();
    });

    simulation.nodes(interactiveNodes).on("tick", ticked);
    simulation.force("link").links(interactiveEdges).id(d => d.id);
    simulation.alpha(0.3).restart();

    function ticked() {
        edgeUpdate.select("line").attr("x1", d => d.source.x).attr("y1", d => d.source.y).attr("x2", d => d.target.x).attr("y2", d => d.target.y);
        edgeUpdate.select("text").attr("x", d => (d.source.x + d.target.x) / 2).attr("y", d => (d.source.y + d.target.y) / 2);
        nodeUpdate.attr("transform", d => `translate(${d.x},${d.y})`);
    }
    function dragstarted(event, d) { if (!event.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
    function dragged(event, d) { d.fx = event.x; d.fy = event.y; }
    function dragended(event, d) { if (!event.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }
}

/**
 * Draws a smooth, pannable, and zoomable grid background.
 */
function drawGrid(gridG, width, height, transform) {
    const isDark = document.documentElement.classList.contains('dark');
    const gridColor = isDark ? "rgba(255, 255, 255, 0.1)" : "rgba(0, 0, 0, 0.1)";
    const gridSpacing = 50;

    // Calculate the spacing and offset for lines based on the current zoom level.
    // This creates the visual effect of an infinite grid.
    const lineSpacing = gridSpacing * transform.k;
    const offsetX = transform.x % lineSpacing;
    const offsetY = transform.y % lineSpacing;

    // Clear any previous grid lines to redraw them.
    gridG.selectAll("*").remove();

    // Generate the data for the new line positions.
    const xLines = d3__WEBPACK_IMPORTED_MODULE_4__.range(offsetX, width + 1, lineSpacing);
    const yLines = d3__WEBPACK_IMPORTED_MODULE_4__.range(offsetY, height + 1, lineSpacing);
    gridG.selectAll(".grid-line-v").data(xLines).enter().append("line").attr("x1", d => d).attr("y1", 0).attr("x2", d => d).attr("y2", height);
    gridG.selectAll(".grid-line-h").data(yLines).enter().append("line").attr("x1", 0).attr("y1", d => d).attr("x2", width).attr("y2", d => d);
    gridG.selectAll("line").attr("stroke", gridColor).attr("stroke-width", 1);
}

function handleResize() {
    if (!interactiveGraphContainer || !svgRoot || !gridG) return;

    const width = interactiveGraphContainer.clientWidth;
    const height = interactiveGraphContainer.clientHeight;

    svgRoot.attr("width", width).attr("height", height);
    drawGrid(gridG, width, height, currentTransform);
}

function updateThemeForGraph() {
    if (!svg) return;
    const isDark = docElement.classList.contains('dark');
    const arrowheadColor = isDark ? "#718096" : "#4A5568";
    d3__WEBPACK_IMPORTED_MODULE_4__.select("#arrow path").style("fill", arrowheadColor);
    updateInteractiveGraph();
    const width = interactiveGraphContainer.clientWidth;
    const height = interactiveGraphContainer.clientHeight;
    drawGrid(gridG, width, height, currentTransform);
}

function initInteractiveGraph() {
    const width = interactiveGraphContainer.clientWidth;
    const height = interactiveGraphContainer.clientHeight;

    svgRoot = d3__WEBPACK_IMPORTED_MODULE_4__.select(interactiveGraphContainer).append("svg").attr("width", width).attr("height", height)
        .on("dblclick", (event) => {
            event.preventDefault();
            const [mx, my] = d3__WEBPACK_IMPORTED_MODULE_4__.pointer(event);
            const tempNodeCoordsArr = currentTransform.invert([mx, my]);
            tempNodeCoords.x = tempNodeCoordsArr[0];
            tempNodeCoords.y = tempNodeCoordsArr[1];
            nodeNameInput.value = `node${interactiveNodes.length + 1}`;
            nodeValueInput.value = "";
            nodeModal.showModal();
            nodeValueInput.focus();
            nodeValueInput.select();
            // disallow browser dropdown for node values
            nodeValueInput.setAttribute("autocomplete", "off");
        })
        .on("click", () => {
            if (selectedSourceNode) {
                selectedSourceNode = null;
                deleteNodeBtn.classList.add('hidden'); // Hide on deselect
                updateInteractiveGraph();
            }
        });

    svgRoot.append("defs").append("marker").attr("id", "arrow").attr("viewBox", "0 -5 10 10").attr("refX", 33).attr("refY", 0).attr("markerWidth", 6).attr("markerHeight", 6).attr("orient", "auto").append("path").attr("d", "M0,-5L10,0L0,5").attr("class", "arrowhead");

    gridG = svgRoot.append("g").attr("class", "grid");

    zoomableContainer = svgRoot.append("g");
    svg = zoomableContainer; // Main container for nodes and links
    svg.append("g").attr("class", "links");
    svg.append("g").attr("class", "nodes");

    const zoomBehavior = d3__WEBPACK_IMPORTED_MODULE_4__.zoom().scaleExtent([0.1, 8]).on("zoom", (event) => {
        currentTransform = event.transform;
        zoomableContainer.attr("transform", currentTransform);
        drawGrid(gridG, interactiveGraphContainer.clientWidth, interactiveGraphContainer.clientHeight, currentTransform);
    });
    svgRoot.call(zoomBehavior).on("dblclick.zoom", null);

    drawGrid(gridG, width, height, currentTransform);

    simulation = d3__WEBPACK_IMPORTED_MODULE_4__.forceSimulation(interactiveNodes)
        .force("link", d3__WEBPACK_IMPORTED_MODULE_4__.forceLink(interactiveEdges).id(d => d.id).distance(150).strength(0.6))
        .force("charge", d3__WEBPACK_IMPORTED_MODULE_4__.forceManyBody().strength(-800))
        .force("positionX", d3__WEBPACK_IMPORTED_MODULE_4__.forceX(300))
        .force("positionY", d3__WEBPACK_IMPORTED_MODULE_4__.forceY(300));

    updateThemeForGraph();
}

// --- Event Handlers for UI ---

nodeForm.addEventListener('submit', () => {
    const name = nodeNameInput.value.trim();
    const value = nodeValueInput.value.trim();
    if (name && interactiveNodes.find(n => n.name === name)) {
        alert("A node with this name already exists.");
        return;
    }
    let nodeKey = concreteGraph.addNode(value);
    const newNode = { id: crypto.randomUUID(), name, value, x: tempNodeCoords.x, y: tempNodeCoords.y, nodeKey: nodeKey, fx: tempNodeCoords.x, fy: tempNodeCoords.y };
    interactiveNodes.push(newNode);
    updateInteractiveGraph();
    setTimeout(() => { newNode.fx = null; newNode.fy = null; }, 150);
});
cancelNodeBtn.addEventListener('click', () => nodeModal.close());

edgeForm.addEventListener('submit', () => {
    if (!pendingEdge) return;
    // if interactiveEdges already contains this edge, remove it first
    const existingEdgeIndex = interactiveEdges.findIndex(e => e.source.id === pendingEdge.source.id && e.target.id === pendingEdge.target.id);
    if (existingEdgeIndex !== -1) {
        interactiveEdges.splice(existingEdgeIndex, 1);
    }
    interactiveEdges.push({ source: pendingEdge.source, target: pendingEdge.target, value: edgeValueInput.value.trim() });
    concreteGraph.addEdge(pendingEdge.source.nodeKey, pendingEdge.target.nodeKey, edgeValueInput.value.trim());
    pendingEdge = null;
    updateInteractiveGraph();
});
cancelEdgeBtn.addEventListener('click', () => { pendingEdge = null; edgeModal.close(); });

addNodeInputBtn.addEventListener('click', () => {
    const inputCount = operationInputsContainer.children.length;
    const inputWrapper = document.createElement('div');
    inputWrapper.className = 'relative';
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.placeholder = `Input ${inputCount + 1}`;
    newInput.className = 'bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md p-2 pl-3 w-32 focus:ring-2 focus:ring-blue-500 focus:outline-none';
    const removeBtn = document.createElement('button');
    removeBtn.innerHTML = '&times;';
    removeBtn.className = 'absolute right-1 top-1/2 -translate-y-1/2 text-gray-400 hover:text-red-500 font-bold p-1 leading-none';
    removeBtn.onclick = () => {
        inputWrapper.remove();
        Array.from(operationInputsContainer.querySelectorAll('input')).forEach((inp, i) => { inp.placeholder = `Input ${i + 1}`; });
    };
    inputWrapper.appendChild(newInput);
    inputWrapper.appendChild(removeBtn);
    operationInputsContainer.appendChild(inputWrapper);
    return removeBtn.onclick;
});

runOperationBtn.addEventListener('click', () => {
    const operationName = operationSelector.value;
    if (!operationName) { alert("Please select an operation to run."); return; }
    const inputNodeNames = Array.from(operationInputsContainer.querySelectorAll('input')).map(input => input.value.trim()).filter(name => name !== "");
    executeOperation(operationName, inputNodeNames);
});

runSimulationBtn.addEventListener('click', () => {
    simulation.tick(100);
    updateInteractiveGraph();
})

// --- Delete Node Event Listeners ---
deleteNodeBtn.addEventListener('click', () => {
    if (selectedSourceNode) {
        deleteConfirmModal.showModal();
    }
});
cancelDeleteBtn.addEventListener('click', () => deleteConfirmModal.close());
confirmDeleteBtn.addEventListener('click', deleteSelectedNode);

window.addEventListener('keydown', (e) => {
    if ((e.key === 'Delete' || e.key === 'Backspace') && selectedSourceNode) {
        // Prevent typing 'Backspace' in an input field from triggering deletion
        if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
            return;
        }
        e.preventDefault();
        deleteConfirmModal.showModal();
    }
});
window.addEventListener('resize', handleResize);


// --- User-Adaptable Functions ---

/**
 * Populates the operation selector dropdown.
 */
function populateOperationSelector(res) {
    operationSelector.innerHTML = '';
    const opNames = [...res.listOperations()].map(op => op.toString());

    if (opNames.length === 0) {
        operationSelector.add(new Option('No operations found', '', true, true));
        return;
    }
    opNames.forEach(name => operationSelector.add(new Option(name, name)));
}

/**
 * This is called when the "Run" button is clicked. You have access to `interactiveNodes` and `interactiveEdges`.
 */
function executeOperation(operationName, inputNodeNames) {
    console.log("Executing operation:", operationName, "with inputs:", inputNodeNames);
    const inputNodes = inputNodeNames.map(name => interactiveNodes.find(node => node.name === name)).filter(Boolean);

    if (inputNodes.length !== inputNodeNames.length) {
        alert("One or more input nodes could not be found in the graph.");
        return;
    }

    let inputKeys = inputNodes.map(node => node.nodeKey);

    try {
        let res = current_res.runOperation(concreteGraph, operationName, inputKeys);
        let traceDotsRaw = res.chainedDotTrace();

        if (traceDotsRaw && traceDotsRaw.trim() !== "") {
            currentTraceDots = traceDotsRaw.split('---').map(dot => dot.trim()).filter(dot => dot);
            rawCurrentTraceDots = currentTraceDots; // Keep the raw trace dots for reference
            if (skipDuplicateTracesInput.checked) {
                // deduplicate consecutive identical trace dots
                currentTraceDots = currentTraceDots.filter((dot, index, arr) => index === 0 || dot !== arr[index - 1]);
            }
            // deduplicate consecutive identical trace dots
            // note: we're deduping now with skipDuplicateTracesInput
            // currentTraceDots = currentTraceDots.filter((dot, index, arr) => index === 0 || dot !== arr[index - 1]);
            currentTraceIndex = 0;
            traceBox.style.display = 'block';
            renderTraceGraph();
            traceBox.scrollIntoView({ behavior: 'smooth' });
        } else {
            currentTraceDots = [];
            traceBox.style.display = 'none';
        }

        const avgX = inputNodes.reduce((sum, n) => sum + (n.x || 0), 0) / inputNodes.length;
        const avgY = inputNodes.reduce((sum, n) => sum + (n.y || 0), 0) / inputNodes.length;

        // now make the current interactiveEdges and interactiveNodes synchronized with concreteGraph
        let newInteractiveNodes = [];
        let newInteractiveEdges = [];

        const addNode = (key, name, value) => {
            let thisX = avgX + Math.random() * 50; // Randomly offset to avoid overlap
            let thisY = avgY + Math.random() * 50; // Randomly offset to avoid overlap
            // check if the name already exists, if so, append a number to it
            let foundName = interactiveNodes.find(n => n.name === name);
            while (foundName) {
                const parts = name.match(/^(.*?)(\d+)?$/);
                const baseName = parts[1];
                const num = parts[2] ? parseInt(parts[2]) + 1 : 1;
                name = `${baseName}${num}`;
                foundName = interactiveNodes.find(n => n.name === name);
            }
            newInteractiveNodes.push({ id: crypto.randomUUID(), name, value, x: thisX, y: thisY, nodeKey: key });
        }

        for (const knownNewNode of res) {
            let nodeKey = knownNewNode.key();
            let name = knownNewNode.name();
            let value = knownNewNode.value();
            // if "new node" is actually an existing, shape matched node, then we need to just update its name
            // NOTE: this is a special case we only need to handle here, in the _concrete_ setting,
            //  since abstractly a returned node can never already exist in the abstract graph.
            let existingNode = interactiveNodes.find(n => n.nodeKey === nodeKey);
            if (existingNode) {
                existingNode.name = name; //Update name if it exists
                existingNode.value = value; // Update value if it exists
                newInteractiveNodes.push(existingNode); // Keep existing nodes
            } else {
                addNode(nodeKey, name, value);
            }
        }


        for (const node of concreteGraph.getNodes()) {
            let key = node.key();
            let value = node.value();

            let alreadyExists = newInteractiveNodes.find(n => n.nodeKey === key);
            if (alreadyExists) {
                // we added this already with a proper name
                continue;
            }

            let existingNode = interactiveNodes.find(n => n.nodeKey === key);
            if (!existingNode) {
                addNode(key, key, value);
            } else {
                existingNode.value = value; // Update value if it exists
                newInteractiveNodes.push(existingNode); // Keep existing nodes
            }
        }
        for (const edge of concreteGraph.getEdges()) {
            let sourceKey = edge.src();
            let targetKey = edge.dst();
            let value = edge.weight();

            let sourceNode = newInteractiveNodes.find(n => n.nodeKey === sourceKey);
            let targetNode = newInteractiveNodes.find(n => n.nodeKey === targetKey);

            if (sourceNode && targetNode) {
                // Check if the edge already exists
                let existingEdge = interactiveEdges.find(e => e.source.nodeKey === sourceKey && e.target.nodeKey === targetKey);
                if (!existingEdge) {
                    newInteractiveEdges.push({ source: sourceNode, target: targetNode, value });
                } else {
                    // Update the value of the existing edge if it already exists
                    existingEdge.value = value;
                    // also update the source and target nodes
                    existingEdge.source = sourceNode;
                    existingEdge.target = targetNode;
                    newInteractiveEdges.push(existingEdge);
                }
            }
        }
        // update the interactive nodes and edges
        interactiveNodes = newInteractiveNodes;
        interactiveEdges = newInteractiveEdges;
    } catch (e) {
        let errorMessage = e.cause ? e.cause.toString() : e.toString();
        alert(errorMessage);
        console.error("Error running operation:", e);
    }

    updateInteractiveGraph(); // Refresh the graph to show changes
}

function renderTraceGraph() {
    if (currentTraceDots.length === 0) {
        traceBox.style.display = 'none';
        return;
    }

    traceBox.style.display = 'block';
    const dot = currentTraceDots[currentTraceIndex];
    console.log("Rendering trace graph for index:", currentTraceIndex, "with DOT:\n", dot);

    // Apply theme adjustments to the DOT string
    // let themedDot = dot.replace(/fill="white"/g, 'fill="none"');
    // themedDot = themedDot.replace(/<text /g, '<text fill="white" ');
    // if (docElement.classList.contains('dark')) {
    //     themedDot = themedDot.replace(/stroke="black"/g, 'stroke="white"');
    //     themedDot = themedDot.replace(/<text fill="black"/g, '<text fill="white"');
    // } else {
    //     themedDot = themedDot.replace(/stroke="white"/g, 'stroke="black"');
    //     themedDot = themedDot.replace(/<text fill="white"/g, '<text fill="black"');
    // }

    let themedDot = dot;
    isTraceRendering = true; // Prevent further interactions during rendering
    traceGraphviz
        .transition(() => d3__WEBPACK_IMPORTED_MODULE_4__.transition().duration(300).ease(d3__WEBPACK_IMPORTED_MODULE_4__.easeLinear))
        .renderDot(themedDot)
        .on("end", function () {
            // // adjust the svg inside trace-graph-container to be full width and height:
            // const traceGraphSvg = document.querySelector("#trace-graph-container svg");
            // if (traceGraphSvg) {
            //     // traceGraphSvg.style.width = "100%";
            //     // traceGraphSvg.style.height = "100%";
            // }
            // scroll to the bottom of the trace box
            // traceBox.scrollIntoView({ behavior: 'smooth' });
            isTraceRendering = false; // Allow further interactions after rendering
        });

    let traceContainer = document.querySelector("#trace-graph-container");
    // disable moving around via drag and drop
    if (traceContainer) {
        traceContainer.style.pointerEvents = 'none'; // Disable pointer events to prevent dragging
    }


    traceStepIndicator.textContent = `${currentTraceIndex + 1} / ${currentTraceDots.length}`;
    prevTraceBtn.disabled = currentTraceIndex === 0;
    nextTraceBtn.disabled = currentTraceIndex === currentTraceDots.length - 1;
}


// --- Initial Load ---
async function main() {
    // Initialize panic hooks
    online_syntax_js__WEBPACK_IMPORTED_MODULE_1__.Context.init();
    // Load Graphviz WASM module
    outputPre.innerText = "Loading Graphviz WASM module...";
    graphviz = await _hpcc_js_wasm__WEBPACK_IMPORTED_MODULE_0__.Graphviz.load();

    if (localStorage.getItem("theme")) {
        setTheme(localStorage.getItem("theme"));
    }
    if (localStorage.getItem("auto_compile_timeout")) {
        MS_BETWEEN_CODE_CHANGES = parseInt(localStorage.getItem("auto_compile_timeout"), 10);
        autoCompileInput.value = MS_BETWEEN_CODE_CHANGES;
    }
    if (localStorage.getItem("skip_duplicate_traces")) {
        skipDuplicateTracesInput.checked = localStorage.getItem("skip_duplicate_traces") === 'true';
    }

    // Perform initial compilation
    onCodeChanged();
    initInteractiveGraph(); // 
    initTraceViewer();

    // add a Ctrl-S event listener to the monaco editor that immediately runs onCodeChangedInner()
    editor.addCommand(monaco_editor_esm_vs_editor_editor_api__WEBPACK_IMPORTED_MODULE_2__.KeyMod.CtrlCmd | monaco_editor_esm_vs_editor_editor_api__WEBPACK_IMPORTED_MODULE_2__.KeyCode.KeyS, () => {
        onCodeChangedInner();
    });
}

/// Advances the current trace index by respecting the value of
function advanceTrace() {
    currentTraceIndex++;
    return;
    // note: we're handling with rawCurrentTraceDots now
    // let doSkip = skipDuplicateTracesInput.checked;
    // if (doSkip) {
    //     // skip to the next unique trace dot
    //     while (currentTraceIndex < currentTraceDots.length - 1 && currentTraceDots[currentTraceIndex] === currentTraceDots[currentTraceIndex + 1]) {
    //         currentTraceIndex++;
    //     }
    // } else {
    //     // just increment the index
    //     if (currentTraceIndex < currentTraceDots.length - 1) {
    //         currentTraceIndex++;
    //     }
    // }
}

function previousTrace() {
    currentTraceIndex--;
    return;
    // note: we're handling with rawCurrentTraceDots now
    // let doSkip = skipDuplicateTracesInput.checked;
    // if (doSkip) {
    //     // skip to the previous unique trace dot
    //     while (currentTraceIndex > 0 && currentTraceDots[currentTraceIndex] === currentTraceDots[currentTraceIndex - 1]) {
    //         currentTraceIndex--;
    //     }
    // } else {
    //     // just decrement the index
    //     if (currentTraceIndex > 0) {
    //         currentTraceIndex--;
    //     }
    // }
}

function initTraceViewer() {
    traceGraphviz = d3__WEBPACK_IMPORTED_MODULE_4__.select("#trace-graph-container").graphviz({
        useWorker: false,
        fit: true,
    });

    // add child to traceGraphContainer to provide some buffer
    if (traceGraphContainer) {
        let divChild = document.createElement('div');
        divChild.className = "h-[100vh] bg-white";
        traceGraphContainer.appendChild(divChild);
    }

    prevTraceBtn.addEventListener('click', () => {
        if (isTraceRendering) return; // Prevent navigation while rendering
        if (currentTraceIndex > 0) {
            previousTrace();
            renderTraceGraph();
        }
    });

    nextTraceBtn.addEventListener('click', () => {
        if (isTraceRendering) return; // Prevent navigation while rendering
        if (currentTraceIndex < currentTraceDots.length - 1) {
            advanceTrace();
            renderTraceGraph();
        }
    });

    // add left and right arrow key listeners to navigate the trace
    traceBox.addEventListener('keydown', (e) => {
        if (isTraceRendering) return; // Prevent navigation while rendering
        if (e.key === 'ArrowLeft' && currentTraceIndex > 0) {
            previousTrace();
            renderTraceGraph();
        } else if (e.key === 'ArrowRight' && currentTraceIndex < currentTraceDots.length - 1) {
            advanceTrace();
            renderTraceGraph();
        }
    });
}

await main();

__webpack_async_result__();
} catch(e) { __webpack_async_result__(e); } }, 1);

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/base/common/worker lazy recursive ^.*$":
/*!******************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/base/common/worker/ lazy ^.*$ namespace object ***!
  \******************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./simpleWorker": "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js",
	"./simpleWorker.js": "./node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js"
};

function webpackAsyncContext(req) {
	return Promise.resolve().then(() => {
		if(!__webpack_require__.o(map, req)) {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		}

		var id = map[req];
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./node_modules/monaco-editor/esm/vs/base/common/worker lazy recursive ^.*$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "./node_modules/monaco-editor/esm/vs/editor/common/services lazy recursive ^.*$":
/*!**********************************************************************************************!*\
  !*** ./node_modules/monaco-editor/esm/vs/editor/common/services/ lazy ^.*$ namespace object ***!
  \**********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./editorBaseApi": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js"
	],
	"./editorBaseApi.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorBaseApi.js"
	],
	"./editorSimpleWorker": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"
	],
	"./editorSimpleWorker.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js"
	],
	"./editorWorker": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js"
	],
	"./editorWorker.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorker.js"
	],
	"./editorWorkerHost": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js"
	],
	"./editorWorkerHost.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/editorWorkerHost.js"
	],
	"./findSectionHeaders": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js"
	],
	"./findSectionHeaders.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/findSectionHeaders.js"
	],
	"./getIconClasses": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js"
	],
	"./getIconClasses.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/getIconClasses.js"
	],
	"./languageFeatureDebounce": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js"
	],
	"./languageFeatureDebounce.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatureDebounce.js"
	],
	"./languageFeatures": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatures.js"
	],
	"./languageFeatures.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeatures.js"
	],
	"./languageFeaturesService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js"
	],
	"./languageFeaturesService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageFeaturesService.js"
	],
	"./languageService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js"
	],
	"./languageService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js"
	],
	"./languagesAssociations": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js"
	],
	"./languagesAssociations.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js"
	],
	"./languagesRegistry": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js"
	],
	"./languagesRegistry.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js"
	],
	"./markerDecorations": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorations.js"
	],
	"./markerDecorations.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorations.js"
	],
	"./markerDecorationsService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js"
	],
	"./markerDecorationsService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/markerDecorationsService.js"
	],
	"./model": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/model.js"
	],
	"./model.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/model.js"
	],
	"./modelService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js"
	],
	"./modelService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js"
	],
	"./resolverService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js"
	],
	"./resolverService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/resolverService.js"
	],
	"./semanticTokensDto": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"
	],
	"./semanticTokensDto.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js"
	],
	"./semanticTokensProviderStyling": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js"
	],
	"./semanticTokensProviderStyling.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js"
	],
	"./semanticTokensStyling": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStyling.js"
	],
	"./semanticTokensStyling.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStyling.js"
	],
	"./semanticTokensStylingService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js"
	],
	"./semanticTokensStylingService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensStylingService.js"
	],
	"./textModelSync/textModelSync.impl": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js"
	],
	"./textModelSync/textModelSync.impl.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.impl.js"
	],
	"./textModelSync/textModelSync.protocol": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.protocol.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_textModelSync_textModelSync_protocol_js"
	],
	"./textModelSync/textModelSync.protocol.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textModelSync/textModelSync.protocol.js",
		"node_modules_monaco-editor_esm_vs_editor_common_services_textModelSync_textModelSync_protocol_js"
	],
	"./textResourceConfiguration": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js"
	],
	"./textResourceConfiguration.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js"
	],
	"./treeSitterParserService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js"
	],
	"./treeSitterParserService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js"
	],
	"./treeViewsDnd": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js"
	],
	"./treeViewsDnd.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDnd.js"
	],
	"./treeViewsDndService": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js"
	],
	"./treeViewsDndService.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/treeViewsDndService.js"
	],
	"./unicodeTextModelHighlighter": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"
	],
	"./unicodeTextModelHighlighter.js": [
		"./node_modules/monaco-editor/esm/vs/editor/common/services/unicodeTextModelHighlighter.js"
	]
};
function webpackAsyncContext(req) {
	if(!__webpack_require__.o(map, req)) {
		return Promise.resolve().then(() => {
			var e = new Error("Cannot find module '" + req + "'");
			e.code = 'MODULE_NOT_FOUND';
			throw e;
		});
	}

	var ids = map[req], id = ids[0];
	return Promise.all(ids.slice(1).map(__webpack_require__.e)).then(() => {
		return __webpack_require__(id);
	});
}
webpackAsyncContext.keys = () => (Object.keys(map));
webpackAsyncContext.id = "./node_modules/monaco-editor/esm/vs/editor/common/services lazy recursive ^.*$";
module.exports = webpackAsyncContext;

/***/ }),

/***/ "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=":
/*!**********************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII= ***!
  \**********************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAZdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuMTZEaa/1AAAAHUlEQVQYV2PYvXu3JAi7uLiAMaYAjAGTQBPYLQkAa/0Zef3qRswAAAAASUVORK5CYII=";

/***/ }),

/***/ "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjNDI0MjQyIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjNDI0MjQyIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg== ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjNDI0MjQyIi8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";

/***/ }),

/***/ "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjQzVDNUM1Ii8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==":
/*!**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjQzVDNUM1Ii8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg== ***!
  \**********************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module) => {

"use strict";
module.exports = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCA1MyAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGcgY2xpcC1wYXRoPSJ1cmwoI2NsaXAwKSI+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNNDguMDM2NCA0LjAxMDQySDQuMDA3NzlMNC4wMDc3OSAzMi4wMjg2SDQ4LjAzNjRWNC4wMTA0MlpNNC4wMDc3OSAwLjAwNzgxMjVDMS43OTcyMSAwLjAwNzgxMjUgMC4wMDUxODc5OSAxLjc5OTg0IDAuMDA1MTg3OTkgNC4wMTA0MlYzMi4wMjg2QzAuMDA1MTg3OTkgMzQuMjM5MiAxLjc5NzIxIDM2LjAzMTIgNC4wMDc3OSAzNi4wMzEySDQ4LjAzNjRDNTAuMjQ3IDM2LjAzMTIgNTIuMDM5IDM0LjIzOTIgNTIuMDM5IDMyLjAyODZWNC4wMTA0MkM1Mi4wMzkgMS43OTk4NCA1MC4yNDcgMC4wMDc4MTI1IDQ4LjAzNjQgMC4wMDc4MTI1SDQuMDA3NzlaTTguMDEwNDIgOC4wMTMwMkgxMi4wMTNWMTIuMDE1Nkg4LjAxMDQyVjguMDEzMDJaTTIwLjAxODIgOC4wMTMwMkgxNi4wMTU2VjEyLjAxNTZIMjAuMDE4MlY4LjAxMzAyWk0yNC4wMjA4IDguMDEzMDJIMjguMDIzNFYxMi4wMTU2SDI0LjAyMDhWOC4wMTMwMlpNMzYuMDI4NiA4LjAxMzAySDMyLjAyNlYxMi4wMTU2SDM2LjAyODZWOC4wMTMwMlpNNDAuMDMxMiA4LjAxMzAySDQ0LjAzMzlWMTIuMDE1Nkg0MC4wMzEyVjguMDEzMDJaTTE2LjAxNTYgMTYuMDE4Mkg4LjAxMDQyVjIwLjAyMDhIMTYuMDE1NlYxNi4wMTgyWk0yMC4wMTgyIDE2LjAxODJIMjQuMDIwOFYyMC4wMjA4SDIwLjAxODJWMTYuMDE4MlpNMzIuMDI2IDE2LjAxODJIMjguMDIzNFYyMC4wMjA4SDMyLjAyNlYxNi4wMTgyWk00NC4wMzM5IDE2LjAxODJWMjAuMDIwOEgzNi4wMjg2VjE2LjAxODJINDQuMDMzOVpNMTIuMDEzIDI0LjAyMzRIOC4wMTA0MlYyOC4wMjZIMTIuMDEzVjI0LjAyMzRaTTE2LjAxNTYgMjQuMDIzNEgzNi4wMjg2VjI4LjAyNkgxNi4wMTU2VjI0LjAyMzRaTTQ0LjAzMzkgMjQuMDIzNEg0MC4wMzEyVjI4LjAyNkg0NC4wMzM5VjI0LjAyMzRaIiBmaWxsPSIjQzVDNUM1Ii8+CjwvZz4KPGRlZnM+CjxjbGlwUGF0aCBpZD0iY2xpcDAiPgo8cmVjdCB3aWR0aD0iNTMiIGhlaWdodD0iMzYiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5jbHVkZV9pbmRleF9qcy1ub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfYmFzZV9jb21tb25fd29ya2VyX2xhenlfcmVjdXJzaXZlXy1ub2RlX21vZHVsZXNfbW8tODRhNDYxLmQyMDJlNmU1YWVhZTFhZDM5MGEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDMkM7QUFDQTtBQUNKO0FBQ21COztBQUUxRDtBQUNBLElBQUksMERBQUk7QUFDUixDQUFDOztBQUVNO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1QkFBdUIsc0VBQW1DO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSx1QkFBdUIsMERBQUk7O0FBRTNCO0FBQ0EscUNBQXFDLHNFQUFtQztBQUN4RTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsK0RBQTRCOztBQUVuRSwyQkFBMkIsOERBQTJCLE1BQU0sMERBQUk7O0FBRWhFLHVCQUF1QiwwREFBSTs7QUFFM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLElBQUksMERBQUk7O0FBRVI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLCtEQUE0Qjs7QUFFbkUsNEJBQTRCLDhEQUEyQixNQUFNLDBEQUFJO0FBQ2pFLElBQUksMERBQUk7O0FBRVI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QiwwREFBSTs7QUFFM0I7QUFDQSx1QkFBdUIscURBQVMsQ0FBQyxzRUFBbUM7QUFDcEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QiwwREFBSTs7QUFFM0I7QUFDQSx1QkFBdUIscURBQVMsQ0FBQyxzRUFBbUM7QUFDcEU7O0FBRUE7QUFDQTtBQUNB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QUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQSw2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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7Ozs7Ozs7Ozs7OztBQ3I3QkE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jcmVhdGUtd2FzbS1hcHAvLi4vb25saW5lLXN5bnRheC1qcy9hcGkvQ29uY3JldGVHcmFwaC5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvYXBpL0NvbnRleHQubWpzIiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uLi9vbmxpbmUtc3ludGF4LWpzL2FwaS9FZGdlV3JhcHBlci5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvYXBpL0VkZ2VzSXRlci5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvYXBpL0xpbmVDb2xTcGFuLm1qcyIsIndlYnBhY2s6Ly9jcmVhdGUtd2FzbS1hcHAvLi4vb25saW5lLXN5bnRheC1qcy9hcGkvTGluZUNvbFNwYW5zSXRlci5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvYXBpL05ld05vZGUubWpzIiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uLi9vbmxpbmUtc3ludGF4LWpzL2FwaS9OZXdOb2Rlc0l0ZXIubWpzIiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uLi9vbmxpbmUtc3ludGF4LWpzL2FwaS9Ob2RlV3JhcHBlci5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvYXBpL05vZGVzSXRlci5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvYXBpL09wQ3R4QW5kRm5OYW1lcy5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvYXBpL1BhcnNlUmVzdWx0Lm1qcyIsIndlYnBhY2s6Ly9jcmVhdGUtd2FzbS1hcHAvLi4vb25saW5lLXN5bnRheC1qcy9hcGkvUnVuT3BlcmF0aW9uUmVzdWx0Lm1qcyIsIndlYnBhY2s6Ly9jcmVhdGUtd2FzbS1hcHAvLi4vb25saW5lLXN5bnRheC1qcy9hcGkvU3RyaW5nRXJyb3IubWpzIiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uLi9vbmxpbmUtc3ludGF4LWpzL2FwaS9TdHJpbmdJdGVyLm1qcyIsIndlYnBhY2s6Ly9jcmVhdGUtd2FzbS1hcHAvLi4vb25saW5lLXN5bnRheC1qcy9hcGkvU3RyaW5nV3JhcHBlci5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvYXBpL2RpcGxvbWF0LXJ1bnRpbWUubWpzIiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uLi9vbmxpbmUtc3ludGF4LWpzL2FwaS9kaXBsb21hdC13YXNtLm1qcyIsIndlYnBhY2s6Ly9jcmVhdGUtd2FzbS1hcHAvLi4vb25saW5lLXN5bnRheC1qcy9hcGkvaW5kZXgubWpzIiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uLi9vbmxpbmUtc3ludGF4LWpzL2RpcGxvbWF0LmNvbmZpZy5tanMiLCJ3ZWJwYWNrOi8vY3JlYXRlLXdhc20tYXBwLy4uL29ubGluZS1zeW50YXgtanMvd2JnL29ubGluZV9zeW50YXhfZmZpLmpzIiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uL2luZGV4LmpzIiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi93b3JrZXIvIGxhenkgXi4qJCBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2NyZWF0ZS13YXNtLWFwcC8uL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzLyBsYXp5IF4uKiQgbmFtZXNwYWNlIG9iamVjdCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBnZW5lcmF0ZWQgYnkgZGlwbG9tYXQtdG9vbFxuaW1wb3J0IHsgRWRnZXNJdGVyIH0gZnJvbSBcIi4vRWRnZXNJdGVyLm1qc1wiXG5pbXBvcnQgeyBOb2Rlc0l0ZXIgfSBmcm9tIFwiLi9Ob2Rlc0l0ZXIubWpzXCJcbmltcG9ydCB3YXNtIGZyb20gXCIuL2RpcGxvbWF0LXdhc20ubWpzXCI7XG5pbXBvcnQgKiBhcyBkaXBsb21hdFJ1bnRpbWUgZnJvbSBcIi4vZGlwbG9tYXQtcnVudGltZS5tanNcIjtcblxuY29uc3QgQ29uY3JldGVHcmFwaF9ib3hfZGVzdHJveV9yZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgocHRyKSA9PiB7XG4gICAgd2FzbS5Db25jcmV0ZUdyYXBoX2Rlc3Ryb3kocHRyKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgQ29uY3JldGVHcmFwaCB7XG4gICAgLy8gSW50ZXJuYWwgcHRyIHJlZmVyZW5jZTpcbiAgICAjcHRyID0gbnVsbDtcblxuICAgIC8vIExpZmV0aW1lcyBhcmUgb25seSB0byBrZWVwIGRlcGVuZGVuY2llcyBhbGl2ZS5cbiAgICAvLyBTaW5jZSBKUyB3b24ndCBnYXJiYWdlIGNvbGxlY3QgdW50aWwgdGhlcmUgYXJlIG5vIGluY29taW5nIGVkZ2VzLlxuICAgICNzZWxmRWRnZSA9IFtdO1xuXG4gICAgI2ludGVybmFsQ29uc3RydWN0b3Ioc3ltYm9sLCBwdHIsIHNlbGZFZGdlKSB7XG4gICAgICAgIGlmIChzeW1ib2wgIT09IGRpcGxvbWF0UnVudGltZS5pbnRlcm5hbENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ29uY3JldGVHcmFwaCBpcyBhbiBPcGFxdWUgdHlwZS4gWW91IGNhbm5vdCBjYWxsIGl0cyBjb25zdHJ1Y3Rvci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHRyID0gcHRyO1xuICAgICAgICB0aGlzLiNzZWxmRWRnZSA9IHNlbGZFZGdlO1xuXG4gICAgICAgIC8vIEFyZSB3ZSBiZWluZyBib3Jyb3dlZD8gSWYgbm90LCB3ZSBjYW4gcmVnaXN0ZXIuXG4gICAgICAgIGlmICh0aGlzLiNzZWxmRWRnZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIENvbmNyZXRlR3JhcGhfYm94X2Rlc3Ryb3lfcmVnaXN0cnkucmVnaXN0ZXIodGhpcywgdGhpcy4jcHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IGZmaVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHRyO1xuICAgIH1cblxuXG4gICAgc3RhdGljIG5ld18oKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FzbS5Db25jcmV0ZUdyYXBoX25ldygpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbmNyZXRlR3JhcGgoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBub2RlIGtleSBvZiB0aGUgbmV3bHkgYWRkZWQgbm9kZVxuICAgICAqL1xuICAgIGFkZE5vZGUodmFsdWUpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uQ2xlYW51cEFyZW5hID0gbmV3IGRpcGxvbWF0UnVudGltZS5DbGVhbnVwQXJlbmEoKTtcblxuICAgICAgICBjb25zdCB2YWx1ZVNsaWNlID0gZGlwbG9tYXRSdW50aW1lLkRpcGxvbWF0QnVmLnN0cjgod2FzbSwgdmFsdWUpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhc20uQ29uY3JldGVHcmFwaF9hZGRfbm9kZSh0aGlzLmZmaVZhbHVlLCAuLi52YWx1ZVNsaWNlLnNwbGF0KCkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBmdW5jdGlvbkNsZWFudXBBcmVuYS5mcmVlKCk7XG5cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZU5vZGUoa2V5KSB7XG4gICAgd2FzbS5Db25jcmV0ZUdyYXBoX2RlbGV0ZV9ub2RlKHRoaXMuZmZpVmFsdWUsIGtleSk7XG5cbiAgICAgICAgdHJ5IHt9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhZGRFZGdlKHNyYywgZHN0LCB3ZWlnaHQpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uQ2xlYW51cEFyZW5hID0gbmV3IGRpcGxvbWF0UnVudGltZS5DbGVhbnVwQXJlbmEoKTtcblxuICAgICAgICBjb25zdCB3ZWlnaHRTbGljZSA9IGRpcGxvbWF0UnVudGltZS5EaXBsb21hdEJ1Zi5zdHI4KHdhc20sIHdlaWdodCk7XG4gICAgd2FzbS5Db25jcmV0ZUdyYXBoX2FkZF9lZGdlKHRoaXMuZmZpVmFsdWUsIHNyYywgZHN0LCAuLi53ZWlnaHRTbGljZS5zcGxhdCgpKTtcblxuICAgICAgICB0cnkge31cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2xlYW51cEFyZW5hLmZyZWUoKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Tm9kZXMoKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FzbS5Db25jcmV0ZUdyYXBoX2dldF9ub2Rlcyh0aGlzLmZmaVZhbHVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2Rlc0l0ZXIoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRFZGdlcygpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLkNvbmNyZXRlR3JhcGhfZ2V0X2VkZ2VzKHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVkZ2VzSXRlcihkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3RvciwgcmVzdWx0LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb25zdHJ1Y3RvciguLi5hcmd1bWVudHMpXG4gICAgfVxufSIsIi8vIGdlbmVyYXRlZCBieSBkaXBsb21hdC10b29sXG5pbXBvcnQgeyBQYXJzZVJlc3VsdCB9IGZyb20gXCIuL1BhcnNlUmVzdWx0Lm1qc1wiXG5pbXBvcnQgd2FzbSBmcm9tIFwiLi9kaXBsb21hdC13YXNtLm1qc1wiO1xuaW1wb3J0ICogYXMgZGlwbG9tYXRSdW50aW1lIGZyb20gXCIuL2RpcGxvbWF0LXJ1bnRpbWUubWpzXCI7XG5cblxuXG5leHBvcnQgY2xhc3MgQ29udGV4dCB7XG4gICAgI2k7XG4gICAgZ2V0IGkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpO1xuICAgIH1cbiAgICBzZXQgaSh2YWx1ZSl7XG4gICAgICAgIHRoaXMuI2kgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBmcm9tRmllbGRzKHN0cnVjdE9iaikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRleHQoc3RydWN0T2JqKTtcbiAgICB9XG5cbiAgICAjaW50ZXJuYWxDb25zdHJ1Y3RvcihzdHJ1Y3RPYmopIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJ1Y3RPYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQncyBjb25zdHJ1Y3RvciB0YWtlcyBhbiBvYmplY3Qgb2YgQ29udGV4dCdzIGZpZWxkcy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJpXCIgaW4gc3RydWN0T2JqKSB7XG4gICAgICAgICAgICB0aGlzLiNpID0gc3RydWN0T2JqLmk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVpcmVkIGZpZWxkIGkuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoaXMgc3RydWN0IGluIEZGSSBmdW5jdGlvbiBmcmllbmRseSBmb3JtYXQuXG4gICAgLy8gUmV0dXJucyBhbiBhcnJheSB0aGF0IGNhbiBiZSBleHBhbmRlZCB3aXRoIHNwcmVhZCBzeW50YXggKC4uLilcbiAgICBfaW50b0ZGSShcbiAgICAgICAgZnVuY3Rpb25DbGVhbnVwQXJlbmEsXG4gICAgICAgIGFwcGVuZEFycmF5TWFwXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy4jaV1cbiAgICB9XG5cbiAgICBzdGF0aWMgX2Zyb21TdXBwbGllZFZhbHVlKGludGVybmFsQ29uc3RydWN0b3IsIG9iaikge1xuICAgICAgICBpZiAoaW50ZXJuYWxDb25zdHJ1Y3RvciAhPT0gZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIl9mcm9tU3VwcGxpZWRWYWx1ZSBjYW5ub3QgYmUgY2FsbGVkIGV4dGVybmFsbHkuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG9iaiBpbnN0YW5jZW9mIENvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gQ29udGV4dC5mcm9tRmllbGRzKG9iaik7XG4gICAgfVxuXG4gICAgX3dyaXRlVG9BcnJheUJ1ZmZlcihcbiAgICAgICAgYXJyYXlCdWZmZXIsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgZnVuY3Rpb25DbGVhbnVwQXJlbmEsXG4gICAgICAgIGFwcGVuZEFycmF5TWFwXG4gICAgKSB7XG4gICAgICAgIGRpcGxvbWF0UnVudGltZS53cml0ZVRvQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIG9mZnNldCArIDAsIHRoaXMuI2ksIEludDMyQXJyYXkpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgc3RydWN0IGNvbnRhaW5zIGJvcnJvd2VkIGZpZWxkcywgc28gdGhpcyB0YWtlcyBpbiBhIGxpc3Qgb2ZcbiAgICAvLyBcImVkZ2VzXCIgY29ycmVzcG9uZGluZyB0byB3aGVyZSBlYWNoIGxpZmV0aW1lJ3MgZGF0YSBtYXkgaGF2ZSBiZWVuIGJvcnJvd2VkIGZyb21cbiAgICAvLyBhbmQgcGFzc2VzIGl0IGRvd24gdG8gaW5kaXZpZHVhbCBmaWVsZHMgY29udGFpbmluZyB0aGUgYm9ycm93LlxuICAgIC8vIFRoaXMgbWV0aG9kIGRvZXMgbm90IGF0dGVtcHQgdG8gaGFuZGxlIGFueSBkZXBlbmRlbmNpZXMgYmV0d2VlbiBsaWZldGltZXMsIHRoZSBjYWxsZXJcbiAgICAvLyBzaG91bGQgaGFuZGxlIHRoaXMgd2hlbiBjb25zdHJ1Y3RpbmcgZWRnZSBhcnJheXMuXG4gICAgc3RhdGljIF9mcm9tRkZJKGludGVybmFsQ29uc3RydWN0b3IsIHByaW1pdGl2ZVZhbHVlKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbENvbnN0cnVjdG9yICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29udGV4dC5fZnJvbUZGSSBpcyBub3QgbWVhbnQgdG8gYmUgY2FsbGVkIGV4dGVybmFsbHkuIFBsZWFzZSB1c2UgdGhlIGRlZmF1bHQgY29uc3RydWN0b3IuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJ1Y3RPYmogPSB7fTtcbiAgICAgICAgc3RydWN0T2JqLmkgPSBwcmltaXRpdmVWYWx1ZTtcblxuICAgICAgICByZXR1cm4gbmV3IENvbnRleHQoc3RydWN0T2JqKTtcbiAgICB9XG5cblxuICAgIHN0YXRpYyBpbml0KCkge1xuICAgIHdhc20uQ29udGV4dF9pbml0KCk7XG5cbiAgICAgICAgdHJ5IHt9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0aWMgcGFyc2Uoc3JjKSB7XG4gICAgICAgIGxldCBmdW5jdGlvbkNsZWFudXBBcmVuYSA9IG5ldyBkaXBsb21hdFJ1bnRpbWUuQ2xlYW51cEFyZW5hKCk7XG5cbiAgICAgICAgY29uc3Qgc3JjU2xpY2UgPSBkaXBsb21hdFJ1bnRpbWUuRGlwbG9tYXRCdWYuc3RyOCh3YXNtLCBzcmMpO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhc20uQ29udGV4dF9wYXJzZSguLi5zcmNTbGljZS5zcGxhdCgpKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZVJlc3VsdChkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3RvciwgcmVzdWx0LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2xlYW51cEFyZW5hLmZyZWUoKTtcblxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc3RydWN0T2JqKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbENvbnN0cnVjdG9yKC4uLmFyZ3VtZW50cylcbiAgICB9XG59IiwiLy8gZ2VuZXJhdGVkIGJ5IGRpcGxvbWF0LXRvb2xcbmltcG9ydCB3YXNtIGZyb20gXCIuL2RpcGxvbWF0LXdhc20ubWpzXCI7XG5pbXBvcnQgKiBhcyBkaXBsb21hdFJ1bnRpbWUgZnJvbSBcIi4vZGlwbG9tYXQtcnVudGltZS5tanNcIjtcblxuY29uc3QgRWRnZVdyYXBwZXJfYm94X2Rlc3Ryb3lfcmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHB0cikgPT4ge1xuICAgIHdhc20uRWRnZVdyYXBwZXJfZGVzdHJveShwdHIpO1xufSk7XG5cbmV4cG9ydCBjbGFzcyBFZGdlV3JhcHBlciB7XG4gICAgLy8gSW50ZXJuYWwgcHRyIHJlZmVyZW5jZTpcbiAgICAjcHRyID0gbnVsbDtcblxuICAgIC8vIExpZmV0aW1lcyBhcmUgb25seSB0byBrZWVwIGRlcGVuZGVuY2llcyBhbGl2ZS5cbiAgICAvLyBTaW5jZSBKUyB3b24ndCBnYXJiYWdlIGNvbGxlY3QgdW50aWwgdGhlcmUgYXJlIG5vIGluY29taW5nIGVkZ2VzLlxuICAgICNzZWxmRWRnZSA9IFtdO1xuXG4gICAgI2ludGVybmFsQ29uc3RydWN0b3Ioc3ltYm9sLCBwdHIsIHNlbGZFZGdlKSB7XG4gICAgICAgIGlmIChzeW1ib2wgIT09IGRpcGxvbWF0UnVudGltZS5pbnRlcm5hbENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRWRnZVdyYXBwZXIgaXMgYW4gT3BhcXVlIHR5cGUuIFlvdSBjYW5ub3QgY2FsbCBpdHMgY29uc3RydWN0b3IuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3B0ciA9IHB0cjtcbiAgICAgICAgdGhpcy4jc2VsZkVkZ2UgPSBzZWxmRWRnZTtcblxuICAgICAgICAvLyBBcmUgd2UgYmVpbmcgYm9ycm93ZWQ/IElmIG5vdCwgd2UgY2FuIHJlZ2lzdGVyLlxuICAgICAgICBpZiAodGhpcy4jc2VsZkVkZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBFZGdlV3JhcHBlcl9ib3hfZGVzdHJveV9yZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCB0aGlzLiNwdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgZmZpVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwdHI7XG4gICAgfVxuXG5cbiAgICBzcmMoKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FzbS5FZGdlV3JhcHBlcl9zcmModGhpcy5mZmlWYWx1ZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRzdCgpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLkVkZ2VXcmFwcGVyX2RzdCh0aGlzLmZmaVZhbHVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgd2VpZ2h0KCkge1xuICAgICAgICBjb25zdCB3cml0ZSA9IG5ldyBkaXBsb21hdFJ1bnRpbWUuRGlwbG9tYXRXcml0ZUJ1Zih3YXNtKTtcblxuICAgIHdhc20uRWRnZVdyYXBwZXJfd2VpZ2h0KHRoaXMuZmZpVmFsdWUsIHdyaXRlLmJ1ZmZlcik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZS5yZWFkU3RyaW5nOCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB3cml0ZS5mcmVlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29uc3RydWN0b3IoLi4uYXJndW1lbnRzKVxuICAgIH1cbn0iLCIvLyBnZW5lcmF0ZWQgYnkgZGlwbG9tYXQtdG9vbFxuaW1wb3J0IHsgRWRnZVdyYXBwZXIgfSBmcm9tIFwiLi9FZGdlV3JhcHBlci5tanNcIlxuaW1wb3J0IHdhc20gZnJvbSBcIi4vZGlwbG9tYXQtd2FzbS5tanNcIjtcbmltcG9ydCAqIGFzIGRpcGxvbWF0UnVudGltZSBmcm9tIFwiLi9kaXBsb21hdC1ydW50aW1lLm1qc1wiO1xuXG5jb25zdCBFZGdlc0l0ZXJfYm94X2Rlc3Ryb3lfcmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHB0cikgPT4ge1xuICAgIHdhc20uRWRnZXNJdGVyX2Rlc3Ryb3kocHRyKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgRWRnZXNJdGVyIHtcbiAgICAvLyBJbnRlcm5hbCBwdHIgcmVmZXJlbmNlOlxuICAgICNwdHIgPSBudWxsO1xuXG4gICAgLy8gTGlmZXRpbWVzIGFyZSBvbmx5IHRvIGtlZXAgZGVwZW5kZW5jaWVzIGFsaXZlLlxuICAgIC8vIFNpbmNlIEpTIHdvbid0IGdhcmJhZ2UgY29sbGVjdCB1bnRpbCB0aGVyZSBhcmUgbm8gaW5jb21pbmcgZWRnZXMuXG4gICAgI3NlbGZFZGdlID0gW107XG5cbiAgICAjaW50ZXJuYWxDb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPT0gZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFZGdlc0l0ZXIgaXMgYW4gT3BhcXVlIHR5cGUuIFlvdSBjYW5ub3QgY2FsbCBpdHMgY29uc3RydWN0b3IuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3B0ciA9IHB0cjtcbiAgICAgICAgdGhpcy4jc2VsZkVkZ2UgPSBzZWxmRWRnZTtcblxuICAgICAgICAvLyBBcmUgd2UgYmVpbmcgYm9ycm93ZWQ/IElmIG5vdCwgd2UgY2FuIHJlZ2lzdGVyLlxuICAgICAgICBpZiAodGhpcy4jc2VsZkVkZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBFZGdlc0l0ZXJfYm94X2Rlc3Ryb3lfcmVnaXN0cnkucmVnaXN0ZXIodGhpcywgdGhpcy4jcHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IGZmaVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHRyO1xuICAgIH1cblxuXG4gICAgI2l0ZXJhdG9yTmV4dCgpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLkVkZ2VzSXRlcl9uZXh0KHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSAwID8gbnVsbCA6IG5ldyBFZGdlV3JhcHBlcihkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3RvciwgcmVzdWx0LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhc20uRWRnZXNJdGVyX3RvX2l0ZXJhYmxlKHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVkZ2VzSXRlcihkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3RvciwgcmVzdWx0LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5leHQoKXtcbiAgICAgICAgY29uc3Qgb3V0ID0gdGhpcy4jaXRlcmF0b3JOZXh0KCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiBvdXQsXG4gICAgICAgICAgICBkb25lOiBvdXQgPT09IG51bGwsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc3ltYm9sLCBwdHIsIHNlbGZFZGdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbENvbnN0cnVjdG9yKC4uLmFyZ3VtZW50cylcbiAgICB9XG59IiwiLy8gZ2VuZXJhdGVkIGJ5IGRpcGxvbWF0LXRvb2xcbmltcG9ydCB3YXNtIGZyb20gXCIuL2RpcGxvbWF0LXdhc20ubWpzXCI7XG5pbXBvcnQgKiBhcyBkaXBsb21hdFJ1bnRpbWUgZnJvbSBcIi4vZGlwbG9tYXQtcnVudGltZS5tanNcIjtcblxuXG5cbmV4cG9ydCBjbGFzcyBMaW5lQ29sU3BhbiB7XG4gICAgI2xpbmVTdGFydDtcbiAgICBnZXQgbGluZVN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbGluZVN0YXJ0O1xuICAgIH1cbiAgICBzZXQgbGluZVN0YXJ0KHZhbHVlKXtcbiAgICAgICAgdGhpcy4jbGluZVN0YXJ0ID0gdmFsdWU7XG4gICAgfVxuICAgICNsaW5lRW5kO1xuICAgIGdldCBsaW5lRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbGluZUVuZDtcbiAgICB9XG4gICAgc2V0IGxpbmVFbmQodmFsdWUpe1xuICAgICAgICB0aGlzLiNsaW5lRW5kID0gdmFsdWU7XG4gICAgfVxuICAgICNjb2xTdGFydDtcbiAgICBnZXQgY29sU3RhcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjb2xTdGFydDtcbiAgICB9XG4gICAgc2V0IGNvbFN0YXJ0KHZhbHVlKXtcbiAgICAgICAgdGhpcy4jY29sU3RhcnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgI2NvbEVuZDtcbiAgICBnZXQgY29sRW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY29sRW5kO1xuICAgIH1cbiAgICBzZXQgY29sRW5kKHZhbHVlKXtcbiAgICAgICAgdGhpcy4jY29sRW5kID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBzdGF0aWMgZnJvbUZpZWxkcyhzdHJ1Y3RPYmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5lQ29sU3BhbihzdHJ1Y3RPYmopO1xuICAgIH1cblxuICAgICNpbnRlcm5hbENvbnN0cnVjdG9yKHN0cnVjdE9iaikge1xuICAgICAgICBpZiAodHlwZW9mIHN0cnVjdE9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGluZUNvbFNwYW4ncyBjb25zdHJ1Y3RvciB0YWtlcyBhbiBvYmplY3Qgb2YgTGluZUNvbFNwYW4ncyBmaWVsZHMuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwibGluZVN0YXJ0XCIgaW4gc3RydWN0T2JqKSB7XG4gICAgICAgICAgICB0aGlzLiNsaW5lU3RhcnQgPSBzdHJ1Y3RPYmoubGluZVN0YXJ0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBmaWVsZCBsaW5lU3RhcnQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwibGluZUVuZFwiIGluIHN0cnVjdE9iaikge1xuICAgICAgICAgICAgdGhpcy4jbGluZUVuZCA9IHN0cnVjdE9iai5saW5lRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBmaWVsZCBsaW5lRW5kLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcImNvbFN0YXJ0XCIgaW4gc3RydWN0T2JqKSB7XG4gICAgICAgICAgICB0aGlzLiNjb2xTdGFydCA9IHN0cnVjdE9iai5jb2xTdGFydDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWlyZWQgZmllbGQgY29sU3RhcnQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiY29sRW5kXCIgaW4gc3RydWN0T2JqKSB7XG4gICAgICAgICAgICB0aGlzLiNjb2xFbmQgPSBzdHJ1Y3RPYmouY29sRW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyByZXF1aXJlZCBmaWVsZCBjb2xFbmQuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIHRoaXMgc3RydWN0IGluIEZGSSBmdW5jdGlvbiBmcmllbmRseSBmb3JtYXQuXG4gICAgLy8gUmV0dXJucyBhbiBhcnJheSB0aGF0IGNhbiBiZSBleHBhbmRlZCB3aXRoIHNwcmVhZCBzeW50YXggKC4uLilcbiAgICBfaW50b0ZGSShcbiAgICAgICAgZnVuY3Rpb25DbGVhbnVwQXJlbmEsXG4gICAgICAgIGFwcGVuZEFycmF5TWFwXG4gICAgKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy4jbGluZVN0YXJ0LCB0aGlzLiNsaW5lRW5kLCB0aGlzLiNjb2xTdGFydCwgdGhpcy4jY29sRW5kXVxuICAgIH1cblxuICAgIHN0YXRpYyBfZnJvbVN1cHBsaWVkVmFsdWUoaW50ZXJuYWxDb25zdHJ1Y3Rvciwgb2JqKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbENvbnN0cnVjdG9yICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiX2Zyb21TdXBwbGllZFZhbHVlIGNhbm5vdCBiZSBjYWxsZWQgZXh0ZXJuYWxseS5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgTGluZUNvbFNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gTGluZUNvbFNwYW4uZnJvbUZpZWxkcyhvYmopO1xuICAgIH1cblxuICAgIF93cml0ZVRvQXJyYXlCdWZmZXIoXG4gICAgICAgIGFycmF5QnVmZmVyLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGZ1bmN0aW9uQ2xlYW51cEFyZW5hLFxuICAgICAgICBhcHBlbmRBcnJheU1hcFxuICAgICkge1xuICAgICAgICBkaXBsb21hdFJ1bnRpbWUud3JpdGVUb0FycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBvZmZzZXQgKyAwLCB0aGlzLiNsaW5lU3RhcnQsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgZGlwbG9tYXRSdW50aW1lLndyaXRlVG9BcnJheUJ1ZmZlcihhcnJheUJ1ZmZlciwgb2Zmc2V0ICsgNCwgdGhpcy4jbGluZUVuZCwgVWludDMyQXJyYXkpO1xuICAgICAgICBkaXBsb21hdFJ1bnRpbWUud3JpdGVUb0FycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBvZmZzZXQgKyA4LCB0aGlzLiNjb2xTdGFydCwgVWludDMyQXJyYXkpO1xuICAgICAgICBkaXBsb21hdFJ1bnRpbWUud3JpdGVUb0FycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBvZmZzZXQgKyAxMiwgdGhpcy4jY29sRW5kLCBVaW50MzJBcnJheSk7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBzdHJ1Y3QgY29udGFpbnMgYm9ycm93ZWQgZmllbGRzLCBzbyB0aGlzIHRha2VzIGluIGEgbGlzdCBvZlxuICAgIC8vIFwiZWRnZXNcIiBjb3JyZXNwb25kaW5nIHRvIHdoZXJlIGVhY2ggbGlmZXRpbWUncyBkYXRhIG1heSBoYXZlIGJlZW4gYm9ycm93ZWQgZnJvbVxuICAgIC8vIGFuZCBwYXNzZXMgaXQgZG93biB0byBpbmRpdmlkdWFsIGZpZWxkcyBjb250YWluaW5nIHRoZSBib3Jyb3cuXG4gICAgLy8gVGhpcyBtZXRob2QgZG9lcyBub3QgYXR0ZW1wdCB0byBoYW5kbGUgYW55IGRlcGVuZGVuY2llcyBiZXR3ZWVuIGxpZmV0aW1lcywgdGhlIGNhbGxlclxuICAgIC8vIHNob3VsZCBoYW5kbGUgdGhpcyB3aGVuIGNvbnN0cnVjdGluZyBlZGdlIGFycmF5cy5cbiAgICBzdGF0aWMgX2Zyb21GRkkoaW50ZXJuYWxDb25zdHJ1Y3RvciwgcHRyKSB7XG4gICAgICAgIGlmIChpbnRlcm5hbENvbnN0cnVjdG9yICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGluZUNvbFNwYW4uX2Zyb21GRkkgaXMgbm90IG1lYW50IHRvIGJlIGNhbGxlZCBleHRlcm5hbGx5LiBQbGVhc2UgdXNlIHRoZSBkZWZhdWx0IGNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RydWN0T2JqID0ge307XG4gICAgICAgIGNvbnN0IGxpbmVTdGFydERlcmVmID0gKG5ldyBVaW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIsIHB0ciwgMSkpWzBdO1xuICAgICAgICBzdHJ1Y3RPYmoubGluZVN0YXJ0ID0gbGluZVN0YXJ0RGVyZWY7XG4gICAgICAgIGNvbnN0IGxpbmVFbmREZXJlZiA9IChuZXcgVWludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIgKyA0LCAxKSlbMF07XG4gICAgICAgIHN0cnVjdE9iai5saW5lRW5kID0gbGluZUVuZERlcmVmO1xuICAgICAgICBjb25zdCBjb2xTdGFydERlcmVmID0gKG5ldyBVaW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIsIHB0ciArIDgsIDEpKVswXTtcbiAgICAgICAgc3RydWN0T2JqLmNvbFN0YXJ0ID0gY29sU3RhcnREZXJlZjtcbiAgICAgICAgY29uc3QgY29sRW5kRGVyZWYgPSAobmV3IFVpbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgcHRyICsgMTIsIDEpKVswXTtcbiAgICAgICAgc3RydWN0T2JqLmNvbEVuZCA9IGNvbEVuZERlcmVmO1xuXG4gICAgICAgIHJldHVybiBuZXcgTGluZUNvbFNwYW4oc3RydWN0T2JqKTtcbiAgICB9XG5cblxuICAgIGNvbnN0cnVjdG9yKHN0cnVjdE9iaikge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb25zdHJ1Y3RvciguLi5hcmd1bWVudHMpXG4gICAgfVxufSIsIi8vIGdlbmVyYXRlZCBieSBkaXBsb21hdC10b29sXG5pbXBvcnQgeyBMaW5lQ29sU3BhbiB9IGZyb20gXCIuL0xpbmVDb2xTcGFuLm1qc1wiXG5pbXBvcnQgd2FzbSBmcm9tIFwiLi9kaXBsb21hdC13YXNtLm1qc1wiO1xuaW1wb3J0ICogYXMgZGlwbG9tYXRSdW50aW1lIGZyb20gXCIuL2RpcGxvbWF0LXJ1bnRpbWUubWpzXCI7XG5cbmNvbnN0IExpbmVDb2xTcGFuc0l0ZXJfYm94X2Rlc3Ryb3lfcmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHB0cikgPT4ge1xuICAgIHdhc20uTGluZUNvbFNwYW5zSXRlcl9kZXN0cm95KHB0cik7XG59KTtcblxuZXhwb3J0IGNsYXNzIExpbmVDb2xTcGFuc0l0ZXIge1xuICAgIC8vIEludGVybmFsIHB0ciByZWZlcmVuY2U6XG4gICAgI3B0ciA9IG51bGw7XG5cbiAgICAvLyBMaWZldGltZXMgYXJlIG9ubHkgdG8ga2VlcCBkZXBlbmRlbmNpZXMgYWxpdmUuXG4gICAgLy8gU2luY2UgSlMgd29uJ3QgZ2FyYmFnZSBjb2xsZWN0IHVudGlsIHRoZXJlIGFyZSBubyBpbmNvbWluZyBlZGdlcy5cbiAgICAjc2VsZkVkZ2UgPSBbXTtcblxuICAgICNpbnRlcm5hbENvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkxpbmVDb2xTcGFuc0l0ZXIgaXMgYW4gT3BhcXVlIHR5cGUuIFlvdSBjYW5ub3QgY2FsbCBpdHMgY29uc3RydWN0b3IuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3B0ciA9IHB0cjtcbiAgICAgICAgdGhpcy4jc2VsZkVkZ2UgPSBzZWxmRWRnZTtcblxuICAgICAgICAvLyBBcmUgd2UgYmVpbmcgYm9ycm93ZWQ/IElmIG5vdCwgd2UgY2FuIHJlZ2lzdGVyLlxuICAgICAgICBpZiAodGhpcy4jc2VsZkVkZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBMaW5lQ29sU3BhbnNJdGVyX2JveF9kZXN0cm95X3JlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMsIHRoaXMuI3B0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBmZmlWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3B0cjtcbiAgICB9XG5cblxuICAgICNpdGVyYXRvck5leHQoKSB7XG4gICAgICAgIGNvbnN0IGRpcGxvbWF0UmVjZWl2ZSA9IG5ldyBkaXBsb21hdFJ1bnRpbWUuRGlwbG9tYXRSZWNlaXZlQnVmKHdhc20sIDE3LCA0LCB0cnVlKTtcblxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhc20uTGluZUNvbFNwYW5zSXRlcl9uZXh0KGRpcGxvbWF0UmVjZWl2ZS5idWZmZXIsIHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWRpcGxvbWF0UmVjZWl2ZS5yZXN1bHRGbGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gTGluZUNvbFNwYW4uX2Zyb21GRkkoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIGRpcGxvbWF0UmVjZWl2ZS5idWZmZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBkaXBsb21hdFJlY2VpdmUuZnJlZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FzbS5MaW5lQ29sU3BhbnNJdGVyX3RvX2l0ZXJhYmxlKHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmVDb2xTcGFuc0l0ZXIoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0KCl7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuI2l0ZXJhdG9yTmV4dCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3V0LFxuICAgICAgICAgICAgZG9uZTogb3V0ID09PSBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb25zdHJ1Y3RvciguLi5hcmd1bWVudHMpXG4gICAgfVxufSIsIi8vIGdlbmVyYXRlZCBieSBkaXBsb21hdC10b29sXG5pbXBvcnQgd2FzbSBmcm9tIFwiLi9kaXBsb21hdC13YXNtLm1qc1wiO1xuaW1wb3J0ICogYXMgZGlwbG9tYXRSdW50aW1lIGZyb20gXCIuL2RpcGxvbWF0LXJ1bnRpbWUubWpzXCI7XG5cbmNvbnN0IE5ld05vZGVfYm94X2Rlc3Ryb3lfcmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHB0cikgPT4ge1xuICAgIHdhc20uTmV3Tm9kZV9kZXN0cm95KHB0cik7XG59KTtcblxuZXhwb3J0IGNsYXNzIE5ld05vZGUge1xuICAgIC8vIEludGVybmFsIHB0ciByZWZlcmVuY2U6XG4gICAgI3B0ciA9IG51bGw7XG5cbiAgICAvLyBMaWZldGltZXMgYXJlIG9ubHkgdG8ga2VlcCBkZXBlbmRlbmNpZXMgYWxpdmUuXG4gICAgLy8gU2luY2UgSlMgd29uJ3QgZ2FyYmFnZSBjb2xsZWN0IHVudGlsIHRoZXJlIGFyZSBubyBpbmNvbWluZyBlZGdlcy5cbiAgICAjc2VsZkVkZ2UgPSBbXTtcblxuICAgICNpbnRlcm5hbENvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk5ld05vZGUgaXMgYW4gT3BhcXVlIHR5cGUuIFlvdSBjYW5ub3QgY2FsbCBpdHMgY29uc3RydWN0b3IuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3B0ciA9IHB0cjtcbiAgICAgICAgdGhpcy4jc2VsZkVkZ2UgPSBzZWxmRWRnZTtcblxuICAgICAgICAvLyBBcmUgd2UgYmVpbmcgYm9ycm93ZWQ/IElmIG5vdCwgd2UgY2FuIHJlZ2lzdGVyLlxuICAgICAgICBpZiAodGhpcy4jc2VsZkVkZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBOZXdOb2RlX2JveF9kZXN0cm95X3JlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMsIHRoaXMuI3B0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBmZmlWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3B0cjtcbiAgICB9XG5cblxuICAgIGtleSgpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLk5ld05vZGVfa2V5KHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lKCkge1xuICAgICAgICBjb25zdCB3cml0ZSA9IG5ldyBkaXBsb21hdFJ1bnRpbWUuRGlwbG9tYXRXcml0ZUJ1Zih3YXNtKTtcblxuICAgIHdhc20uTmV3Tm9kZV9uYW1lKHRoaXMuZmZpVmFsdWUsIHdyaXRlLmJ1ZmZlcik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZS5yZWFkU3RyaW5nOCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB3cml0ZS5mcmVlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZSgpIHtcbiAgICAgICAgY29uc3Qgd3JpdGUgPSBuZXcgZGlwbG9tYXRSdW50aW1lLkRpcGxvbWF0V3JpdGVCdWYod2FzbSk7XG5cbiAgICB3YXNtLk5ld05vZGVfdmFsdWUodGhpcy5mZmlWYWx1ZSwgd3JpdGUuYnVmZmVyKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlLnJlYWRTdHJpbmc4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdyaXRlLmZyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb25zdHJ1Y3RvciguLi5hcmd1bWVudHMpXG4gICAgfVxufSIsIi8vIGdlbmVyYXRlZCBieSBkaXBsb21hdC10b29sXG5pbXBvcnQgeyBOZXdOb2RlIH0gZnJvbSBcIi4vTmV3Tm9kZS5tanNcIlxuaW1wb3J0IHdhc20gZnJvbSBcIi4vZGlwbG9tYXQtd2FzbS5tanNcIjtcbmltcG9ydCAqIGFzIGRpcGxvbWF0UnVudGltZSBmcm9tIFwiLi9kaXBsb21hdC1ydW50aW1lLm1qc1wiO1xuXG5jb25zdCBOZXdOb2Rlc0l0ZXJfYm94X2Rlc3Ryb3lfcmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHB0cikgPT4ge1xuICAgIHdhc20uTmV3Tm9kZXNJdGVyX2Rlc3Ryb3kocHRyKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgTmV3Tm9kZXNJdGVyIHtcbiAgICAvLyBJbnRlcm5hbCBwdHIgcmVmZXJlbmNlOlxuICAgICNwdHIgPSBudWxsO1xuXG4gICAgLy8gTGlmZXRpbWVzIGFyZSBvbmx5IHRvIGtlZXAgZGVwZW5kZW5jaWVzIGFsaXZlLlxuICAgIC8vIFNpbmNlIEpTIHdvbid0IGdhcmJhZ2UgY29sbGVjdCB1bnRpbCB0aGVyZSBhcmUgbm8gaW5jb21pbmcgZWRnZXMuXG4gICAgI3NlbGZFZGdlID0gW107XG5cbiAgICAjaW50ZXJuYWxDb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPT0gZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOZXdOb2Rlc0l0ZXIgaXMgYW4gT3BhcXVlIHR5cGUuIFlvdSBjYW5ub3QgY2FsbCBpdHMgY29uc3RydWN0b3IuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3B0ciA9IHB0cjtcbiAgICAgICAgdGhpcy4jc2VsZkVkZ2UgPSBzZWxmRWRnZTtcblxuICAgICAgICAvLyBBcmUgd2UgYmVpbmcgYm9ycm93ZWQ/IElmIG5vdCwgd2UgY2FuIHJlZ2lzdGVyLlxuICAgICAgICBpZiAodGhpcy4jc2VsZkVkZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBOZXdOb2Rlc0l0ZXJfYm94X2Rlc3Ryb3lfcmVnaXN0cnkucmVnaXN0ZXIodGhpcywgdGhpcy4jcHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IGZmaVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHRyO1xuICAgIH1cblxuXG4gICAgI2l0ZXJhdG9yTmV4dCgpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLk5ld05vZGVzSXRlcl9uZXh0KHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSAwID8gbnVsbCA6IG5ldyBOZXdOb2RlKGRpcGxvbWF0UnVudGltZS5pbnRlcm5hbENvbnN0cnVjdG9yLCByZXN1bHQsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FzbS5OZXdOb2Rlc0l0ZXJfdG9faXRlcmFibGUodGhpcy5mZmlWYWx1ZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTmV3Tm9kZXNJdGVyKGRpcGxvbWF0UnVudGltZS5pbnRlcm5hbENvbnN0cnVjdG9yLCByZXN1bHQsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgbmV4dCgpe1xuICAgICAgICBjb25zdCBvdXQgPSB0aGlzLiNpdGVyYXRvck5leHQoKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IG91dCxcbiAgICAgICAgICAgIGRvbmU6IG91dCA9PT0gbnVsbCxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29uc3RydWN0b3IoLi4uYXJndW1lbnRzKVxuICAgIH1cbn0iLCIvLyBnZW5lcmF0ZWQgYnkgZGlwbG9tYXQtdG9vbFxuaW1wb3J0IHdhc20gZnJvbSBcIi4vZGlwbG9tYXQtd2FzbS5tanNcIjtcbmltcG9ydCAqIGFzIGRpcGxvbWF0UnVudGltZSBmcm9tIFwiLi9kaXBsb21hdC1ydW50aW1lLm1qc1wiO1xuXG5jb25zdCBOb2RlV3JhcHBlcl9ib3hfZGVzdHJveV9yZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgocHRyKSA9PiB7XG4gICAgd2FzbS5Ob2RlV3JhcHBlcl9kZXN0cm95KHB0cik7XG59KTtcblxuZXhwb3J0IGNsYXNzIE5vZGVXcmFwcGVyIHtcbiAgICAvLyBJbnRlcm5hbCBwdHIgcmVmZXJlbmNlOlxuICAgICNwdHIgPSBudWxsO1xuXG4gICAgLy8gTGlmZXRpbWVzIGFyZSBvbmx5IHRvIGtlZXAgZGVwZW5kZW5jaWVzIGFsaXZlLlxuICAgIC8vIFNpbmNlIEpTIHdvbid0IGdhcmJhZ2UgY29sbGVjdCB1bnRpbCB0aGVyZSBhcmUgbm8gaW5jb21pbmcgZWRnZXMuXG4gICAgI3NlbGZFZGdlID0gW107XG5cbiAgICAjaW50ZXJuYWxDb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPT0gZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOb2RlV3JhcHBlciBpcyBhbiBPcGFxdWUgdHlwZS4gWW91IGNhbm5vdCBjYWxsIGl0cyBjb25zdHJ1Y3Rvci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHRyID0gcHRyO1xuICAgICAgICB0aGlzLiNzZWxmRWRnZSA9IHNlbGZFZGdlO1xuXG4gICAgICAgIC8vIEFyZSB3ZSBiZWluZyBib3Jyb3dlZD8gSWYgbm90LCB3ZSBjYW4gcmVnaXN0ZXIuXG4gICAgICAgIGlmICh0aGlzLiNzZWxmRWRnZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIE5vZGVXcmFwcGVyX2JveF9kZXN0cm95X3JlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMsIHRoaXMuI3B0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBmZmlWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3B0cjtcbiAgICB9XG5cblxuICAgIGtleSgpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLk5vZGVXcmFwcGVyX2tleSh0aGlzLmZmaVZhbHVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlID0gbmV3IGRpcGxvbWF0UnVudGltZS5EaXBsb21hdFdyaXRlQnVmKHdhc20pO1xuXG4gICAgd2FzbS5Ob2RlV3JhcHBlcl92YWx1ZSh0aGlzLmZmaVZhbHVlLCB3cml0ZS5idWZmZXIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGUucmVhZFN0cmluZzgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgd3JpdGUuZnJlZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3Ioc3ltYm9sLCBwdHIsIHNlbGZFZGdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpbnRlcm5hbENvbnN0cnVjdG9yKC4uLmFyZ3VtZW50cylcbiAgICB9XG59IiwiLy8gZ2VuZXJhdGVkIGJ5IGRpcGxvbWF0LXRvb2xcbmltcG9ydCB7IE5vZGVXcmFwcGVyIH0gZnJvbSBcIi4vTm9kZVdyYXBwZXIubWpzXCJcbmltcG9ydCB3YXNtIGZyb20gXCIuL2RpcGxvbWF0LXdhc20ubWpzXCI7XG5pbXBvcnQgKiBhcyBkaXBsb21hdFJ1bnRpbWUgZnJvbSBcIi4vZGlwbG9tYXQtcnVudGltZS5tanNcIjtcblxuY29uc3QgTm9kZXNJdGVyX2JveF9kZXN0cm95X3JlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChwdHIpID0+IHtcbiAgICB3YXNtLk5vZGVzSXRlcl9kZXN0cm95KHB0cik7XG59KTtcblxuZXhwb3J0IGNsYXNzIE5vZGVzSXRlciB7XG4gICAgLy8gSW50ZXJuYWwgcHRyIHJlZmVyZW5jZTpcbiAgICAjcHRyID0gbnVsbDtcblxuICAgIC8vIExpZmV0aW1lcyBhcmUgb25seSB0byBrZWVwIGRlcGVuZGVuY2llcyBhbGl2ZS5cbiAgICAvLyBTaW5jZSBKUyB3b24ndCBnYXJiYWdlIGNvbGxlY3QgdW50aWwgdGhlcmUgYXJlIG5vIGluY29taW5nIGVkZ2VzLlxuICAgICNzZWxmRWRnZSA9IFtdO1xuXG4gICAgI2ludGVybmFsQ29uc3RydWN0b3Ioc3ltYm9sLCBwdHIsIHNlbGZFZGdlKSB7XG4gICAgICAgIGlmIChzeW1ib2wgIT09IGRpcGxvbWF0UnVudGltZS5pbnRlcm5hbENvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZXNJdGVyIGlzIGFuIE9wYXF1ZSB0eXBlLiBZb3UgY2Fubm90IGNhbGwgaXRzIGNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwdHIgPSBwdHI7XG4gICAgICAgIHRoaXMuI3NlbGZFZGdlID0gc2VsZkVkZ2U7XG5cbiAgICAgICAgLy8gQXJlIHdlIGJlaW5nIGJvcnJvd2VkPyBJZiBub3QsIHdlIGNhbiByZWdpc3Rlci5cbiAgICAgICAgaWYgKHRoaXMuI3NlbGZFZGdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgTm9kZXNJdGVyX2JveF9kZXN0cm95X3JlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMsIHRoaXMuI3B0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBmZmlWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3B0cjtcbiAgICB9XG5cblxuICAgICNpdGVyYXRvck5leHQoKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FzbS5Ob2Rlc0l0ZXJfbmV4dCh0aGlzLmZmaVZhbHVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gMCA/IG51bGwgOiBuZXcgTm9kZVdyYXBwZXIoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLk5vZGVzSXRlcl90b19pdGVyYWJsZSh0aGlzLmZmaVZhbHVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOb2Rlc0l0ZXIoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0KCl7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuI2l0ZXJhdG9yTmV4dCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3V0LFxuICAgICAgICAgICAgZG9uZTogb3V0ID09PSBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb25zdHJ1Y3RvciguLi5hcmd1bWVudHMpXG4gICAgfVxufSIsIi8vIGdlbmVyYXRlZCBieSBkaXBsb21hdC10b29sXG5pbXBvcnQgd2FzbSBmcm9tIFwiLi9kaXBsb21hdC13YXNtLm1qc1wiO1xuaW1wb3J0ICogYXMgZGlwbG9tYXRSdW50aW1lIGZyb20gXCIuL2RpcGxvbWF0LXJ1bnRpbWUubWpzXCI7XG5cbmNvbnN0IE9wQ3R4QW5kRm5OYW1lc19ib3hfZGVzdHJveV9yZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgocHRyKSA9PiB7XG4gICAgd2FzbS5PcEN0eEFuZEZuTmFtZXNfZGVzdHJveShwdHIpO1xufSk7XG5cbmV4cG9ydCBjbGFzcyBPcEN0eEFuZEZuTmFtZXMge1xuICAgIC8vIEludGVybmFsIHB0ciByZWZlcmVuY2U6XG4gICAgI3B0ciA9IG51bGw7XG5cbiAgICAvLyBMaWZldGltZXMgYXJlIG9ubHkgdG8ga2VlcCBkZXBlbmRlbmNpZXMgYWxpdmUuXG4gICAgLy8gU2luY2UgSlMgd29uJ3QgZ2FyYmFnZSBjb2xsZWN0IHVudGlsIHRoZXJlIGFyZSBubyBpbmNvbWluZyBlZGdlcy5cbiAgICAjc2VsZkVkZ2UgPSBbXTtcblxuICAgICNpbnRlcm5hbENvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk9wQ3R4QW5kRm5OYW1lcyBpcyBhbiBPcGFxdWUgdHlwZS4gWW91IGNhbm5vdCBjYWxsIGl0cyBjb25zdHJ1Y3Rvci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHRyID0gcHRyO1xuICAgICAgICB0aGlzLiNzZWxmRWRnZSA9IHNlbGZFZGdlO1xuXG4gICAgICAgIC8vIEFyZSB3ZSBiZWluZyBib3Jyb3dlZD8gSWYgbm90LCB3ZSBjYW4gcmVnaXN0ZXIuXG4gICAgICAgIGlmICh0aGlzLiNzZWxmRWRnZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIE9wQ3R4QW5kRm5OYW1lc19ib3hfZGVzdHJveV9yZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCB0aGlzLiNwdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgZmZpVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwdHI7XG4gICAgfVxuXG5cbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29uc3RydWN0b3IoLi4uYXJndW1lbnRzKVxuICAgIH1cbn0iLCIvLyBnZW5lcmF0ZWQgYnkgZGlwbG9tYXQtdG9vbFxuaW1wb3J0IHsgQ29uY3JldGVHcmFwaCB9IGZyb20gXCIuL0NvbmNyZXRlR3JhcGgubWpzXCJcbmltcG9ydCB7IExpbmVDb2xTcGFuc0l0ZXIgfSBmcm9tIFwiLi9MaW5lQ29sU3BhbnNJdGVyLm1qc1wiXG5pbXBvcnQgeyBSdW5PcGVyYXRpb25SZXN1bHQgfSBmcm9tIFwiLi9SdW5PcGVyYXRpb25SZXN1bHQubWpzXCJcbmltcG9ydCB7IFN0cmluZ0Vycm9yIH0gZnJvbSBcIi4vU3RyaW5nRXJyb3IubWpzXCJcbmltcG9ydCB7IFN0cmluZ0l0ZXIgfSBmcm9tIFwiLi9TdHJpbmdJdGVyLm1qc1wiXG5pbXBvcnQgd2FzbSBmcm9tIFwiLi9kaXBsb21hdC13YXNtLm1qc1wiO1xuaW1wb3J0ICogYXMgZGlwbG9tYXRSdW50aW1lIGZyb20gXCIuL2RpcGxvbWF0LXJ1bnRpbWUubWpzXCI7XG5cbmNvbnN0IFBhcnNlUmVzdWx0X2JveF9kZXN0cm95X3JlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChwdHIpID0+IHtcbiAgICB3YXNtLlBhcnNlUmVzdWx0X2Rlc3Ryb3kocHRyKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgUGFyc2VSZXN1bHQge1xuICAgIC8vIEludGVybmFsIHB0ciByZWZlcmVuY2U6XG4gICAgI3B0ciA9IG51bGw7XG5cbiAgICAvLyBMaWZldGltZXMgYXJlIG9ubHkgdG8ga2VlcCBkZXBlbmRlbmNpZXMgYWxpdmUuXG4gICAgLy8gU2luY2UgSlMgd29uJ3QgZ2FyYmFnZSBjb2xsZWN0IHVudGlsIHRoZXJlIGFyZSBubyBpbmNvbWluZyBlZGdlcy5cbiAgICAjc2VsZkVkZ2UgPSBbXTtcblxuICAgICNpbnRlcm5hbENvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlBhcnNlUmVzdWx0IGlzIGFuIE9wYXF1ZSB0eXBlLiBZb3UgY2Fubm90IGNhbGwgaXRzIGNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwdHIgPSBwdHI7XG4gICAgICAgIHRoaXMuI3NlbGZFZGdlID0gc2VsZkVkZ2U7XG5cbiAgICAgICAgLy8gQXJlIHdlIGJlaW5nIGJvcnJvd2VkPyBJZiBub3QsIHdlIGNhbiByZWdpc3Rlci5cbiAgICAgICAgaWYgKHRoaXMuI3NlbGZFZGdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgUGFyc2VSZXN1bHRfYm94X2Rlc3Ryb3lfcmVnaXN0cnkucmVnaXN0ZXIodGhpcywgdGhpcy4jcHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IGZmaVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHRyO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogV3JpdGVzIHRoZSBlcnJvciBtZXNzYWdlIGlmIG9uZSBleGlzdHMuXG4gICAgICovXG4gICAgZXJyb3JNZXNzYWdlKCkge1xuICAgICAgICBjb25zdCB3cml0ZSA9IG5ldyBkaXBsb21hdFJ1bnRpbWUuRGlwbG9tYXRXcml0ZUJ1Zih3YXNtKTtcblxuICAgIHdhc20uUGFyc2VSZXN1bHRfZXJyb3JfbWVzc2FnZSh0aGlzLmZmaVZhbHVlLCB3cml0ZS5idWZmZXIpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gd3JpdGUucmVhZFN0cmluZzgoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgd3JpdGUuZnJlZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpbnRlcmFibGUgb2YgZXJyb3Igc3BhbnMgKGlmIGFueSkuXG4gICAgICovXG4gICAgZXJyb3JTcGFucygpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLlBhcnNlUmVzdWx0X2Vycm9yX3NwYW5zKHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IExpbmVDb2xTcGFuc0l0ZXIoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBET1QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGludGVybWVkaWF0ZSBzdGF0ZSBuYW1lZCBgc3RhdGVgLlxuICAgICAqL1xuICAgIGRvdE9mU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uQ2xlYW51cEFyZW5hID0gbmV3IGRpcGxvbWF0UnVudGltZS5DbGVhbnVwQXJlbmEoKTtcblxuICAgICAgICBjb25zdCBzdGF0ZVNsaWNlID0gZGlwbG9tYXRSdW50aW1lLkRpcGxvbWF0QnVmLnN0cjgod2FzbSwgc3RhdGUpO1xuICAgICAgICBjb25zdCB3cml0ZSA9IG5ldyBkaXBsb21hdFJ1bnRpbWUuRGlwbG9tYXRXcml0ZUJ1Zih3YXNtKTtcblxuICAgIHdhc20uUGFyc2VSZXN1bHRfZG90X29mX3N0YXRlKHRoaXMuZmZpVmFsdWUsIC4uLnN0YXRlU2xpY2Uuc3BsYXQoKSwgd3JpdGUuYnVmZmVyKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlLnJlYWRTdHJpbmc4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uQ2xlYW51cEFyZW5hLmZyZWUoKTtcblxuICAgICAgICAgICAgd3JpdGUuZnJlZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGF2YWlsYWJsZSBzdGF0ZXMuXG4gICAgICovXG4gICAgbGlzdFN0YXRlcygpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLlBhcnNlUmVzdWx0X2xpc3Rfc3RhdGVzKHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0l0ZXIoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaXN0cyB0aGUgYXZhaWxhYmxlIG9wZXJhdGlvbnMuXG4gICAgICovXG4gICAgbGlzdE9wZXJhdGlvbnMoKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FzbS5QYXJzZVJlc3VsdF9saXN0X29wZXJhdGlvbnModGhpcy5mZmlWYWx1ZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU3RyaW5nSXRlcihkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3RvciwgcmVzdWx0LCBbXSk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgdGhlIG9wZXJhdGlvbiB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBhcmd1bWVudHMgb24gdGhlIHByb3ZpZGVkIGNvbmNyZXRlIGdyYXBoLlxuICAgICAqL1xuICAgIHJ1bk9wZXJhdGlvbihnLCBvcE5hbWUsIGFyZ3MpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uQ2xlYW51cEFyZW5hID0gbmV3IGRpcGxvbWF0UnVudGltZS5DbGVhbnVwQXJlbmEoKTtcblxuICAgICAgICBjb25zdCBvcE5hbWVTbGljZSA9IGRpcGxvbWF0UnVudGltZS5EaXBsb21hdEJ1Zi5zdHI4KHdhc20sIG9wTmFtZSk7XG4gICAgICAgIGNvbnN0IGFyZ3NTbGljZSA9IGRpcGxvbWF0UnVudGltZS5EaXBsb21hdEJ1Zi5zbGljZSh3YXNtLCBhcmdzLCBcInUzMlwiKTtcbiAgICAgICAgY29uc3QgZGlwbG9tYXRSZWNlaXZlID0gbmV3IGRpcGxvbWF0UnVudGltZS5EaXBsb21hdFJlY2VpdmVCdWYod2FzbSwgNSwgNCwgdHJ1ZSk7XG5cblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLlBhcnNlUmVzdWx0X3J1bl9vcGVyYXRpb24oZGlwbG9tYXRSZWNlaXZlLmJ1ZmZlciwgdGhpcy5mZmlWYWx1ZSwgZy5mZmlWYWx1ZSwgLi4ub3BOYW1lU2xpY2Uuc3BsYXQoKSwgLi4uYXJnc1NsaWNlLnNwbGF0KCkpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWRpcGxvbWF0UmVjZWl2ZS5yZXN1bHRGbGFnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F1c2UgPSBuZXcgU3RyaW5nRXJyb3IoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIGRpcGxvbWF0UnVudGltZS5wdHJSZWFkKHdhc20sIGRpcGxvbWF0UmVjZWl2ZS5idWZmZXIpLCBbXSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGdsb2JhbFRoaXMuRXJyb3IoJ1N0cmluZ0Vycm9yOiAnICsgY2F1c2UudG9TdHJpbmcoKSwgeyBjYXVzZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUnVuT3BlcmF0aW9uUmVzdWx0KGRpcGxvbWF0UnVudGltZS5pbnRlcm5hbENvbnN0cnVjdG9yLCBkaXBsb21hdFJ1bnRpbWUucHRyUmVhZCh3YXNtLCBkaXBsb21hdFJlY2VpdmUuYnVmZmVyKSwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBmdW5jdGlvbkNsZWFudXBBcmVuYS5mcmVlKCk7XG5cbiAgICAgICAgICAgIGRpcGxvbWF0UmVjZWl2ZS5mcmVlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29uc3RydWN0b3IoLi4uYXJndW1lbnRzKVxuICAgIH1cbn0iLCIvLyBnZW5lcmF0ZWQgYnkgZGlwbG9tYXQtdG9vbFxuaW1wb3J0IHsgTmV3Tm9kZXNJdGVyIH0gZnJvbSBcIi4vTmV3Tm9kZXNJdGVyLm1qc1wiXG5pbXBvcnQgd2FzbSBmcm9tIFwiLi9kaXBsb21hdC13YXNtLm1qc1wiO1xuaW1wb3J0ICogYXMgZGlwbG9tYXRSdW50aW1lIGZyb20gXCIuL2RpcGxvbWF0LXJ1bnRpbWUubWpzXCI7XG5cbmNvbnN0IFJ1bk9wZXJhdGlvblJlc3VsdF9ib3hfZGVzdHJveV9yZWdpc3RyeSA9IG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeSgocHRyKSA9PiB7XG4gICAgd2FzbS5SdW5PcGVyYXRpb25SZXN1bHRfZGVzdHJveShwdHIpO1xufSk7XG5cbmV4cG9ydCBjbGFzcyBSdW5PcGVyYXRpb25SZXN1bHQge1xuICAgIC8vIEludGVybmFsIHB0ciByZWZlcmVuY2U6XG4gICAgI3B0ciA9IG51bGw7XG5cbiAgICAvLyBMaWZldGltZXMgYXJlIG9ubHkgdG8ga2VlcCBkZXBlbmRlbmNpZXMgYWxpdmUuXG4gICAgLy8gU2luY2UgSlMgd29uJ3QgZ2FyYmFnZSBjb2xsZWN0IHVudGlsIHRoZXJlIGFyZSBubyBpbmNvbWluZyBlZGdlcy5cbiAgICAjc2VsZkVkZ2UgPSBbXTtcblxuICAgICNpbnRlcm5hbENvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlJ1bk9wZXJhdGlvblJlc3VsdCBpcyBhbiBPcGFxdWUgdHlwZS4gWW91IGNhbm5vdCBjYWxsIGl0cyBjb25zdHJ1Y3Rvci5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcHRyID0gcHRyO1xuICAgICAgICB0aGlzLiNzZWxmRWRnZSA9IHNlbGZFZGdlO1xuXG4gICAgICAgIC8vIEFyZSB3ZSBiZWluZyBib3Jyb3dlZD8gSWYgbm90LCB3ZSBjYW4gcmVnaXN0ZXIuXG4gICAgICAgIGlmICh0aGlzLiNzZWxmRWRnZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIFJ1bk9wZXJhdGlvblJlc3VsdF9ib3hfZGVzdHJveV9yZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCB0aGlzLiNwdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgZmZpVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwdHI7XG4gICAgfVxuXG5cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLlJ1bk9wZXJhdGlvblJlc3VsdF90b19pdGVyYWJsZSh0aGlzLmZmaVZhbHVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBOZXdOb2Rlc0l0ZXIoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjaGFpbmVkRG90VHJhY2UoKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlID0gbmV3IGRpcGxvbWF0UnVudGltZS5EaXBsb21hdFdyaXRlQnVmKHdhc20pO1xuXG4gICAgd2FzbS5SdW5PcGVyYXRpb25SZXN1bHRfY2hhaW5lZF9kb3RfdHJhY2UodGhpcy5mZmlWYWx1ZSwgd3JpdGUuYnVmZmVyKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlLnJlYWRTdHJpbmc4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdyaXRlLmZyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb25zdHJ1Y3RvciguLi5hcmd1bWVudHMpXG4gICAgfVxufSIsIi8vIGdlbmVyYXRlZCBieSBkaXBsb21hdC10b29sXG5pbXBvcnQgd2FzbSBmcm9tIFwiLi9kaXBsb21hdC13YXNtLm1qc1wiO1xuaW1wb3J0ICogYXMgZGlwbG9tYXRSdW50aW1lIGZyb20gXCIuL2RpcGxvbWF0LXJ1bnRpbWUubWpzXCI7XG5cbmNvbnN0IFN0cmluZ0Vycm9yX2JveF9kZXN0cm95X3JlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChwdHIpID0+IHtcbiAgICB3YXNtLlN0cmluZ0Vycm9yX2Rlc3Ryb3kocHRyKTtcbn0pO1xuXG5leHBvcnQgY2xhc3MgU3RyaW5nRXJyb3Ige1xuICAgIC8vIEludGVybmFsIHB0ciByZWZlcmVuY2U6XG4gICAgI3B0ciA9IG51bGw7XG5cbiAgICAvLyBMaWZldGltZXMgYXJlIG9ubHkgdG8ga2VlcCBkZXBlbmRlbmNpZXMgYWxpdmUuXG4gICAgLy8gU2luY2UgSlMgd29uJ3QgZ2FyYmFnZSBjb2xsZWN0IHVudGlsIHRoZXJlIGFyZSBubyBpbmNvbWluZyBlZGdlcy5cbiAgICAjc2VsZkVkZ2UgPSBbXTtcblxuICAgICNpbnRlcm5hbENvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlN0cmluZ0Vycm9yIGlzIGFuIE9wYXF1ZSB0eXBlLiBZb3UgY2Fubm90IGNhbGwgaXRzIGNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwdHIgPSBwdHI7XG4gICAgICAgIHRoaXMuI3NlbGZFZGdlID0gc2VsZkVkZ2U7XG5cbiAgICAgICAgLy8gQXJlIHdlIGJlaW5nIGJvcnJvd2VkPyBJZiBub3QsIHdlIGNhbiByZWdpc3Rlci5cbiAgICAgICAgaWYgKHRoaXMuI3NlbGZFZGdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgU3RyaW5nRXJyb3JfYm94X2Rlc3Ryb3lfcmVnaXN0cnkucmVnaXN0ZXIodGhpcywgdGhpcy4jcHRyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGludGVybmFsICovXG4gICAgZ2V0IGZmaVZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcHRyO1xuICAgIH1cblxuXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IHdyaXRlID0gbmV3IGRpcGxvbWF0UnVudGltZS5EaXBsb21hdFdyaXRlQnVmKHdhc20pO1xuXG4gICAgd2FzbS5TdHJpbmdFcnJvcl90b19zdHJpbmcodGhpcy5mZmlWYWx1ZSwgd3JpdGUuYnVmZmVyKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHdyaXRlLnJlYWRTdHJpbmc4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdyaXRlLmZyZWUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb25zdHJ1Y3RvciguLi5hcmd1bWVudHMpXG4gICAgfVxufSIsIi8vIGdlbmVyYXRlZCBieSBkaXBsb21hdC10b29sXG5pbXBvcnQgeyBTdHJpbmdXcmFwcGVyIH0gZnJvbSBcIi4vU3RyaW5nV3JhcHBlci5tanNcIlxuaW1wb3J0IHdhc20gZnJvbSBcIi4vZGlwbG9tYXQtd2FzbS5tanNcIjtcbmltcG9ydCAqIGFzIGRpcGxvbWF0UnVudGltZSBmcm9tIFwiLi9kaXBsb21hdC1ydW50aW1lLm1qc1wiO1xuXG5jb25zdCBTdHJpbmdJdGVyX2JveF9kZXN0cm95X3JlZ2lzdHJ5ID0gbmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KChwdHIpID0+IHtcbiAgICB3YXNtLlN0cmluZ0l0ZXJfZGVzdHJveShwdHIpO1xufSk7XG5cbmV4cG9ydCBjbGFzcyBTdHJpbmdJdGVyIHtcbiAgICAvLyBJbnRlcm5hbCBwdHIgcmVmZXJlbmNlOlxuICAgICNwdHIgPSBudWxsO1xuXG4gICAgLy8gTGlmZXRpbWVzIGFyZSBvbmx5IHRvIGtlZXAgZGVwZW5kZW5jaWVzIGFsaXZlLlxuICAgIC8vIFNpbmNlIEpTIHdvbid0IGdhcmJhZ2UgY29sbGVjdCB1bnRpbCB0aGVyZSBhcmUgbm8gaW5jb21pbmcgZWRnZXMuXG4gICAgI3NlbGZFZGdlID0gW107XG5cbiAgICAjaW50ZXJuYWxDb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgaWYgKHN5bWJvbCAhPT0gZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTdHJpbmdJdGVyIGlzIGFuIE9wYXF1ZSB0eXBlLiBZb3UgY2Fubm90IGNhbGwgaXRzIGNvbnN0cnVjdG9yLlwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNwdHIgPSBwdHI7XG4gICAgICAgIHRoaXMuI3NlbGZFZGdlID0gc2VsZkVkZ2U7XG5cbiAgICAgICAgLy8gQXJlIHdlIGJlaW5nIGJvcnJvd2VkPyBJZiBub3QsIHdlIGNhbiByZWdpc3Rlci5cbiAgICAgICAgaWYgKHRoaXMuI3NlbGZFZGdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgU3RyaW5nSXRlcl9ib3hfZGVzdHJveV9yZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCB0aGlzLiNwdHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBnZXQgZmZpVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNwdHI7XG4gICAgfVxuXG5cbiAgICAjaXRlcmF0b3JOZXh0KCkge1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHdhc20uU3RyaW5nSXRlcl9uZXh0KHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSAwID8gbnVsbCA6IG5ldyBTdHJpbmdXcmFwcGVyKGRpcGxvbWF0UnVudGltZS5pbnRlcm5hbENvbnN0cnVjdG9yLCByZXN1bHQsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG5cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gd2FzbS5TdHJpbmdJdGVyX3RvX2l0ZXJhYmxlKHRoaXMuZmZpVmFsdWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0l0ZXIoZGlwbG9tYXRSdW50aW1lLmludGVybmFsQ29uc3RydWN0b3IsIHJlc3VsdCwgW10pO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBuZXh0KCl7XG4gICAgICAgIGNvbnN0IG91dCA9IHRoaXMuI2l0ZXJhdG9yTmV4dCgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogb3V0LFxuICAgICAgICAgICAgZG9uZTogb3V0ID09PSBudWxsLFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy4jaW50ZXJuYWxDb25zdHJ1Y3RvciguLi5hcmd1bWVudHMpXG4gICAgfVxufSIsIi8vIGdlbmVyYXRlZCBieSBkaXBsb21hdC10b29sXG5pbXBvcnQgd2FzbSBmcm9tIFwiLi9kaXBsb21hdC13YXNtLm1qc1wiO1xuaW1wb3J0ICogYXMgZGlwbG9tYXRSdW50aW1lIGZyb20gXCIuL2RpcGxvbWF0LXJ1bnRpbWUubWpzXCI7XG5cbmNvbnN0IFN0cmluZ1dyYXBwZXJfYm94X2Rlc3Ryb3lfcmVnaXN0cnkgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHB0cikgPT4ge1xuICAgIHdhc20uU3RyaW5nV3JhcHBlcl9kZXN0cm95KHB0cik7XG59KTtcblxuZXhwb3J0IGNsYXNzIFN0cmluZ1dyYXBwZXIge1xuICAgIC8vIEludGVybmFsIHB0ciByZWZlcmVuY2U6XG4gICAgI3B0ciA9IG51bGw7XG5cbiAgICAvLyBMaWZldGltZXMgYXJlIG9ubHkgdG8ga2VlcCBkZXBlbmRlbmNpZXMgYWxpdmUuXG4gICAgLy8gU2luY2UgSlMgd29uJ3QgZ2FyYmFnZSBjb2xsZWN0IHVudGlsIHRoZXJlIGFyZSBubyBpbmNvbWluZyBlZGdlcy5cbiAgICAjc2VsZkVkZ2UgPSBbXTtcblxuICAgICNpbnRlcm5hbENvbnN0cnVjdG9yKHN5bWJvbCwgcHRyLCBzZWxmRWRnZSkge1xuICAgICAgICBpZiAoc3ltYm9sICE9PSBkaXBsb21hdFJ1bnRpbWUuaW50ZXJuYWxDb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlN0cmluZ1dyYXBwZXIgaXMgYW4gT3BhcXVlIHR5cGUuIFlvdSBjYW5ub3QgY2FsbCBpdHMgY29uc3RydWN0b3IuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3B0ciA9IHB0cjtcbiAgICAgICAgdGhpcy4jc2VsZkVkZ2UgPSBzZWxmRWRnZTtcblxuICAgICAgICAvLyBBcmUgd2UgYmVpbmcgYm9ycm93ZWQ/IElmIG5vdCwgd2UgY2FuIHJlZ2lzdGVyLlxuICAgICAgICBpZiAodGhpcy4jc2VsZkVkZ2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBTdHJpbmdXcmFwcGVyX2JveF9kZXN0cm95X3JlZ2lzdHJ5LnJlZ2lzdGVyKHRoaXMsIHRoaXMuI3B0cik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIGdldCBmZmlWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3B0cjtcbiAgICB9XG5cblxuICAgIHN0YXRpYyBuZXdfKHMpIHtcbiAgICAgICAgbGV0IGZ1bmN0aW9uQ2xlYW51cEFyZW5hID0gbmV3IGRpcGxvbWF0UnVudGltZS5DbGVhbnVwQXJlbmEoKTtcblxuICAgICAgICBjb25zdCBzU2xpY2UgPSBkaXBsb21hdFJ1bnRpbWUuRGlwbG9tYXRCdWYuc3RyOCh3YXNtLCBzKTtcblxuICAgICAgICBjb25zdCByZXN1bHQgPSB3YXNtLlN0cmluZ1dyYXBwZXJfbmV3KC4uLnNTbGljZS5zcGxhdCgpKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJpbmdXcmFwcGVyKGRpcGxvbWF0UnVudGltZS5pbnRlcm5hbENvbnN0cnVjdG9yLCByZXN1bHQsIFtdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgZnVuY3Rpb25DbGVhbnVwQXJlbmEuZnJlZSgpO1xuXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgY29uc3Qgd3JpdGUgPSBuZXcgZGlwbG9tYXRSdW50aW1lLkRpcGxvbWF0V3JpdGVCdWYod2FzbSk7XG5cbiAgICB3YXNtLlN0cmluZ1dyYXBwZXJfdG9fc3RyaW5nKHRoaXMuZmZpVmFsdWUsIHdyaXRlLmJ1ZmZlcik7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB3cml0ZS5yZWFkU3RyaW5nOCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB3cml0ZS5mcmVlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcihzeW1ib2wsIHB0ciwgc2VsZkVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2ludGVybmFsQ29uc3RydWN0b3IoLi4uYXJndW1lbnRzKVxuICAgIH1cbn0iLCIvKiogRm9yIGludGVybmFsIERpcGxvbWF0IHVzZSB3aGVuIGNvbnN0cnVjdGluZyBvcGFxdWVzIG9yIG91dCBzdHJ1Y3RzLlxuICogVGhpcyBpcyBmb3Igd2hlbiB3ZSdyZSBoYW5kbGluZyBpdGVtcyB0aGF0IHdlIGRvbid0IHdhbnQgdGhlIHVzZXIgdG8gdG91Y2gsIGxpa2UgYW4gc3RydWN0dXJlIHRoYXQncyBvbmx5IG1lYW50IHRvIGJlIG91dHB1dCwgb3IgZGUtcmVmZXJlbmNpbmcgYSBwb2ludGVyIHdlJ3JlIGhhbmRlZCBmcm9tIFdBU00uXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlcm5hbENvbnN0cnVjdG9yID0gU3ltYm9sKFwiY29uc3RydWN0b3JcIik7XG4vKiogRm9yIGludGVybmFsIERpcGxvbWF0IHVzZSB3aGVuIGFjY2Vzc2luZyBhIGZyb20tZmllbGRzL2Zyb20tdmFsdWUgY29uc3RydWN0b3IgdGhhdCdzIGJlZW4gb3ZlcnJpZGRlbiBieSBhIGRlZmF1bHQgY29uc3RydWN0b3IuXG4gKiBJZiB3ZSB3YW50IHRvIHBhc3MgaW4gYXJndW1lbnRzIHdpdGhvdXQgYWxzbyBwYXNzaW5nIGluIGludGVybmFsQ29uc3RydWN0b3IgdG8gYXZvaWQgdHJpZ2dlcmluZyBzb21lIGxvZ2ljIHdlIGRvbid0IHdhbnQsIHdlIHVzZSBleHBvc2VDb25zdHJ1Y3Rvci5cbiAqL1xuZXhwb3J0IGNvbnN0IGV4cG9zZUNvbnN0cnVjdG9yID0gU3ltYm9sKFwiZXhwb3NlQ29uc3RydWN0b3JcIik7XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyaW5nOCh3YXNtLCBwdHIsIGxlbikge1xuICAgIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgcHRyLCBsZW4pO1xuICAgIHJldHVybiAobmV3IFRleHREZWNvZGVyKFwidXRmLThcIikpLmRlY29kZShidWYpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkU3RyaW5nMTYod2FzbSwgcHRyLCBsZW4pIHtcbiAgICBjb25zdCBidWYgPSBuZXcgVWludDE2QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIGxlbik7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgYnVmKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd2l0aERpcGxvbWF0V3JpdGUod2FzbSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCB3cml0ZSA9IHdhc20uZGlwbG9tYXRfYnVmZmVyX3dyaXRlX2NyZWF0ZSgwKTtcbiAgICB0cnkge1xuICAgIGNhbGxiYWNrKHdyaXRlKTtcbiAgICBjb25zdCBvdXRTdHJpbmdQdHIgPSB3YXNtLmRpcGxvbWF0X2J1ZmZlcl93cml0ZV9nZXRfYnl0ZXMod3JpdGUpO1xuICAgIGlmIChvdXRTdHJpbmdQdHIgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJPdXQgb2YgbWVtb3J5XCIpO1xuICAgIH1cbiAgICBjb25zdCBvdXRTdHJpbmdMZW4gPSB3YXNtLmRpcGxvbWF0X2J1ZmZlcl93cml0ZV9sZW4od3JpdGUpO1xuICAgIHJldHVybiByZWFkU3RyaW5nOCh3YXNtLCBvdXRTdHJpbmdQdHIsIG91dFN0cmluZ0xlbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICB3YXNtLmRpcGxvbWF0X2J1ZmZlcl93cml0ZV9kZXN0cm95KHdyaXRlKTtcbiAgICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwb2ludGVyIHJldHVybmVkIGJ5IGFuIEZGSSBmdW5jdGlvbi5cbiAqXG4gKiBJdCdzIHRlbXB0aW5nIHRvIGNhbGwgYChuZXcgVWludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBGRklfZnVuYygpLCAxKSlbMF1gLlxuICogSG93ZXZlciwgdGhlcmUncyBhIGNoYW5jZSB0aGF0IGB3YXNtLm1lbW9yeS5idWZmZXJgIHdpbGwgYmUgcmVzaXplZCBiZXR3ZWVuXG4gKiB0aGUgdGltZSBpdCdzIGFjY2Vzc2VkIGFuZCB0aGUgdGltZSBpdCdzIHVzZWQsIGludmFsaWRhdGluZyB0aGUgdmlldy5cbiAqIFRoaXMgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IHRoZSB2aWV3IGludG8gd2FzbSBtZW1vcnkgaXMgZnJlc2guXG4gKlxuICogVGhpcyBpcyB1c2VkIGZvciBtZXRob2RzIHRoYXQgcmV0dXJuIG11bHRpcGxlIHR5cGVzIGludG8gYSB3YXNtIGJ1ZmZlciwgd2hlcmVcbiAqIG9uZSBvZiB0aG9zZSB0eXBlcyBpcyBhbm90aGVyIHB0ci4gQ2FsbCB0aGlzIG1ldGhvZCB0byBnZXQgYWNjZXNzIHRvIHRoZSByZXR1cm5lZFxuICogcHRyLCBzbyB0aGUgcmV0dXJuIGJ1ZmZlciBjYW4gYmUgZnJlZWQuXG4gKiBAcGFyYW0ge1dlYkFzc2VtYmx5LkV4cG9ydHN9IHdhc20gUHJvdmlkZWQgYnkgZGlwbG9tYXQgZ2VuZXJhdGVkIGZpbGVzLlxuICogQHBhcmFtIHtudW1iZXJ9IHB0ciBQb2ludGVyIG9mIGEgcG9pbnRlciwgdG8gYmUgcmVhZC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB1bmRlcmx5aW5nIHBvaW50ZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwdHJSZWFkKHdhc20sIHB0cikge1xuICAgIHJldHVybiAobmV3IFVpbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgcHRyLCAxKSlbMF07XG59XG5cbi8qKlxuICogR2V0IHRoZSBmbGFnIG9mIGEgcmVzdWx0IHR5cGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZXN1bHRGbGFnKHdhc20sIHB0ciwgb2Zmc2V0KSB7XG4gICAgcmV0dXJuIChuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIsIHB0ciArIG9mZnNldCwgMSkpWzBdO1xufVxuXG4vKipcbiAqIEdldCB0aGUgZGlzY3JpbWluYW50IG9mIGEgUnVzdCBlbnVtLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnVtRGlzY3JpbWluYW50KHdhc20sIHB0cikge1xuICAgIHJldHVybiAobmV3IEludDMyQXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIDEpKVswXVxufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBvZiBwYWRkaW5nQ291bnQgemVyb2VzIHRvIGJlIHNwcmVhZCBpbnRvIGEgZnVuY3Rpb24gY2FsbFxuICogaWYgbmVlZHNQYWRkaW5nRmllbGRzIGlzIHRydWUsIGVsc2UgZW1wdHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heWJlUGFkZGluZ0ZpZWxkcyhuZWVkc1BhZGRpbmdGaWVsZHMsIHBhZGRpbmdDb3VudCkge1xuICAgIGlmIChuZWVkc1BhZGRpbmdGaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KHBhZGRpbmdDb3VudCkuZmlsbCgwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuXG4vKipcbiogV3JpdGUgYSB2YWx1ZSBvZiB3aWR0aCBgd2lkdGhgIHRvIGEgYW4gQXJyYXlCdWZmZXIgYGFycmF5QnVmZmVyYFxuKiBhdCBieXRlIG9mZnNldCBgb2Zmc2V0YCwgdHJlYXRpbmcgaXQgYXMgYSBidWZmZXIgb2Yga2luZCBgdHlwZWRBcnJheUtpbmRgXG4qICh3aGljaCBpcyBhIGBUeXBlZEFycmF5YCB2YXJpYW50IGxpa2UgYFVpbnQ4QXJyYXlgIG9yIGBJbnQxNkFycmF5YClcbiovXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVUb0FycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBvZmZzZXQsIHZhbHVlLCB0eXBlZEFycmF5S2luZCkge1xuICAgIGxldCBidWZmZXIgPSBuZXcgdHlwZWRBcnJheUtpbmQoYXJyYXlCdWZmZXIsIG9mZnNldCk7XG4gICAgYnVmZmVyWzBdID0gdmFsdWU7XG59XG5cbi8qKlxuKiBUYWtlIGBqc1ZhbHVlYCBhbmQgd3JpdGUgaXQgdG8gYXJyYXlCdWZmZXIgYXQgb2Zmc2V0IGBvZmZzZXRgIGlmIGl0IGlzIG5vbi1udWxsXG4qIGNhbGxpbmcgYHdyaXRlVG9BcnJheUJ1ZmZlckNhbGxiYWNrKGFycmF5QnVmZmVyLCBvZmZzZXQsIGpzVmFsdWUpYCB0byB3cml0ZSB0byB0aGUgYnVmZmVyLFxuKiBhbHNvIHdyaXRpbmcgYSB0YWcgYml0LlxuKlxuKiBgc2l6ZWAgYW5kIGBhbGlnbmAgYXJlIHRoZSBzaXplIGFuZCBhbGlnbm1lbnQgb2YgVCwgbm90IG9mIE9wdGlvbjxUPlxuKi9cbmV4cG9ydCBmdW5jdGlvbiB3cml0ZU9wdGlvblRvQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIG9mZnNldCwganNWYWx1ZSwgc2l6ZSwgYWxpZ24sIHdyaXRlVG9BcnJheUJ1ZmZlckNhbGxiYWNrKSB7XG4gICAgLy8gcGVyZm9ybSBhIG51bGxpc2ggY2hlY2ssIG5vdCBhIG51bGwgY2hlY2ssXG4gICAgLy8gd2Ugd2FudCBpZGVudGljYWwgYmVoYXZpb3IgZm9yIHVuZGVmaW5lZFxuICAgIGlmIChqc1ZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgd3JpdGVUb0FycmF5QnVmZmVyQ2FsbGJhY2soYXJyYXlCdWZmZXIsIG9mZnNldCwganNWYWx1ZSk7XG4gICAgICAgIHdyaXRlVG9BcnJheUJ1ZmZlcihhcnJheUJ1ZmZlciwgb2Zmc2V0ICsgc2l6ZSwgMSwgVWludDhBcnJheSk7XG4gICAgfVxufVxuXG4vKipcbiogRm9yIE9wdGlvbjxUPiBvZiBnaXZlbiBzaXplL2FsaWduIChvZiBULCBub3QgdGhlIG92ZXJhbGwgb3B0aW9uIHR5cGUpLFxuKiByZXR1cm4gYW4gYXJyYXkgb2YgZmllbGRzIHN1aXRhYmxlIGZvciBwYXNzaW5nIGRvd24gdG8gYSBwYXJhbWV0ZXIgbGlzdC5cbipcbiogQ2FsbHMgd3JpdGVUb0FycmF5QnVmZmVyQ2FsbGJhY2soYXJyYXlCdWZmZXIsIG9mZnNldCwganNWYWx1ZSkgZm9yIG5vbi1udWxsIGpzVmFsdWVzXG4qXG4qIFRoaXMgYXJyYXkgd2lsbCBoYXZlIHNpemU8VD4vYWxpZ248VD4gZWxlbWVudHMgZm9yIHRoZSBhY3R1YWwgVCwgdGhlbiBvbmUgZWxlbWVudFxuKiBmb3IgdGhlIGlzX29rIGJvb2wsIGFuZCB0aGVuIGFsaWduPFQ+IC0gMSBlbGVtZW50cyBmb3IgcGFkZGluZy5cbipcbiogU2VlIHdhc21fYWJpX3F1aXJrcy5tZCdzIHNlY3Rpb24gb24gVW5pb25zIGZvciB1bmRlcnN0YW5kaW5nIHRoaXMgQUJJLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25Ub0FyZ3NGb3JDYWxsaW5nKGpzVmFsdWUsIHNpemUsIGFsaWduLCB3cml0ZVRvQXJyYXlCdWZmZXJDYWxsYmFjaykge1xuICAgIGxldCBhcmdzO1xuICAgIC8vIHBlcmZvcm0gYSBudWxsaXNoIGNoZWNrLCBub3QgYSBudWxsIGNoZWNrLFxuICAgIC8vIHdlIHdhbnQgaWRlbnRpY2FsIGJlaGF2aW9yIGZvciB1bmRlZmluZWRcbiAgICBpZiAoanNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIC8vIFdlIG5lZWQgb3VyIG9yaWdpbmF0b3IgYXJyYXkgdG8gYmUgcHJvcGVybHkgYWxpZ25lZFxuICAgICAgICBpZiAoYWxpZ24gPT0gOCkge1xuICAgICAgICAgICAgYnVmZmVyID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHNpemUgLyBhbGlnbik7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT0gNCkge1xuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KHNpemUgLyBhbGlnbik7XG4gICAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT0gMikge1xuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KHNpemUgLyBhbGlnbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShzaXplIC8gYWxpZ24pO1xuICAgICAgICB9XG5cblxuICAgICAgICB3cml0ZVRvQXJyYXlCdWZmZXJDYWxsYmFjayhidWZmZXIuYnVmZmVyLCAwLCBqc1ZhbHVlKTtcbiAgICAgICAgYXJncyA9IEFycmF5LmZyb20oYnVmZmVyKTtcbiAgICAgICAgYXJncy5wdXNoKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGFyZ3MgPSBBcnJheShzaXplIC8gYWxpZ24pLmZpbGwoMCk7XG4gICAgICAgIGFyZ3MucHVzaCgwKTtcbiAgICB9XG5cbiAgICAvLyBVbmNvbmRpdGlvbmFsbHkgYWRkIHBhZGRpbmdcbiAgICBhcmdzID0gYXJncy5jb25jYXQoQXJyYXkoYWxpZ24gLSAxKS5maWxsKDApKTtcbiAgICByZXR1cm4gYXJncztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvblRvQnVmZmVyRm9yQ2FsbGluZyh3YXNtLCBqc1ZhbHVlLCBzaXplLCBhbGlnbiwgYWxsb2NhdG9yLCB3cml0ZVRvQXJyYXlCdWZmZXJDYWxsYmFjaykge1xuICAgIGxldCBidWYgPSBEaXBsb21hdEJ1Zi5zdHJ1Y3Qod2FzbSwgc2l6ZSwgYWxpZ24pO1xuXG4gICAgbGV0IGJ1ZmZlcjtcbiAgICAvLyBBZGQgMSB0byB0aGUgc2l6ZSBzaW5jZSB3ZSdyZSBhbHNvIGFjY291bnRpbmcgZm9yIHRoZSAwIG9yIDEgaXNfb2sgZmllbGQ6XG4gICAgaWYgKGFsaWduID09IDgpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IEJpZ1VpbnQ2NEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgYnVmLCBzaXplIC8gYWxpZ24gKyAxKTtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09IDQpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgYnVmLCBzaXplIC8gYWxpZ24gKyAxKTtcbiAgICB9IGVsc2UgaWYgKGFsaWduID09IDIpIHtcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgYnVmLCBzaXplIC8gYWxpZ24gKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIsIGJ1Ziwgc2l6ZSAvIGFsaWduICsgMSk7XG4gICAgfVxuXG4gICAgYnVmZmVyLmZpbGwoMCk7XG5cbiAgICBpZiAoanNWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHdyaXRlVG9BcnJheUJ1ZmZlckNhbGxiYWNrKGJ1ZmZlci5idWZmZXIsIDAsIGpzVmFsdWUpO1xuICAgICAgICBidWZmZXJbYnVmZmVyLmxlbmd0aCAtIDFdID0gMTtcbiAgICB9XG5cbiAgICBhbGxvY2F0b3IuYWxsb2MoYnVmKTtcbn1cblxuXG4vKipcbiogR2l2ZW4gYHB0cmAgaW4gV2FzbSBtZW1vcnksIHRyZWF0IGl0IGFzIGFuIE9wdGlvbjxUPiB3aXRoIHNpemUgZm9yIHR5cGUgVCxcbiogYW5kIHJldHVybiB0aGUgY29udmVydGVkIFQgKGNvbnZlcnRlZCB1c2luZyBgcmVhZENhbGxiYWNrKHdhc20sIHB0cilgKSBpZiB0aGUgT3B0aW9uIGlzIFNvbWVcbiogZWxzZSBOb25lLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiByZWFkT3B0aW9uKHdhc20sIHB0ciwgc2l6ZSwgcmVhZENhbGxiYWNrKSB7XG4gICAgLy8gRG9uJ3QgbmVlZCB0aGUgYWxpZ25tZW50OiBkaXBsb21hdCB0eXBlcyBkb24ndCBoYXZlIG92ZXJyaWRkZW4gYWxpZ25tZW50LFxuICAgIC8vIHNvIHRoZSBmbGFnIHdpbGwgaW1tZWRpYXRlbHkgYmUgYWZ0ZXIgdGhlIGlubmVyIHN0cnVjdC5cbiAgICBsZXQgZmxhZyA9IHJlc3VsdEZsYWcod2FzbSwgcHRyLCBzaXplKTtcbiAgICBpZiAoZmxhZykge1xuICAgICAgICByZXR1cm4gcmVhZENhbGxiYWNrKHdhc20sIHB0cik7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgd3JhcHBlciBhcm91bmQgYSBzbGljZSBvZiBXQVNNIG1lbW9yeSB0aGF0IGNhbiBiZSBmcmVlZCBtYW51YWxseSBvclxuICogYXV0b21hdGljYWxseSBieSB0aGUgZ2FyYmFnZSBjb2xsZWN0b3IuXG4gKlxuICogVGhpcyB0eXBlIGlzIG5lY2Vzc2FyeSBmb3IgUnVzdCBmdW5jdGlvbnMgdGhhdCB0YWtlIGEgYCZzdHJgIG9yIGAmW1RdYCwgc2luY2VcbiAqIHRoZXkgY2FuIGNyZWF0ZSBhbiBlZGdlIHRvIHRoaXMgb2JqZWN0IGlmIHRoZXkgYm9ycm93IGZyb20gdGhlIHN0ci9zbGljZSxcbiAqIG9yIHdlIGNhbiBtYW51YWxseSBmcmVlIHRoZSBXQVNNIG1lbW9yeSBpZiB0aGV5IGRvbid0LlxuICovXG5leHBvcnQgY2xhc3MgRGlwbG9tYXRCdWYge1xuICAgIHN0YXRpYyBzdHI4ID0gKHdhc20sIHN0cmluZykgPT4ge1xuICAgIHZhciB1dGY4TGVuZ3RoID0gMDtcbiAgICBmb3IgKGNvbnN0IGNvZGVwb2ludFN0cmluZyBvZiBzdHJpbmcpIHtcbiAgICAgICAgbGV0IGNvZGVwb2ludCA9IGNvZGVwb2ludFN0cmluZy5jb2RlUG9pbnRBdCgwKTtcbiAgICAgICAgaWYgKGNvZGVwb2ludCA8IDB4ODApIHtcbiAgICAgICAgdXRmOExlbmd0aCArPSAxXG4gICAgICAgIH0gZWxzZSBpZiAoY29kZXBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgdXRmOExlbmd0aCArPSAyXG4gICAgICAgIH0gZWxzZSBpZiAoY29kZXBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICB1dGY4TGVuZ3RoICs9IDNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXRmOExlbmd0aCArPSA0XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwdHIgPSB3YXNtLmRpcGxvbWF0X2FsbG9jKHV0ZjhMZW5ndGgsIDEpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGVJbnRvKHN0cmluZywgbmV3IFVpbnQ4QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIHV0ZjhMZW5ndGgpKTtcbiAgICBjb25zb2xlLmFzc2VydChzdHJpbmcubGVuZ3RoID09PSByZXN1bHQucmVhZCAmJiB1dGY4TGVuZ3RoID09PSByZXN1bHQud3JpdHRlbiwgXCJVVEYtOCB3cml0ZSBlcnJvclwiKTtcblxuICAgIHJldHVybiBuZXcgRGlwbG9tYXRCdWYocHRyLCB1dGY4TGVuZ3RoLCAoKSA9PiB3YXNtLmRpcGxvbWF0X2ZyZWUocHRyLCB1dGY4TGVuZ3RoLCAxKSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHN0cjE2ID0gKHdhc20sIHN0cmluZykgPT4ge1xuICAgIGNvbnN0IGJ5dGVMZW5ndGggPSBzdHJpbmcubGVuZ3RoICogMjtcbiAgICBjb25zdCBwdHIgPSB3YXNtLmRpcGxvbWF0X2FsbG9jKGJ5dGVMZW5ndGgsIDIpO1xuXG4gICAgY29uc3QgZGVzdGluYXRpb24gPSBuZXcgVWludDE2QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIHN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlc3RpbmF0aW9uW2ldID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBEaXBsb21hdEJ1ZihwdHIsIHN0cmluZy5sZW5ndGgsICgpID0+IHdhc20uZGlwbG9tYXRfZnJlZShwdHIsIGJ5dGVMZW5ndGgsIDIpKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc2xpY2VXcmFwcGVyID0gKHdhc20sIGJ1ZikgPT4ge1xuICAgICAgICBjb25zdCBwdHIgPSB3YXNtLmRpcGxvbWF0X2FsbG9jKDgsIDQpO1xuICAgICAgICBsZXQgZHN0ID0gbmV3IFVpbnQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgcHRyLCAyKTtcblxuICAgICAgICBkc3RbMF0gPSBidWYucHRyO1xuICAgICAgICBkc3RbMV0gPSBidWYuc2l6ZTtcbiAgICAgICAgcmV0dXJuIG5ldyBEaXBsb21hdEJ1ZihwdHIsIDgsICgpID0+IHtcbiAgICAgICAgICAgIHdhc20uZGlwbG9tYXRfZnJlZShwdHIsIDgsIDQpO1xuICAgICAgICAgICAgYnVmLmZyZWUoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3RhdGljIHNsaWNlID0gKHdhc20sIGxpc3QsIHJ1c3RUeXBlKSA9PiB7XG4gICAgY29uc3QgZWxlbWVudFNpemUgPSBydXN0VHlwZSA9PT0gXCJ1OFwiIHx8IHJ1c3RUeXBlID09PSBcImk4XCIgfHwgcnVzdFR5cGUgPT09IFwiYm9vbGVhblwiID8gMSA6XG4gICAgICAgIHJ1c3RUeXBlID09PSBcInUxNlwiIHx8IHJ1c3RUeXBlID09PSBcImkxNlwiID8gMiA6XG4gICAgICAgIHJ1c3RUeXBlID09PSBcInU2NFwiIHx8IHJ1c3RUeXBlID09PSBcImk2NFwiIHx8IHJ1c3RUeXBlID09PSBcImY2NFwiID8gOCA6XG4gICAgICAgICAgICA0O1xuXG4gICAgY29uc3QgYnl0ZUxlbmd0aCA9IGxpc3QubGVuZ3RoICogZWxlbWVudFNpemU7XG4gICAgY29uc3QgcHRyID0gd2FzbS5kaXBsb21hdF9hbGxvYyhieXRlTGVuZ3RoLCBlbGVtZW50U2l6ZSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW4gYXJyYXkgdmlldyBvZiB0aGUgYnVmZmVyLiBUaGlzIGdpdmVzIHVzIHRoZSBgc2V0YCBtZXRob2Qgd2hpY2ggY29ycmVjdGx5IGhhbmRsZXMgdW50eXBlZCB2YWx1ZXNcbiAgICAgKi9cbiAgICBjb25zdCBkZXN0aW5hdGlvbiA9XG4gICAgICAgIHJ1c3RUeXBlID09PSBcInU4XCIgfHwgcnVzdFR5cGUgPT09IFwiYm9vbGVhblwiID8gbmV3IFVpbnQ4QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIGJ5dGVMZW5ndGgpIDpcbiAgICAgICAgcnVzdFR5cGUgPT09IFwiaThcIiA/IG5ldyBJbnQ4QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIGJ5dGVMZW5ndGgpIDpcbiAgICAgICAgICAgIHJ1c3RUeXBlID09PSBcInUxNlwiID8gbmV3IFVpbnQxNkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgcHRyLCBieXRlTGVuZ3RoKSA6XG4gICAgICAgICAgICBydXN0VHlwZSA9PT0gXCJpMTZcIiA/IG5ldyBJbnQxNkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgcHRyLCBieXRlTGVuZ3RoKSA6XG4gICAgICAgICAgICAgICAgcnVzdFR5cGUgPT09IFwiaTMyXCIgPyBuZXcgSW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIsIHB0ciwgYnl0ZUxlbmd0aCkgOlxuICAgICAgICAgICAgICAgIHJ1c3RUeXBlID09PSBcInU2NFwiID8gbmV3IEJpZ1VpbnQ2NEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgcHRyLCBieXRlTGVuZ3RoKSA6XG4gICAgICAgICAgICAgICAgICAgIHJ1c3RUeXBlID09PSBcImk2NFwiID8gbmV3IEJpZ0ludDY0QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIGJ5dGVMZW5ndGgpIDpcbiAgICAgICAgICAgICAgICAgICAgcnVzdFR5cGUgPT09IFwiZjMyXCIgPyBuZXcgRmxvYXQzMkFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlciwgcHRyLCBieXRlTGVuZ3RoKSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBydXN0VHlwZSA9PT0gXCJmNjRcIiA/IG5ldyBGbG9hdDY0QXJyYXkod2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIGJ5dGVMZW5ndGgpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBVaW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIsIHB0ciwgYnl0ZUxlbmd0aCk7XG4gICAgZGVzdGluYXRpb24uc2V0KGxpc3QpO1xuXG4gICAgcmV0dXJuIG5ldyBEaXBsb21hdEJ1ZihwdHIsIGxpc3QubGVuZ3RoLCAoKSA9PiB3YXNtLmRpcGxvbWF0X2ZyZWUocHRyLCBieXRlTGVuZ3RoLCBlbGVtZW50U2l6ZSkpO1xuICAgIH1cblxuICAgIHN0YXRpYyBzdHJzID0gKHdhc20sIHN0cmluZ3MsIGVuY29kaW5nKSA9PiB7XG4gICAgICAgIGxldCBlbmNvZGVTdHIgPSAoZW5jb2RpbmcgPT09IFwic3RyaW5nMTZcIikgPyBEaXBsb21hdEJ1Zi5zdHIxNiA6IERpcGxvbWF0QnVmLnN0cjg7XG5cbiAgICAgICAgY29uc3QgYnl0ZUxlbmd0aCA9IHN0cmluZ3MubGVuZ3RoICogNCAqIDI7XG5cbiAgICAgICAgY29uc3QgcHRyID0gd2FzbS5kaXBsb21hdF9hbGxvYyhieXRlTGVuZ3RoLCA0KTtcblxuICAgICAgICBjb25zdCBkZXN0aW5hdGlvbiA9IG5ldyBVaW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIsIHB0ciwgYnl0ZUxlbmd0aCk7XG5cbiAgICAgICAgY29uc3Qgc3RyaW5nc0FsbG9jID0gW107XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzdHJpbmdzQWxsb2MucHVzaChlbmNvZGVTdHIod2FzbSwgc3RyaW5nc1tpXSkpO1xuXG4gICAgICAgICAgICBkZXN0aW5hdGlvblsyICogaV0gPSBzdHJpbmdzQWxsb2NbaV0ucHRyO1xuICAgICAgICAgICAgZGVzdGluYXRpb25bKDIgKiBpKSArIDFdID0gc3RyaW5nc0FsbG9jW2ldLnNpemU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IERpcGxvbWF0QnVmKHB0ciwgc3RyaW5ncy5sZW5ndGgsICgpID0+IHtcbiAgICAgICAgICAgIHdhc20uZGlwbG9tYXRfZnJlZShwdHIsIGJ5dGVMZW5ndGgsIDQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzQWxsb2MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdzQWxsb2NbaV0uZnJlZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdGF0aWMgc3RydWN0ID0gKHdhc20sIHNpemUsIGFsaWduKSA9PiB7XG4gICAgICAgIGNvbnN0IHB0ciA9IHdhc20uZGlwbG9tYXRfYWxsb2Moc2l6ZSwgYWxpZ24pO1xuXG4gICAgICAgIHJldHVybiBuZXcgRGlwbG9tYXRCdWYocHRyLCBzaXplLCAoKSA9PiB7XG4gICAgICAgICAgICB3YXNtLmRpcGxvbWF0X2ZyZWUocHRyLCBzaXplLCBhbGlnbik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlZCBjb2RlIGNhbGxzIG9uZSBvZiBtZXRob2RzIHRoZXNlIGZvciBlYWNoIGFsbG9jYXRpb24sIHRvIGVpdGhlclxuICAgICAqIGZyZWUgZGlyZWN0bHkgYWZ0ZXIgdGhlIEZGSSBjYWxsLCB0byBsZWFrICh0byBjcmVhdGUgYSAmJ3N0YXRpYyksIG9yIHRvXG4gICAgICogcmVnaXN0ZXIgdGhlIGJ1ZmZlciB3aXRoIHRoZSBnYXJiYWdlIGNvbGxlY3RvciAodG8gY3JlYXRlIGEgJidhKS5cbiAgICAgKi9cbiAgICBmcmVlO1xuXG4gICAgY29uc3RydWN0b3IocHRyLCBzaXplLCBmcmVlKSB7XG4gICAgICAgIHRoaXMucHRyID0gcHRyO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmZyZWUgPSBmcmVlO1xuICAgICAgICB0aGlzLmxlYWsgPSAoKSA9PiB7IH07XG4gICAgICAgIHRoaXMucmVsZWFzZVRvR2FyYmFnZUNvbGxlY3RvciA9ICgpID0+IERpcGxvbWF0QnVmZmVyRmluYWxpemVyLnJlZ2lzdGVyKHRoaXMsIHRoaXMuZnJlZSk7XG4gICAgfVxuXG4gICAgc3BsYXQoKSB7XG4gICAgICAgIHJldHVybiBbdGhpcy5wdHIsIHRoaXMuc2l6ZV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV3JpdGUgdGhlIChwdHIsIGxlbikgcGFpciB0byBhbiBhcnJheSBidWZmZXIgYXQgYnl0ZSBvZmZzZXQgYG9mZnNldGBcbiAgICAgKi9cbiAgICB3cml0ZVB0ckxlblRvQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIG9mZnNldCkge1xuICAgICAgICB3cml0ZVRvQXJyYXlCdWZmZXIoYXJyYXlCdWZmZXIsIG9mZnNldCwgdGhpcy5wdHIsIFVpbnQzMkFycmF5KTtcbiAgICAgICAgd3JpdGVUb0FycmF5QnVmZmVyKGFycmF5QnVmZmVyLCBvZmZzZXQgKyA0LCB0aGlzLnNpemUsIFVpbnQzMkFycmF5KTtcbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIGZvciBjcmVhdGluZyBhbmQgbWFuYWdpbmcgYGRpcGxvbWF0X2J1ZmZlcl93cml0ZWAuXG4gKiBNZWFudCB0byBtaW5pbWl6ZSBkaXJlY3QgY2FsbHMgdG8gYHdhc21gLlxuICovXG5leHBvcnQgY2xhc3MgRGlwbG9tYXRXcml0ZUJ1ZiB7XG4gICAgbGVhaztcblxuICAgICN3YXNtO1xuICAgICNidWZmZXI7XG5cbiAgICBjb25zdHJ1Y3Rvcih3YXNtKSB7XG4gICAgICAgIHRoaXMuI3dhc20gPSB3YXNtO1xuICAgICAgICB0aGlzLiNidWZmZXIgPSB0aGlzLiN3YXNtLmRpcGxvbWF0X2J1ZmZlcl93cml0ZV9jcmVhdGUoMCk7XG5cbiAgICAgICAgdGhpcy5sZWFrID0gKCkgPT4geyB9O1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIHRoaXMuI3dhc20uZGlwbG9tYXRfYnVmZmVyX3dyaXRlX2Rlc3Ryb3kodGhpcy4jYnVmZmVyKTtcbiAgICB9XG5cbiAgICByZWxlYXNlVG9HYXJiYWdlQ29sbGVjdG9yKCkge1xuICAgICAgICBEaXBsb21hdEJ1ZmZlckZpbmFsaXplci5yZWdpc3Rlcih0aGlzLCB0aGlzLmZyZWUpO1xuICAgIH1cblxuICAgIHJlYWRTdHJpbmc4KCkge1xuICAgICAgICByZXR1cm4gcmVhZFN0cmluZzgodGhpcy4jd2FzbSwgdGhpcy5wdHIsIHRoaXMuc2l6ZSk7XG4gICAgfVxuXG4gICAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1ZmZlcjtcbiAgICB9XG5cbiAgICBnZXQgcHRyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jd2FzbS5kaXBsb21hdF9idWZmZXJfd3JpdGVfZ2V0X2J5dGVzKHRoaXMuI2J1ZmZlcik7XG4gICAgfVxuXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiN3YXNtLmRpcGxvbWF0X2J1ZmZlcl93cml0ZV9sZW4odGhpcy4jYnVmZmVyKTtcbiAgICB9XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyBhbiB1bmRlcmx5aW5nIHNsaWNlIHRoYXQgd2UndmUgZ3JhYmJlZCBmcm9tIFdlYkFzc2VtYmx5LlxuICogWW91IGNhbiB0cmVhdCB0aGlzIGluIEpTIGFzIGEgcmVndWxhciBzbGljZSBvZiBwcmltaXRpdmVzLCBidXQgaXQgaGFuZGxlcyBhZGRpdGlvbmFsIGRhdGEgZm9yIHlvdSBiZWhpbmQgdGhlIHNjZW5lcy5cbiAqL1xuZXhwb3J0IGNsYXNzIERpcGxvbWF0U2xpY2Uge1xuICAgICN3YXNtO1xuXG4gICAgI2J1ZmZlclR5cGU7XG4gICAgZ2V0IGJ1ZmZlclR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNidWZmZXJUeXBlO1xuICAgIH1cblxuICAgICNidWZmZXI7XG4gICAgZ2V0IGJ1ZmZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1ZmZlcjtcbiAgICB9XG5cbiAgICAjbGlmZXRpbWVFZGdlcztcblxuICAgIGNvbnN0cnVjdG9yKHdhc20sIGJ1ZmZlciwgYnVmZmVyVHlwZSwgbGlmZXRpbWVFZGdlcykge1xuICAgICAgICB0aGlzLiN3YXNtID0gd2FzbTtcblxuICAgICAgICBjb25zdCBbcHRyLCBzaXplXSA9IG5ldyBVaW50MzJBcnJheSh0aGlzLiN3YXNtLm1lbW9yeS5idWZmZXIsIGJ1ZmZlciwgMik7XG5cbiAgICAgICAgdGhpcy4jYnVmZmVyID0gbmV3IGJ1ZmZlclR5cGUodGhpcy4jd2FzbS5tZW1vcnkuYnVmZmVyLCBwdHIsIHNpemUpO1xuICAgICAgICB0aGlzLiNidWZmZXJUeXBlID0gYnVmZmVyVHlwZTtcblxuICAgICAgICB0aGlzLiNsaWZldGltZUVkZ2VzID0gbGlmZXRpbWVFZGdlcztcbiAgICB9XG5cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2J1ZmZlcjtcbiAgICB9XG5cbiAgICBbU3ltYm9sLnRvUHJpbWl0aXZlXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICB2YWx1ZU9mKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERpcGxvbWF0U2xpY2VQcmltaXRpdmUgZXh0ZW5kcyBEaXBsb21hdFNsaWNlIHtcbiAgICBjb25zdHJ1Y3Rvcih3YXNtLCBidWZmZXIsIHNsaWNlVHlwZSwgbGlmZXRpbWVFZGdlcykge1xuICAgICAgICBjb25zdCBbcHRyLCBzaXplXSA9IG5ldyBVaW50MzJBcnJheSh3YXNtLm1lbW9yeS5idWZmZXIsIGJ1ZmZlciwgMik7XG5cbiAgICAgICAgbGV0IGFycmF5VHlwZTtcbiAgICAgICAgc3dpdGNoIChzbGljZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1OFwiOlxuICAgICAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgICAgICBhcnJheVR5cGUgPSBVaW50OEFycmF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImk4XCI6XG4gICAgICAgICAgICAgICAgYXJyYXlUeXBlID0gSW50OEFycmF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInUxNlwiOlxuICAgICAgICAgICAgICAgIGFycmF5VHlwZSA9IFVpbnQxNkFycmF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImkxNlwiOlxuICAgICAgICAgICAgICAgIGFycmF5VHlwZSA9IEludDE2QXJyYXk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiaTMyXCI6XG4gICAgICAgICAgICAgICAgYXJyYXlUeXBlID0gSW50MzJBcnJheTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ1MzJcIjpcbiAgICAgICAgICAgICAgICBhcnJheVR5cGUgPSBVaW50MzJBcnJheTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJpNjRcIjpcbiAgICAgICAgICAgICAgICBhcnJheVR5cGUgPSBCaWdJbnQ2NEFycmF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInU2NFwiOlxuICAgICAgICAgICAgICAgIGFycmF5VHlwZSA9IEJpZ1VpbnQ2NEFycmF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImYzMlwiOlxuICAgICAgICAgICAgICAgIGFycmF5VHlwZSA9IEZsb2F0MzJBcnJheTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJmNjRcIjpcbiAgICAgICAgICAgICAgICBhcnJheVR5cGUgPSBGbG9hdDY0QXJyYXk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbnJlY29nbml6ZWQgYnVmZmVyVHlwZSBcIiwgYnVmZmVyVHlwZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlcih3YXNtLCBidWZmZXIsIGFycmF5VHlwZSwgbGlmZXRpbWVFZGdlcyk7XG4gICAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGlwbG9tYXRTbGljZVN0ciBleHRlbmRzIERpcGxvbWF0U2xpY2Uge1xuICAgICNkZWNvZGVyO1xuXG4gICAgY29uc3RydWN0b3Iod2FzbSwgYnVmZmVyLCBzdHJpbmdFbmNvZGluZywgbGlmZXRpbWVFZGdlcykge1xuICAgICAgICBsZXQgZW5jb2Rpbmc7XG4gICAgICAgIHN3aXRjaCAoc3RyaW5nRW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmc4XCI6XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBVaW50OEFycmF5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInN0cmluZzE2XCI6XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBVaW50MTZBcnJheTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlVucmVjb2duaXplZCBzdHJpbmdFbmNvZGluZyBcIiwgc3RyaW5nRW5jb2RpbmcpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHdhc20sIGJ1ZmZlciwgZW5jb2RpbmcsIGxpZmV0aW1lRWRnZXMpO1xuXG4gICAgICAgIGlmIChzdHJpbmdFbmNvZGluZyA9PT0gXCJzdHJpbmc4XCIpIHtcbiAgICAgICAgICAgIHRoaXMuI2RlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoJ3V0Zi04Jyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRWYWx1ZSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLmJ1ZmZlclR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy4jZGVjb2Rlci5kZWNvZGUoc3VwZXIuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHN1cGVyLmdldFZhbHVlKCkpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIERpcGxvbWF0U2xpY2VTdHJpbmdzIGV4dGVuZHMgRGlwbG9tYXRTbGljZSB7XG4gICAgI3N0cmluZ3MgPSBbXTtcbiAgICBjb25zdHJ1Y3Rvcih3YXNtLCBidWZmZXIsIHN0cmluZ0VuY29kaW5nLCBsaWZldGltZUVkZ2VzKSB7XG4gICAgICAgIHN1cGVyKHdhc20sIGJ1ZmZlciwgVWludDMyQXJyYXksIGxpZmV0aW1lRWRnZXMpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmJ1ZmZlci5ieXRlT2Zmc2V0OyBpIDwgdGhpcy5idWZmZXIuYnl0ZUxlbmd0aDsgaSArPSB0aGlzLmJ1ZmZlci5CWVRFU19QRVJfRUxFTUVOVCAqIDIpIHtcbiAgICAgICAgICAgIHRoaXMuI3N0cmluZ3MucHVzaChuZXcgRGlwbG9tYXRTbGljZVN0cih3YXNtLCBpLCBzdHJpbmdFbmNvZGluZywgbGlmZXRpbWVFZGdlcykpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNzdHJpbmdzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIG51bWJlciBvZiBSdXN0IGZ1bmN0aW9ucyBpbiBXZWJBc3NlbWJseSByZXF1aXJlIGEgYnVmZmVyIHRvIHBvcHVsYXRlIHN0cnVjdCwgc2xpY2UsIE9wdGlvbjw+IG9yIFJlc3VsdDw+IHR5cGVzIHdpdGggaW5mb3JtYXRpb24uXG4gKiB7QGxpbmsgRGlwbG9tYXRSZWNlaXZlQnVmfSBhbGxvY2F0ZXMgYSBidWZmZXIgaW4gV2ViQXNzZW1ibHksIHdoaWNoIGNhbiB0aGVuIGJlIHBhc3NlZCBpbnRvIGZ1bmN0aW9ucyB3aXRoIHRoZSB7QGxpbmsgRGlwbG9tYXRSZWNlaXZlQnVmLmJ1ZmZlcn1cbiAqIHByb3BlcnR5LlxuICovXG5leHBvcnQgY2xhc3MgRGlwbG9tYXRSZWNlaXZlQnVmIHtcbiAgICAjd2FzbTtcblxuICAgICNzaXplO1xuICAgICNhbGlnbjtcblxuICAgICNoYXNSZXN1bHQ7XG5cbiAgICAjYnVmZmVyO1xuXG4gICAgY29uc3RydWN0b3Iod2FzbSwgc2l6ZSwgYWxpZ24sIGhhc1Jlc3VsdCkge1xuICAgICAgICB0aGlzLiN3YXNtID0gd2FzbTtcblxuICAgICAgICB0aGlzLiNzaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy4jYWxpZ24gPSBhbGlnbjtcblxuICAgICAgICB0aGlzLiNoYXNSZXN1bHQgPSBoYXNSZXN1bHQ7XG5cbiAgICAgICAgdGhpcy4jYnVmZmVyID0gdGhpcy4jd2FzbS5kaXBsb21hdF9hbGxvYyh0aGlzLiNzaXplLCB0aGlzLiNhbGlnbik7XG5cbiAgICAgICAgdGhpcy5sZWFrID0gKCkgPT4geyB9O1xuICAgIH1cblxuICAgIGZyZWUoKSB7XG4gICAgICAgIHRoaXMuI3dhc20uZGlwbG9tYXRfZnJlZSh0aGlzLiNidWZmZXIsIHRoaXMuI3NpemUsIHRoaXMuI2FsaWduKTtcbiAgICB9XG5cbiAgICBnZXQgYnVmZmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYnVmZmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9ubHkgZm9yIHdoZW4gYSBEaXBsb21hdFJlY2VpdmVCdWYgaXMgYWxsb2NhdGluZyBhIGJ1ZmZlciBmb3IgYW4gYE9wdGlvbjw+YCBvciBhIGBSZXN1bHQ8PmAgdHlwZS5cbiAgICAgKlxuICAgICAqIFRoaXMganVzdCBjaGVja3MgdGhlIGxhc3QgYnl0ZSBmb3IgYSBzdWNjZXNzZnVsIHJlc3VsdCAoYXNzdW1pbmcgdGhhdCBSdXN0J3MgY29tcGlsZXIgZG9lcyBub3QgY2hhbmdlKS5cbiAgICAgKi9cbiAgICBnZXQgcmVzdWx0RmxhZygpIHtcbiAgICAgICAgaWYgKHRoaXMuI2hhc1Jlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdEZsYWcodGhpcy4jd2FzbSwgdGhpcy4jYnVmZmVyLCB0aGlzLiNzaXplIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBGb3IgcHJlYWxsb2NhdGluZyBvd25lZCBzbGljZXNcbiAqXG4gKiBEb2Vzbid0IGFjdHVhbGx5IGRvIGFueXRoaW5nLCBidXQgaGVscHMgY29kZSByZWFkYWJpbGl0eSBvZiBnZW5lcmF0ZWQgY29kZVxuICovXG5leHBvcnQgY2xhc3MgT3duZWRTbGljZUxlYWtlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVhayBhbiBpdGVtXG4gICAgICogQHBhcmFtIHtEaXBsb21hdEJ1Zn0gaXRlbVxuICAgICAqIEByZXR1cm5zIHtEaXBsb21hdEJ1Zn1cbiAgICAgKi9cbiAgICBzdGF0aWMgYWxsb2MoaXRlbSkge1xuICAgICAgICBpdGVtLmxlYWsoKTtcbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxufVxuXG4vKipcbiAqIEZvciBjbGVhbmluZyB1cCBzbGljZXMgaW5zaWRlIHN0cnVjdCBfaW50b0ZGSSBmdW5jdGlvbnMuXG4gKiBCYXNlZCBzb21ld2hhdCBvbiBob3cgdGhlIERhcnQgYmFja2VuZCBoYW5kbGVzIHNsaWNlIGNsZWFudXAuXG4gKlxuICogV2Ugd2FudCB0byBlbnN1cmUgYSBzbGljZSBvbmx5IGxhc3RzIGFzIGxvbmcgYXMgaXRzIHN0cnVjdCwgc28gd2UgaGF2ZSBhIGBmdW5jdGlvbkNsZWFudXBBcmVuYWAgQ2xlYW51cEFyZW5hIHRoYXQgd2UgdXNlIGluIGVhY2ggbWV0aG9kIGZvciBhbnkgc2xpY2UgdGhhdCBuZWVkcyB0byBiZSBjbGVhbmVkIHVwLiBJdCBsYXN0cyBvbmx5IGFzIGxvbmcgYXMgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZCBmb3IuXG4gKlxuICogVGhlbiB3ZSBoYXZlIGBjcmVhdGVXaXRoYCwgd2hpY2ggaXMgbWVhbnQgZm9yIGxvbmdlciBsYXN0aW5nIHNsaWNlcy4gSXQgdGFrZXMgYW4gYXJyYXkgb2YgZWRnZXMgYW5kIHdpbGwgbGFzdCBhcyBsb25nIGFzIHRob3NlIGVkZ2VzIGRvLiBDbGVhbnVwIGlzIG9ubHkgY2FsbGVkIGxhdGVyLlxuICovXG5leHBvcnQgY2xhc3MgQ2xlYW51cEFyZW5hIHtcbiAgICAjaXRlbXMgPSBbXTtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhpcyBhcmVuYSBpcyBmcmVlZCwgY2FsbCAuZnJlZSgpIG9uIHRoZSBnaXZlbiBpdGVtLlxuICAgICAqIEBwYXJhbSB7RGlwbG9tYXRCdWZ9IGl0ZW1cbiAgICAgKiBAcmV0dXJucyB7RGlwbG9tYXRCdWZ9XG4gICAgICovXG4gICAgYWxsb2MoaXRlbSkge1xuICAgICAgICB0aGlzLiNpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IENsZWFudXBBcmVuYSwgYXBwZW5kIGl0IHRvIGFueSBlZGdlIGFycmF5cyBwYXNzZWQgZG93biwgYW5kIHJldHVybiBpdC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlZGdlQXJyYXlzXG4gICAgICogQHJldHVybnMge0NsZWFudXBBcmVuYX1cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlV2l0aCguLi5lZGdlQXJyYXlzKSB7XG4gICAgICAgIGxldCBzZWxmID0gbmV3IENsZWFudXBBcmVuYSgpO1xuICAgICAgICBmb3IgKGxldCBlZGdlQXJyYXkgb2YgZWRnZUFycmF5cykge1xuICAgICAgICAgICAgaWYgKGVkZ2VBcnJheSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZWRnZUFycmF5LnB1c2goc2VsZik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgRGlwbG9tYXRCdWZmZXJGaW5hbGl6ZXIucmVnaXN0ZXIoc2VsZiwgc2VsZi5mcmVlKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSWYgZ2l2ZW4gZWRnZSBhcnJheXMsIGNyZWF0ZSBhIG5ldyBDbGVhbnVwQXJlbmEsIGFwcGVuZCBpdCB0byBhbnkgZWRnZSBhcnJheXMgcGFzc2VkIGRvd24sIGFuZCByZXR1cm4gaXQuXG4gICAgICogRWxzZSByZXR1cm4gdGhlIGZ1bmN0aW9uLWxvY2FsIGNsZWFudXAgYXJlbmFcbiAgICAgKiBAcGFyYW0ge0NsZWFudXBBcmVuYX0gZnVuY3Rpb25DbGVhbnVwQXJlbmFcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBlZGdlQXJyYXlzXG4gICAgICogQHJldHVybnMge0RpcGxvbWF0QnVmfVxuICAgICAqL1xuICAgIHN0YXRpYyBtYXliZUNyZWF0ZVdpdGgoZnVuY3Rpb25DbGVhbnVwQXJlbmEsIC4uLmVkZ2VBcnJheXMpIHtcbiAgICAgICAgaWYgKGVkZ2VBcnJheXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIENsZWFudXBBcmVuYS5jcmVhdGVXaXRoKC4uLmVkZ2VBcnJheXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uQ2xlYW51cEFyZW5hXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmcmVlKCkge1xuICAgICAgICB0aGlzLiNpdGVtcy5mb3JFYWNoKChpKSA9PiB7XG4gICAgICAgICAgICBpLmZyZWUoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy4jaXRlbXMubGVuZ3RoID0gMDtcbiAgICB9XG59XG5cbi8qKlxuICogU2ltaWxhciB0byB7QGxpbmsgQ2xlYW51cEFyZW5hfSwgYnV0IGZvciBob2xkaW5nIG9uIHRvIHNsaWNlcyB1bnRpbCBhIG1ldGhvZCBpcyBjYWxsZWQsXG4gKiBhZnRlciB3aGljaCB3ZSByZWx5IG9uIHRoZSBHQyB0byBmcmVlIHRoZW0uXG4gKlxuICogVGhpcyBpcyB3aGVuIHlvdSBtYXkgd2FudCB0byB1c2UgYSBzbGljZSBsb25nZXIgdGhhbiB0aGUgYm9keSBvZiB0aGUgbWV0aG9kLlxuICpcbiAqIEF0IGZpcnN0IGdsYW5jZSB0aGlzIHNlZW1zIHVubmVjZXNzYXJ5LCBzaW5jZSB3ZSB3aWxsIGJlIGhvbGRpbmcgdGhlc2Ugc2xpY2VzIGluIGVkZ2UgYXJyYXlzIGFueXdheSxcbiAqIGhvd2V2ZXIsIGlmIGFuIGVkZ2UgYXJyYXkgZW5kcyB1cCB1bnVzZWQsIHRoZW4gd2UgZG8gYWN0dWFsbHkgbmVlZCBzb21ldGhpbmcgdG8gaG9sZCBpdCBmb3IgdGhlIGR1cmF0aW9uXG4gKiBvZiB0aGUgbWV0aG9kIGNhbGwuXG4gKi9cbmV4cG9ydCBjbGFzcyBHYXJiYWdlQ29sbGVjdG9yR3JpcCB7XG4gICAgI2l0ZW1zID0gW107XG5cbiAgICBhbGxvYyhpdGVtKSB7XG4gICAgICAgIHRoaXMuI2l0ZW1zLnB1c2goaXRlbSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cblxuICAgIHJlbGVhc2VUb0dhcmJhZ2VDb2xsZWN0b3IoKSB7XG4gICAgICAgIHRoaXMuI2l0ZW1zLmZvckVhY2goKGkpID0+IHtcbiAgICAgICAgICAgIGkucmVsZWFzZVRvR2FyYmFnZUNvbGxlY3RvcigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLiNpdGVtcy5sZW5ndGggPSAwO1xuICAgIH1cbn1cblxuY29uc3QgRGlwbG9tYXRCdWZmZXJGaW5hbGl6ZXIgPSBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoZnJlZSA9PiBmcmVlKCkpO1xuIiwiaW1wb3J0IGNmZyBmcm9tICcuLi9kaXBsb21hdC5jb25maWcubWpzJztcbmltcG9ydCB7cmVhZFN0cmluZzh9IGZyb20gJy4vZGlwbG9tYXQtcnVudGltZS5tanMnXG5pbXBvcnQgKiBhcyB3YmcgZnJvbSAnLi4vd2JnL29ubGluZV9zeW50YXhfZmZpLmpzJ1xuXG5jb25zdCBpbXBvcnRzID0ge1xuICAgIGVudjoge1xuICAgICAgICBkaXBsb21hdF9jb25zb2xlX2RlYnVnX2pzKHB0ciwgbGVuKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKHJlYWRTdHJpbmc4KHdhc20sIHB0ciwgbGVuKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpcGxvbWF0X2NvbnNvbGVfZXJyb3JfanMocHRyLCBsZW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVhZFN0cmluZzgod2FzbSwgcHRyLCBsZW4pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlwbG9tYXRfY29uc29sZV9pbmZvX2pzKHB0ciwgbGVuKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8ocmVhZFN0cmluZzgod2FzbSwgcHRyLCBsZW4pKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlwbG9tYXRfY29uc29sZV9sb2dfanMocHRyLCBsZW4pIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHJlYWRTdHJpbmc4KHdhc20sIHB0ciwgbGVuKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpcGxvbWF0X2NvbnNvbGVfd2Fybl9qcyhwdHIsIGxlbikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKHJlYWRTdHJpbmc4KHdhc20sIHB0ciwgbGVuKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGRpcGxvbWF0X3Rocm93X2Vycm9yX2pzKHB0ciwgbGVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVhZFN0cmluZzgod2FzbSwgcHRyLCBsZW4pKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2JnOiB3YmcuX193YmdfZ2V0X2ltcG9ydHMoKS53Ymdcbn1cblxubGV0IHdhc20gPSBhd2FpdCB3YmcuZGVmYXVsdChpbXBvcnRzKVxuXG53YXNtLmRpcGxvbWF0X2luaXQoKTtcbmlmIChjZmdbJ2luaXQnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY2ZnWydpbml0J10od2FzbSk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHdhc207XG4iLCJcblxuZXhwb3J0IHsgQ29udGV4dCB9IGZyb20gXCIuL0NvbnRleHQubWpzXCJcblxuZXhwb3J0IHsgTGluZUNvbFNwYW4gfSBmcm9tIFwiLi9MaW5lQ29sU3Bhbi5tanNcIlxuXG5leHBvcnQgeyBDb25jcmV0ZUdyYXBoIH0gZnJvbSBcIi4vQ29uY3JldGVHcmFwaC5tanNcIlxuXG5leHBvcnQgeyBFZGdlV3JhcHBlciB9IGZyb20gXCIuL0VkZ2VXcmFwcGVyLm1qc1wiXG5cbmV4cG9ydCB7IEVkZ2VzSXRlciB9IGZyb20gXCIuL0VkZ2VzSXRlci5tanNcIlxuXG5leHBvcnQgeyBMaW5lQ29sU3BhbnNJdGVyIH0gZnJvbSBcIi4vTGluZUNvbFNwYW5zSXRlci5tanNcIlxuXG5leHBvcnQgeyBOZXdOb2RlIH0gZnJvbSBcIi4vTmV3Tm9kZS5tanNcIlxuXG5leHBvcnQgeyBOZXdOb2Rlc0l0ZXIgfSBmcm9tIFwiLi9OZXdOb2Rlc0l0ZXIubWpzXCJcblxuZXhwb3J0IHsgTm9kZVdyYXBwZXIgfSBmcm9tIFwiLi9Ob2RlV3JhcHBlci5tanNcIlxuXG5leHBvcnQgeyBOb2Rlc0l0ZXIgfSBmcm9tIFwiLi9Ob2Rlc0l0ZXIubWpzXCJcblxuZXhwb3J0IHsgT3BDdHhBbmRGbk5hbWVzIH0gZnJvbSBcIi4vT3BDdHhBbmRGbk5hbWVzLm1qc1wiXG5cbmV4cG9ydCB7IFBhcnNlUmVzdWx0IH0gZnJvbSBcIi4vUGFyc2VSZXN1bHQubWpzXCJcblxuZXhwb3J0IHsgUnVuT3BlcmF0aW9uUmVzdWx0IH0gZnJvbSBcIi4vUnVuT3BlcmF0aW9uUmVzdWx0Lm1qc1wiXG5cbmV4cG9ydCB7IFN0cmluZ0Vycm9yIH0gZnJvbSBcIi4vU3RyaW5nRXJyb3IubWpzXCJcblxuZXhwb3J0IHsgU3RyaW5nSXRlciB9IGZyb20gXCIuL1N0cmluZ0l0ZXIubWpzXCJcblxuZXhwb3J0IHsgU3RyaW5nV3JhcHBlciB9IGZyb20gXCIuL1N0cmluZ1dyYXBwZXIubWpzXCJcbiIsImV4cG9ydCBkZWZhdWx0IHtcclxufTsiLCJcbmxldCB3YXNtO1xuXG5jb25zdCBjYWNoZWRUZXh0RGVjb2RlciA9ICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHREZWNvZGVyKCd1dGYtOCcsIHsgaWdub3JlQk9NOiB0cnVlLCBmYXRhbDogdHJ1ZSB9KSA6IHsgZGVjb2RlOiAoKSA9PiB7IHRocm93IEVycm9yKCdUZXh0RGVjb2RlciBub3QgYXZhaWxhYmxlJykgfSB9ICk7XG5cbmlmICh0eXBlb2YgVGV4dERlY29kZXIgIT09ICd1bmRlZmluZWQnKSB7IGNhY2hlZFRleHREZWNvZGVyLmRlY29kZSgpOyB9O1xuXG5sZXQgY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5mdW5jdGlvbiBnZXRVaW50OEFycmF5TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPT09IG51bGwgfHwgY2FjaGVkVWludDhBcnJheU1lbW9yeTAuYnl0ZUxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjYWNoZWRVaW50OEFycmF5TWVtb3J5MCA9IG5ldyBVaW50OEFycmF5KHdhc20ubWVtb3J5LmJ1ZmZlcik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRVaW50OEFycmF5TWVtb3J5MDtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nRnJvbVdhc20wKHB0ciwgbGVuKSB7XG4gICAgcHRyID0gcHRyID4+PiAwO1xuICAgIHJldHVybiBjYWNoZWRUZXh0RGVjb2Rlci5kZWNvZGUoZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIsIHB0ciArIGxlbikpO1xufVxuXG5sZXQgV0FTTV9WRUNUT1JfTEVOID0gMDtcblxuY29uc3QgY2FjaGVkVGV4dEVuY29kZXIgPSAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBUZXh0RW5jb2RlcigndXRmLTgnKSA6IHsgZW5jb2RlOiAoKSA9PiB7IHRocm93IEVycm9yKCdUZXh0RW5jb2RlciBub3QgYXZhaWxhYmxlJykgfSB9ICk7XG5cbmNvbnN0IGVuY29kZVN0cmluZyA9ICh0eXBlb2YgY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlSW50byA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZnVuY3Rpb24gKGFyZywgdmlldykge1xuICAgIHJldHVybiBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGVJbnRvKGFyZywgdmlldyk7XG59XG4gICAgOiBmdW5jdGlvbiAoYXJnLCB2aWV3KSB7XG4gICAgY29uc3QgYnVmID0gY2FjaGVkVGV4dEVuY29kZXIuZW5jb2RlKGFyZyk7XG4gICAgdmlldy5zZXQoYnVmKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZWFkOiBhcmcubGVuZ3RoLFxuICAgICAgICB3cml0dGVuOiBidWYubGVuZ3RoXG4gICAgfTtcbn0pO1xuXG5mdW5jdGlvbiBwYXNzU3RyaW5nVG9XYXNtMChhcmcsIG1hbGxvYywgcmVhbGxvYykge1xuXG4gICAgaWYgKHJlYWxsb2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBidWYgPSBjYWNoZWRUZXh0RW5jb2Rlci5lbmNvZGUoYXJnKTtcbiAgICAgICAgY29uc3QgcHRyID0gbWFsbG9jKGJ1Zi5sZW5ndGgsIDEpID4+PiAwO1xuICAgICAgICBnZXRVaW50OEFycmF5TWVtb3J5MCgpLnN1YmFycmF5KHB0ciwgcHRyICsgYnVmLmxlbmd0aCkuc2V0KGJ1Zik7XG4gICAgICAgIFdBU01fVkVDVE9SX0xFTiA9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIHJldHVybiBwdHI7XG4gICAgfVxuXG4gICAgbGV0IGxlbiA9IGFyZy5sZW5ndGg7XG4gICAgbGV0IHB0ciA9IG1hbGxvYyhsZW4sIDEpID4+PiAwO1xuXG4gICAgY29uc3QgbWVtID0gZ2V0VWludDhBcnJheU1lbW9yeTAoKTtcblxuICAgIGxldCBvZmZzZXQgPSAwO1xuXG4gICAgZm9yICg7IG9mZnNldCA8IGxlbjsgb2Zmc2V0KyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGFyZy5jaGFyQ29kZUF0KG9mZnNldCk7XG4gICAgICAgIGlmIChjb2RlID4gMHg3RikgYnJlYWs7XG4gICAgICAgIG1lbVtwdHIgKyBvZmZzZXRdID0gY29kZTtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0ICE9PSBsZW4pIHtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICAgICAgYXJnID0gYXJnLnNsaWNlKG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgbGVuID0gb2Zmc2V0ICsgYXJnLmxlbmd0aCAqIDMsIDEpID4+PiAwO1xuICAgICAgICBjb25zdCB2aWV3ID0gZ2V0VWludDhBcnJheU1lbW9yeTAoKS5zdWJhcnJheShwdHIgKyBvZmZzZXQsIHB0ciArIGxlbik7XG4gICAgICAgIGNvbnN0IHJldCA9IGVuY29kZVN0cmluZyhhcmcsIHZpZXcpO1xuXG4gICAgICAgIG9mZnNldCArPSByZXQud3JpdHRlbjtcbiAgICAgICAgcHRyID0gcmVhbGxvYyhwdHIsIGxlbiwgb2Zmc2V0LCAxKSA+Pj4gMDtcbiAgICB9XG5cbiAgICBXQVNNX1ZFQ1RPUl9MRU4gPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHB0cjtcbn1cblxubGV0IGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9IG51bGw7XG5cbmZ1bmN0aW9uIGdldERhdGFWaWV3TWVtb3J5MCgpIHtcbiAgICBpZiAoY2FjaGVkRGF0YVZpZXdNZW1vcnkwID09PSBudWxsIHx8IGNhY2hlZERhdGFWaWV3TWVtb3J5MC5idWZmZXIuZGV0YWNoZWQgPT09IHRydWUgfHwgKGNhY2hlZERhdGFWaWV3TWVtb3J5MC5idWZmZXIuZGV0YWNoZWQgPT09IHVuZGVmaW5lZCAmJiBjYWNoZWREYXRhVmlld01lbW9yeTAuYnVmZmVyICE9PSB3YXNtLm1lbW9yeS5idWZmZXIpKSB7XG4gICAgICAgIGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9IG5ldyBEYXRhVmlldyh3YXNtLm1lbW9yeS5idWZmZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkRGF0YVZpZXdNZW1vcnkwO1xufVxuXG5hc3luYyBmdW5jdGlvbiBfX3diZ19sb2FkKG1vZHVsZSwgaW1wb3J0cykge1xuICAgIGlmICh0eXBlb2YgUmVzcG9uc2UgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmcobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChtb2R1bGUuaGVhZGVycy5nZXQoJ0NvbnRlbnQtVHlwZScpICE9ICdhcHBsaWNhdGlvbi93YXNtJykge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmdgIGZhaWxlZCBiZWNhdXNlIHlvdXIgc2VydmVyIGRvZXMgbm90IHNlcnZlIFdhc20gd2l0aCBgYXBwbGljYXRpb24vd2FzbWAgTUlNRSB0eXBlLiBGYWxsaW5nIGJhY2sgdG8gYFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlYCB3aGljaCBpcyBzbG93ZXIuIE9yaWdpbmFsIGVycm9yOlxcblwiLCBlKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBtb2R1bGUuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJ5dGVzLCBpbXBvcnRzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gYXdhaXQgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUobW9kdWxlLCBpbXBvcnRzKTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBXZWJBc3NlbWJseS5JbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW5zdGFuY2UsIG1vZHVsZSB9O1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3diZ19nZXRfaW1wb3J0cygpIHtcbiAgICBjb25zdCBpbXBvcnRzID0ge307XG4gICAgaW1wb3J0cy53YmcgPSB7fTtcbiAgICBpbXBvcnRzLndiZy5fX3diZ19lcnJvcl83NTM0YjhlOWEzNmYxYWI0ID0gZnVuY3Rpb24oYXJnMCwgYXJnMSkge1xuICAgICAgICBsZXQgZGVmZXJyZWQwXzA7XG4gICAgICAgIGxldCBkZWZlcnJlZDBfMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRlZmVycmVkMF8wID0gYXJnMDtcbiAgICAgICAgICAgIGRlZmVycmVkMF8xID0gYXJnMTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZ2V0U3RyaW5nRnJvbVdhc20wKGFyZzAsIGFyZzEpKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHdhc20uX193YmluZGdlbl9mcmVlKGRlZmVycmVkMF8wLCBkZWZlcnJlZDBfMSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGltcG9ydHMud2JnLl9fd2JnX25ld184YTZmMjM4YTZlY2U4NmVhID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBFcnJvcigpO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193Ymdfc3RhY2tfMGVkNzVkNjg1NzViMGYzYyA9IGZ1bmN0aW9uKGFyZzAsIGFyZzEpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gYXJnMS5zdGFjaztcbiAgICAgICAgY29uc3QgcHRyMSA9IHBhc3NTdHJpbmdUb1dhc20wKHJldCwgd2FzbS5fX3diaW5kZ2VuX21hbGxvYywgd2FzbS5fX3diaW5kZ2VuX3JlYWxsb2MpO1xuICAgICAgICBjb25zdCBsZW4xID0gV0FTTV9WRUNUT1JfTEVOO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDEsIGxlbjEsIHRydWUpO1xuICAgICAgICBnZXREYXRhVmlld01lbW9yeTAoKS5zZXRJbnQzMihhcmcwICsgNCAqIDAsIHB0cjEsIHRydWUpO1xuICAgIH07XG4gICAgaW1wb3J0cy53YmcuX193YmluZGdlbl9pbml0X2V4dGVybnJlZl90YWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zdCB0YWJsZSA9IHdhc20uX193YmluZGdlbl9leHBvcnRfMztcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGFibGUuZ3Jvdyg0KTtcbiAgICAgICAgdGFibGUuc2V0KDAsIHVuZGVmaW5lZCk7XG4gICAgICAgIHRhYmxlLnNldChvZmZzZXQgKyAwLCB1bmRlZmluZWQpO1xuICAgICAgICB0YWJsZS5zZXQob2Zmc2V0ICsgMSwgbnVsbCk7XG4gICAgICAgIHRhYmxlLnNldChvZmZzZXQgKyAyLCB0cnVlKTtcbiAgICAgICAgdGFibGUuc2V0KG9mZnNldCArIDMsIGZhbHNlKTtcbiAgICAgICAgO1xuICAgIH07XG5cbiAgICByZXR1cm4gaW1wb3J0cztcbn1cblxuZnVuY3Rpb24gX193YmdfaW5pdF9tZW1vcnkoaW1wb3J0cywgbWVtb3J5KSB7XG5cbn1cblxuZnVuY3Rpb24gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKSB7XG4gICAgd2FzbSA9IGluc3RhbmNlLmV4cG9ydHM7XG4gICAgX193YmdfaW5pdC5fX3diaW5kZ2VuX3dhc21fbW9kdWxlID0gbW9kdWxlO1xuICAgIGNhY2hlZERhdGFWaWV3TWVtb3J5MCA9IG51bGw7XG4gICAgY2FjaGVkVWludDhBcnJheU1lbW9yeTAgPSBudWxsO1xuXG5cbiAgICB3YXNtLl9fd2JpbmRnZW5fc3RhcnQoKTtcbiAgICByZXR1cm4gd2FzbTtcbn1cblxuZnVuY3Rpb24gaW5pdFN5bmMoaW1wb3J0cywgbW9kdWxlKSB7XG4gICAgaWYgKHdhc20gIT09IHVuZGVmaW5lZCkgcmV0dXJuIHdhc207XG5cblxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZSkgPT09IE9iamVjdC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgICh7bW9kdWxlfSA9IG1vZHVsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndXNpbmcgZGVwcmVjYXRlZCBwYXJhbWV0ZXJzIGZvciBgaW5pdFN5bmMoKWA7IHBhc3MgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQnKVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBfX3diZ19pbml0X21lbW9yeShpbXBvcnRzKTtcblxuICAgIGlmICghKG1vZHVsZSBpbnN0YW5jZW9mIFdlYkFzc2VtYmx5Lk1vZHVsZSkpIHtcbiAgICAgICAgbW9kdWxlID0gbmV3IFdlYkFzc2VtYmx5Lk1vZHVsZShtb2R1bGUpO1xuICAgIH1cblxuICAgIGNvbnN0IGluc3RhbmNlID0gbmV3IFdlYkFzc2VtYmx5Lkluc3RhbmNlKG1vZHVsZSwgaW1wb3J0cyk7XG5cbiAgICByZXR1cm4gX193YmdfZmluYWxpemVfaW5pdChpbnN0YW5jZSwgbW9kdWxlKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gX193YmdfaW5pdChpbXBvcnRzLCBtb2R1bGVfb3JfcGF0aCkge1xuICAgIGlmICh3YXNtICE9PSB1bmRlZmluZWQpIHJldHVybiB3YXNtO1xuXG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZV9vcl9wYXRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBpZiAoT2JqZWN0LmdldFByb3RvdHlwZU9mKG1vZHVsZV9vcl9wYXRoKSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgKHttb2R1bGVfb3JfcGF0aH0gPSBtb2R1bGVfb3JfcGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigndXNpbmcgZGVwcmVjYXRlZCBwYXJhbWV0ZXJzIGZvciB0aGUgaW5pdGlhbGl6YXRpb24gZnVuY3Rpb247IHBhc3MgYSBzaW5nbGUgb2JqZWN0IGluc3RlYWQnKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBtb2R1bGVfb3JfcGF0aCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbW9kdWxlX29yX3BhdGggPSBuZXcgVVJMKCdvbmxpbmVfc3ludGF4X2ZmaV9iZy53YXNtJywgaW1wb3J0Lm1ldGEudXJsKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG1vZHVsZV9vcl9wYXRoID09PSAnc3RyaW5nJyB8fCAodHlwZW9mIFJlcXVlc3QgPT09ICdmdW5jdGlvbicgJiYgbW9kdWxlX29yX3BhdGggaW5zdGFuY2VvZiBSZXF1ZXN0KSB8fCAodHlwZW9mIFVSTCA9PT0gJ2Z1bmN0aW9uJyAmJiBtb2R1bGVfb3JfcGF0aCBpbnN0YW5jZW9mIFVSTCkpIHtcbiAgICAgICAgbW9kdWxlX29yX3BhdGggPSBmZXRjaChtb2R1bGVfb3JfcGF0aCk7XG4gICAgfVxuXG4gICAgX193YmdfaW5pdF9tZW1vcnkoaW1wb3J0cyk7XG5cbiAgICBjb25zdCB7IGluc3RhbmNlLCBtb2R1bGUgfSA9IGF3YWl0IF9fd2JnX2xvYWQoYXdhaXQgbW9kdWxlX29yX3BhdGgsIGltcG9ydHMpO1xuXG4gICAgcmV0dXJuIF9fd2JnX2ZpbmFsaXplX2luaXQoaW5zdGFuY2UsIG1vZHVsZSk7XG59XG5cbmV4cG9ydCB7IGluaXRTeW5jIH07XG5leHBvcnQgZGVmYXVsdCBfX3diZ19pbml0O1xuIiwiaW1wb3J0IHtHcmFwaHZpen0gZnJvbSBcIkBocGNjLWpzL3dhc21cIjtcbmltcG9ydCB7Q29uY3JldGVHcmFwaCwgQ29udGV4dH0gZnJvbSBcIm9ubGluZS1zeW50YXgtanNcIjtcbi8vIGltcG9ydCAqIGFzIG1vbmFjbyBmcm9tICdtb25hY28tZWRpdG9yJztcbi8vIGltcG9ydCB0aGlzIHRvIG9ubHkgaW1wb3J0IHRoZSBmZWF0dXJlcyB3ZSByZXF1ZXN0ZWQgZnJvbSB3ZWJwYWNrLmNvbmZpZy5qczpcbmltcG9ydCAqIGFzIG1vbmFjbyBmcm9tICdtb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvZWRpdG9yLmFwaSc7XG4vLyBpbXBvcnQgJ21vbmFjby1lZGl0b3IvZXNtL3ZzL2Jhc2ljLWxhbmd1YWdlcy9ydXN0L3J1c3QuY29udHJpYnV0aW9uJztcbmltcG9ydCB7IEFuc2lVcCB9IGZyb20gJ2Fuc2lfdXAnO1xuaW1wb3J0ICogYXMgZDMgZnJvbSAnZDMnO1xuaW1wb3J0IHtkM0dyYXBodml6fSBmcm9tICdkMy1ncmFwaHZpeidcblxuLy8gLS0tIEluaXRpYWxpemF0aW9uIC0tLVxuY29uc3QgYW5zaV91cCA9IG5ldyBBbnNpVXAoKTtcbmxldCBncmFwaHZpejtcbmxldCBjdXJyZW50X3JlczsgLy8gVG8gc3RvcmUgdGhlIHJlc3VsdCBvZiBhIHN1Y2Nlc3NmdWwgY29tcGlsYXRpb25cblxuLy8gLS0tIERPTSBFbGVtZW50IFJlZmVyZW5jZXMgLS0tXG5jb25zdCBvdXRwdXRQcmUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnb3V0cHV0Jyk7XG5jb25zdCBzdmdDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ZnLWNvbnRhaW5lcicpO1xuY29uc3Qgc3RhdGVTZWxlY3RvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGF0ZS1zZWxlY3RvcicpO1xuXG4vLyAtLS0gTW9uYWNvIEVkaXRvciBTZXR1cCAtLS1cbmNvbnN0IGluaXRpYWxDb2RlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ2xhc3RfY29kZScpIHx8XG4gICAgYC8vIFdlbGNvbWUhIFR5cGUgeW91ciBHcmFiYXBsIGNvZGUgaGVyZS5cbi8vIFlvdSBjYW4gZmluZCBhIHNhbXBsZSBidWJibGUgc29ydCBpbXBsZW1lbnRhdGlvbiB0byBjb3B5IHBhc3RlIGhlcmU6IGh0dHBzOi8vY3JhdGVzLmlvL2NyYXRlcy9ncmFiYXBsXG5mbiBmb28oeDogaW50KSAtPiAocmVzdWx0OiBpbnQpIHtcbiAgICBzaG93X3N0YXRlKGluaXRpYWxfc3RhdGUpO1xuICAgIC8vIHRyeSByZXR1cm5pbmcgYSBub2RlIVxuICAgIC8vIGxldCEgbmV3X25vZGUgPSBhZGRfbm9kZTwxPigpO1xuICAgIC8vIHNob3dfc3RhdGUoYWZ0ZXJfYWRkaW5nX25vZGVfc3RhdGUpO1xuICAgIC8vIHJldHVybiAocmVzdWx0OiBuZXdfbm9kZSk7XG59YDtcbi8vIFRPRE86IGFkZCBkcm9wIGRvd24gd2l0aCBleGFtcGxlIGNvZGUgc25pcHBldHNcblxuY29uc3QgZWRpdG9yID0gbW9uYWNvLmVkaXRvci5jcmVhdGUoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpLCB7XG4gICAgdmFsdWU6IGluaXRpYWxDb2RlLFxuICAgIGxhbmd1YWdlOiAncnVzdCcsXG4gICAgdGhlbWU6ICd2cy1saWdodCcsXG4gICAgYXV0b21hdGljTGF5b3V0OiB0cnVlLCAvLyBFbnN1cmVzIHRoZSBlZGl0b3IgcmVzaXplcyByZXNwb25zaXZlbHlcbiAgICBtaW5pbWFwOiB7IGVuYWJsZWQ6IGZhbHNlIH0sXG4gICAgcm91bmRlZFNlbGVjdGlvbjogdHJ1ZSxcbiAgICBzY3JvbGxCZXlvbmRMYXN0TGluZTogdHJ1ZSxcbn0pO1xud2luZG93LmVkaXRvciA9IGVkaXRvcjsgLy8gRXhwb3NlIGVkaXRvciBmb3IgcmVzaXplciBzY3JpcHRcblxubGV0IGVkaXRvckRlY29yYXRpb25zID0gZWRpdG9yLmNyZWF0ZURlY29yYXRpb25zQ29sbGVjdGlvbigpO1xuXG4vLyAtLS0gVGhlbWUgVG9nZ2xlIExvZ2ljIC0tLVxuY29uc3QgdGhlbWVUb2dnbGVCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndGhlbWUtdG9nZ2xlJyk7XG5jb25zdCB0aGVtZVRvZ2dsZURhcmtJY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RoZW1lLXRvZ2dsZS1kYXJrLWljb24nKTtcbmNvbnN0IHRoZW1lVG9nZ2xlTGlnaHRJY29uID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RoZW1lLXRvZ2dsZS1saWdodC1pY29uJyk7XG5jb25zdCBkb2NFbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4vKipcbiAqIFNldHMgdGhlIGFwcGxpY2F0aW9uIHRoZW1lIChsaWdodC9kYXJrKSBhbmQgdXBkYXRlcyB0aGUgVUkgYWNjb3JkaW5nbHkuXG4gKiBAcGFyYW0geydsaWdodCcgfCAnZGFyayd9IHRoZW1lIFRoZSB0aGVtZSB0byBzZXQuXG4gKi9cbmNvbnN0IHNldFRoZW1lID0gKHRoZW1lKSA9PiB7XG4gICAgaWYgKHRoZW1lID09PSAnZGFyaycpIHtcbiAgICAgICAgZG9jRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdkYXJrJyk7XG4gICAgICAgIHRoZW1lVG9nZ2xlTGlnaHRJY29uLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICB0aGVtZVRvZ2dsZURhcmtJY29uLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICBtb25hY28uZWRpdG9yLnNldFRoZW1lKCd2cy1kYXJrJyk7XG4gICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCd0aGVtZScsICdkYXJrJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZG9jRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKCdkYXJrJyk7XG4gICAgICAgIHRoZW1lVG9nZ2xlTGlnaHRJY29uLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICB0aGVtZVRvZ2dsZURhcmtJY29uLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuICAgICAgICBtb25hY28uZWRpdG9yLnNldFRoZW1lKCd2cy1saWdodCcpOyAvLyBVc2UgdGhlIGxpZ2h0IHRoZW1lIGZvciBNb25hY29cbiAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ3RoZW1lJywgJ2xpZ2h0Jyk7XG4gICAgfVxuICAgIC8vIFJlLXJlbmRlciBncmFwaHMgd2l0aCB0aGUgbmV3IHRoZW1lXG4gICAgaWYgKGN1cnJlbnRfcmVzICYmIHN0YXRlU2VsZWN0b3IudmFsdWUpIHtcbiAgICAgICAgY29uc3QgZG90ID0gY3VycmVudF9yZXMuZG90T2ZTdGF0ZShzdGF0ZVNlbGVjdG9yLnZhbHVlKTtcbiAgICAgICAgcmVuZGVyR3JhcGgoZG90KTtcbiAgICB9XG4gICAgdXBkYXRlVGhlbWVGb3JHcmFwaCgpO1xufTtcblxuLy8gLS0tIENvcmUgRnVuY3Rpb25zIC0tLVxuXG4vKipcbiAqIFJlbmRlcnMgYSBET1Qgc3RyaW5nIGludG8gYW4gU1ZHIGFuZCBkaXNwbGF5cyBpdCBpbiB0aGUgcHJldmlldyBjb250YWluZXIuXG4gKiBAcGFyYW0ge3N0cmluZ30gZG90U3RyaW5nIFRoZSBET1QgZ3JhcGggbm90YXRpb24gc3RyaW5nLlxuICovXG5mdW5jdGlvbiByZW5kZXJHcmFwaChkb3RTdHJpbmcpIHtcbiAgICBpZiAoIWdyYXBodml6IHx8ICFkb3RTdHJpbmcpIHtcbiAgICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IGA8cCBjbGFzcz1cInRleHQtZ3JheS01MDBcIj5Db3VsZCBub3QgZ2VuZXJhdGUgZ3JhcGguPC9wPmA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbGV0IHN2ZyA9IGdyYXBodml6LmRvdChkb3RTdHJpbmcpO1xuICAgICAgICAvLyByZXBsYWNlIGZpbGw9XCJ3aGl0ZVwiIHdpdGggZmlsbD1cIm5vbmVcIiB0byBhdm9pZCB3aGl0ZSBiYWNrZ3JvdW5kXG4gICAgICAgIHN2ZyA9IHN2Zy5yZXBsYWNlKC9maWxsPVwid2hpdGVcIi9nLCAnZmlsbD1cIm5vbmVcIicpO1xuICAgICAgICBzdmcgPSBzdmcucmVwbGFjZSgvPHRleHQgL2csICc8dGV4dCBmaWxsPVwid2hpdGVcIiAnKTtcbiAgICAgICAgLy8gaWYgdGhlbWUgaXMgZGFyaywgc2V0ICdzdHJva2U9XCJibGFja1wiJyB0byAnc3Ryb2tlPVwid2hpdGVcIidcbiAgICAgICAgaWYgKGRvY0VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkYXJrJykpIHtcbiAgICAgICAgICAgIHN2ZyA9IHN2Zy5yZXBsYWNlKC9zdHJva2U9XCJibGFja1wiL2csICdzdHJva2U9XCJ3aGl0ZVwiJyk7XG4gICAgICAgICAgICBzdmcgPSBzdmcucmVwbGFjZSgvPHRleHQgZmlsbD1cImJsYWNrXCIvZywgJzx0ZXh0IGZpbGw9XCJ3aGl0ZVwiJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdmcgPSBzdmcucmVwbGFjZSgvc3Ryb2tlPVwid2hpdGVcIi9nLCAnc3Ryb2tlPVwiYmxhY2tcIicpO1xuICAgICAgICAgICAgc3ZnID0gc3ZnLnJlcGxhY2UoLzx0ZXh0IGZpbGw9XCJ3aGl0ZVwiL2csICc8dGV4dCBmaWxsPVwiYmxhY2tcIicpO1xuICAgICAgICB9XG4gICAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBzdmc7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkdyYXBodml6IHJlbmRlcmluZyBlcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICBzdmdDb250YWluZXIuaW5uZXJIVE1MID0gYDxwIGNsYXNzPVwidGV4dC1yZWQtNTAwXCI+RXJyb3IgcmVuZGVyaW5nIGdyYXBoLiBDaGVjayBjb25zb2xlIGZvciBkZXRhaWxzLjwvcD5gO1xuICAgIH1cbn1cblxuLyoqXG4gKiBQb3B1bGF0ZXMgdGhlIHN0YXRlIHNlbGVjdG9yIGRyb3Bkb3duIHdpdGggbmFtZXMgZnJvbSB0aGUgY29tcGlsYXRpb24gcmVzdWx0LlxuICogQHBhcmFtIHthbnl9IHJlcyBUaGUgc3VjY2Vzc2Z1bCBjb21waWxhdGlvbiByZXN1bHQgZnJvbSBDb250ZXh0LnBhcnNlLlxuICovXG5mdW5jdGlvbiBwb3B1bGF0ZVN0YXRlU2VsZWN0b3IocmVzKSB7XG4gICAgc3RhdGVTZWxlY3Rvci5pbm5lckhUTUwgPSAnJzsgLy8gQ2xlYXIgcHJldmlvdXMgb3B0aW9uc1xuXG4gICAgY29uc3Qgc3RhdGVOYW1lcyA9IFsuLi5yZXMubGlzdFN0YXRlcygpXS5tYXAoc3RhdGUgPT4gc3RhdGUudG9TdHJpbmcoKSk7XG5cbiAgICBpZiAoc3RhdGVOYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gbmV3IE9wdGlvbignTm8gc3RhdGVzIGZvdW5kIGluIGNvZGUnLCAnJyk7XG4gICAgICAgIG9wdGlvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHN0YXRlU2VsZWN0b3IuYWRkKG9wdGlvbik7XG4gICAgICAgIHN2Z0NvbnRhaW5lci5pbm5lckhUTUwgPSBgPHAgY2xhc3M9XCJ0ZXh0LWdyYXktNTAwXCI+Tm8gc3RhdGVzIHdlcmUgZm91bmQgdG8gdmlzdWFsaXplLjwvcD5gO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGVOYW1lcy5mb3JFYWNoKG5hbWUgPT4gc3RhdGVTZWxlY3Rvci5hZGQobmV3IE9wdGlvbihuYW1lLCBuYW1lKSkpO1xuXG4gICAgLy8gQXV0b21hdGljYWxseSByZW5kZXIgdGhlIGdyYXBoIGZvciB0aGUgZmlyc3Qgc3RhdGVcbiAgICBpZiAoc3RhdGVOYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGRvdCA9IHJlcy5kb3RPZlN0YXRlKHN0YXRlTmFtZXNbMF0pO1xuICAgICAgICByZW5kZXJHcmFwaChkb3QpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGlnaGxpZ2h0RXJyb3IobGluZSwgY29sdW1uKSB7XG5cbiAgICAvLyBIaWdobGlnaHQgdGhlIGVycm9yIGluIHRoZSBlZGl0b3JcbiAgICBlZGl0b3IucmV2ZWFsTGluZUluQ2VudGVyKGxpbmUpO1xuICAgIGVkaXRvci5mb2N1cygpO1xuICAgIGVkaXRvci5zZXRQb3NpdGlvbih7IGxpbmVOdW1iZXI6IGxpbmUsIGNvbHVtbjogY29sdW1uIH0pO1xuXG4gICAgLy8gc2hvdyBkZWNvcmF0aW9uXG59XG5cbmxldCBNU19CRVRXRUVOX0NPREVfQ0hBTkdFUyA9IDIwMDsgLy8gVGhyb3R0bGUgY29kZSBjaGFuZ2UgZXZlbnRzIHRvIGF2b2lkIGV4Y2Vzc2l2ZSBwYXJzaW5nXG5cbi8qKlxuICogV3JhcHBlciBhcm91bmQgb25Db2RlQ2hhbmdlZElubmVyIHRvIHRocm90dGxlIGNhbGxzLlxuICovXG5mdW5jdGlvbiBvbkNvZGVDaGFuZ2VkKCkge1xuICAgIGlmIChvbkNvZGVDaGFuZ2VkLnRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KG9uQ29kZUNoYW5nZWQudGltZW91dCk7XG4gICAgfVxuICAgIG9uQ29kZUNoYW5nZWQudGltZW91dCA9IHNldFRpbWVvdXQob25Db2RlQ2hhbmdlZElubmVyLCBNU19CRVRXRUVOX0NPREVfQ0hBTkdFUyk7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgdGhlIGNvbnRlbnQgaW4gdGhlIE1vbmFjbyBlZGl0b3IgY2hhbmdlcy5cbiAqIEl0IGF0dGVtcHRzIHRvIGNvbXBpbGUgdGhlIGNvZGUgYW5kIHVwZGF0ZXMgdGhlIFVJIGFjY29yZGluZ2x5LlxuICovXG5mdW5jdGlvbiBvbkNvZGVDaGFuZ2VkSW5uZXIoKSB7XG4gICAgY29uc3QgY3VycmVudF9jb250ZW50ID0gZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2xhc3RfY29kZScsIGN1cnJlbnRfY29udGVudCk7XG5cbiAgICB0cnkge1xuICAgICAgICAvLyBBdHRlbXB0IHRvIHBhcnNlL2NvbXBpbGUgdGhlIGNvZGVcbiAgICAgICAgY29uc3QgcmVzID0gQ29udGV4dC5wYXJzZShjdXJyZW50X2NvbnRlbnQpO1xuICAgICAgICBjdXJyZW50X3JlcyA9IHJlcztcblxuICAgICAgICAvLyByZXNldCB0aGUgZXJyb3Igb24gdGhlIGVkaXRvclxuICAgICAgICBlZGl0b3JEZWNvcmF0aW9ucy5jbGVhcigpXG4gICAgICAgIC8vIG5vdyBjaGVjayBpZiBpdCB3YXMgcGFyc2VkIHN1Y2Nlc3NmdWxseVxuICAgICAgICBsZXQgZXJyb3JfbXNnX3JhdyA9IHJlcy5lcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgaWYgKGVycm9yX21zZ19yYXcgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBVSSBmb3Igc3VjY2Vzc1xuICAgICAgICAgICAgb3V0cHV0UHJlLmNsYXNzTmFtZSA9IFwidy1mdWxsIHAtNCBvdmVyZmxvdy1hdXRvIHdoaXRlc3BhY2UtcHJlLXdyYXAgdGV4dC1ncmVlbi00MDBcIjtcbiAgICAgICAgICAgIG91dHB1dFByZS5pbm5lclRleHQgPSBcIkNvZGUgY29tcGlsZWQgc3VjY2Vzc2Z1bGx5IVwiO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZXJyb3JcbiAgICAgICAgICAgIG91dHB1dFByZS5jbGFzc05hbWUgPSBcInctZnVsbCBwLTQgb3ZlcmZsb3ctYXV0byB3aGl0ZXNwYWNlLXByZS13cmFwIHRleHQtcmVkLTQwMFwiO1xuXG4gICAgICAgICAgICBsZXQgZXJyb3JfbXNnID0gYW5zaV91cC5hbnNpX3RvX2h0bWwoZXJyb3JfbXNnX3Jhdyk7XG5cbiAgICAgICAgICAgIC8vIHJhdyBlcnJvcl9tc2cgdGV4dDpcbiAgICAgICAgICAgIC8vIGNvbnN0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIC8vIHRlbXBEaXYuaW5uZXJIVE1MID0gZXJyb3JfbXNnO1xuICAgICAgICAgICAgLy8gbGV0IGVycm9yX21zZ190ZXh0X2Zvcm0gPSB0ZW1wRGl2LmlubmVyVGV4dDsgLy8gR2V0IHRoZSByYXcgdGV4dCB3aXRob3V0IEhUTUwgdGFnc1xuICAgICAgICAgICAgLy8gLy8gZGVsZXRlXG4gICAgICAgICAgICAvLyB0ZW1wRGl2LnJlbW92ZSgpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIGxldCBsaW5lX2FyciA9IGVycm9yX21zZ190ZXh0X2Zvcm0uc3BsaXQoXCJcXG5cIikubWFwKChsaW5lKSA9PiB7cmV0dXJuIHt2YWx1ZTogbGluZX19KTtcblxuXG4gICAgICAgICAgICAvLyBmb3IgZXZlcnkgYWN0dWFsIHNwYW4gcmV0dXJuZWQgaW4gdGhlIGVycm9yLCBhZGQgYSBkZWNvcmF0aW9uXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNwYW4gb2YgcmVzLmVycm9yU3BhbnMoKSkge1xuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiSGlnaGxpZ2h0aW5nIGVycm9yIHNwYW46XCIsIHNwYW4pO1xuICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIHJhbmdlIGZvciB0aGUgZGVjb3JhdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbmV3IG1vbmFjby5SYW5nZShzcGFuLmxpbmVTdGFydCwgc3Bhbi5jb2xTdGFydCwgc3Bhbi5saW5lRW5kLCBzcGFuLmNvbEVuZCk7XG4gICAgICAgICAgICAgICAgZWRpdG9yRGVjb3JhdGlvbnMuYXBwZW5kKFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2Vycm9yLWhpZ2hsaWdodCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNXaG9sZUxpbmU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvdmVyTWVzc2FnZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCJlcnJvciBoZXJlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3b3VsZCBiZSBjb29sIGlmIGV2ZXJ5IGVycm9yU3BhbiBoYWQgd2FzIG1vcmUgJ3JpY2gnIGluIHRoZSBzZW5zZSB0aGF0IGl0IGFsc28gY29udGFpbmVkIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgc3BlY2lmaWMgbWVzc2FnZSB0byBzaG93LiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBnbHlwaE1hcmdpbkhvdmVyTWVzc2FnZTogXCJnbHlwaCBoYWhhXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gZmluZCB0aGUgcG9ydGlvbiBvZiB0aGUgZXJyb3IgbWVzc2FnZSB0aGF0IGNvbnRhaW5zIHRoZSBlcnJvciwgaXQncyBvZiB0aGUgZm9ybSBpbnB1dDpsaW5lOmNvbHVtblxuICAgICAgICAgICAgb3V0cHV0UHJlLmlubmVySFRNTCA9IGVycm9yX21zZztcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWF0Y2hlcyA9IGVycm9yX21zZy5tYXRjaEFsbCgvaW5wdXQ6KFxcZCspOihcXGQrKS9nKTtcbiAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgIGNvbnN0IGFkZGVkX2lkc19hbmRfc3BhbnMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZXJyb3JNYXRjaCBvZiBlcnJvck1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBsaW5rIHRvIHRoZSBlZGl0b3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lID0gcGFyc2VJbnQoZXJyb3JNYXRjaFsxXSwgMTApO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IHBhcnNlSW50KGVycm9yTWF0Y2hbMl0sIDEwKTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiUmVwbGFjaW5nIGZvciBtYXRjaDogXCIsIGVycm9yTWF0Y2hbMF0sIFwiYXQgbGluZTpcIiwgbGluZSwgXCJjb2x1bW46XCIsIGNvbHVtbik7XG5cbiAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRoZSBtYXRjaCBpbiB0aGUgZXJyb3JfbXNnIHRvIGJlIGEgbGluayB0aGF0IGludm9rZXMgdGhlIGZvbGxvd2luZyBmdW5jdGlvbiBvbiBjbGljazpcbiAgICAgICAgICAgICAgICBvdXRwdXRQcmUuaW5uZXJIVE1MID0gb3V0cHV0UHJlLmlubmVySFRNTC5yZXBsYWNlKGVycm9yTWF0Y2hbMF0sIGA8YSBocmVmPVwiI1wiIGlkPVwiZXJyb3Itc3Bhbi1saW5rLSR7aX1cIiBjbGFzcz1cInRleHQtcmVkLTQwMCB1bmRlcmxpbmVcIj5pbnB1dDoke2xpbmV9OiR7Y29sdW1ufTwvYT5gKTtcbiAgICAgICAgICAgICAgICBhZGRlZF9pZHNfYW5kX3NwYW5zLnB1c2goeyBpZDogYGVycm9yLXNwYW4tbGluay0ke2l9YCwgbGluZTogbGluZSwgY29sdW1uOiBjb2x1bW4gfSk7XG4gICAgICAgICAgICAgICAgaSA9IGkgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbm93IGF0dGFjaCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWRfYW5kX3NwYW4gb2YgYWRkZWRfaWRzX2FuZF9zcGFucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBpZF9hbmRfc3Bhbi5saW5lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbiA9IGlkX2FuZF9zcGFuLmNvbHVtbjtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgQXR0YWNoaW5nIGNsaWNrIGhhbmRsZXIgZm9yIGVycm9yIGF0IGxpbmUgJHtsaW5lfSwgY29sdW1uICR7Y29sdW1ufWApO1xuICAgICAgICAgICAgICAgIC8vIGZpbmQgYW5kIGF0dGFjaCBhIGNsaWNrIGhhbmRsZXIgdG8gdGhlIGVycm9yIHNwYW5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclNwYW5MaW5rID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWRfYW5kX3NwYW4uaWQpO1xuICAgICAgICAgICAgICAgIGkgPSBpICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JTcGFuTGluaykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgSUYgbGluZSAke2xpbmV9LCBjb2x1bW4gJHtjb2x1bW59YCk7XG5cbiAgICAgICAgICAgICAgICAgICAgZXJyb3JTcGFuTGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgSGlnaGxpZ2h0aW5nIGVycm9yIGF0IGxpbmUgJHtsaW5lfSwgY29sdW1uICR7Y29sdW1ufWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0RXJyb3IobGluZSwgY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuXG4gICAgICAgIC8vIFBvcHVsYXRlIHRoZSBkcm9wZG93biB3aXRoIGRpc2NvdmVyZWQgc3RhdGVzXG4gICAgICAgIHBvcHVsYXRlU3RhdGVTZWxlY3RvcihyZXMpO1xuICAgICAgICBwb3B1bGF0ZU9wZXJhdGlvblNlbGVjdG9yKHJlcyk7IC8vIPCfmoBcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGN1cnJlbnRfcmVzID0gbnVsbDsgLy8gSW52YWxpZGF0ZSBvbGQgcmVzdWx0cyBvbiBjcmFzaFxuXG4gICAgICAgIC8vIFVwZGF0ZSBVSSBmb3IgZXJyb3JcbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZS5jYXVzZSA/IGUuY2F1c2UudG9TdHJpbmcoKSA6IGUudG9TdHJpbmcoKTtcbiAgICAgICAgb3V0cHV0UHJlLmNsYXNzTmFtZSA9IFwidy1mdWxsIHAtNCBvdmVyZmxvdy1hdXRvIHdoaXRlc3BhY2UtcHJlLXdyYXAgZm9udC1tb25vIHRleHQtc20gdGV4dC1yZWQtNDAwXCI7XG4gICAgICAgIG91dHB1dFByZS5pbm5lckhUTUwgPSBhbnNpX3VwLmFuc2lfdG9faHRtbChlcnJvck1lc3NhZ2UpO1xuXG4gICAgICAgIC8vIENsZWFyIHRoZSBzdGF0ZSBzZWxlY3RvciBhbmQgU1ZHIHByZXZpZXdcbiAgICAgICAgc3RhdGVTZWxlY3Rvci5pbm5lckhUTUwgPSAnPG9wdGlvbiB2YWx1ZT1cIlwiPkZpeCBjb2RlIGVycm9ycyB0byBzZWUgc3RhdGVzPC9vcHRpb24+JztcbiAgICAgICAgc3ZnQ29udGFpbmVyLmlubmVySFRNTCA9IGA8cCBjbGFzcz1cInRleHQtZ3JheS01MDBcIj5Zb3VyIHN0YXRlIGdyYXBoIHdpbGwgYXBwZWFyIGhlcmUuPC9wPmA7XG4gICAgICAgIG9wZXJhdGlvblNlbGVjdG9yLmlubmVySFRNTCA9ICc8b3B0aW9uIHZhbHVlPVwiXCI+Rml4IGNvZGUgZXJyb3JzIHRvIHNlZSBvcGVyYXRpb25zPC9vcHRpb24+JzsgLy8g8J+agFxuICAgIH1cbn1cblxuLy8gLS0tIEV2ZW50IExpc3RlbmVycyAtLS1cblxuLy8gTGlzdGVuIGZvciBjaGFuZ2VzIGluIHRoZSBlZGl0b3IgbW9kZWxcbmVkaXRvci5vbkRpZENoYW5nZU1vZGVsQ29udGVudCgoKSA9PiB7XG4gICAgb25Db2RlQ2hhbmdlZCgpO1xufSk7XG5cbi8vIExpc3RlbiBmb3IgY2hhbmdlcyBpbiB0aGUgc3RhdGUgc2VsZWN0b3IgZHJvcGRvd25cbnN0YXRlU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKGUpID0+IHtcbiAgICBpZiAoY3VycmVudF9yZXMgJiYgZS50YXJnZXQudmFsdWUpIHtcbiAgICAgICAgcmVuZGVyR3JhcGgoY3VycmVudF9yZXMuZG90T2ZTdGF0ZShlLnRhcmdldC52YWx1ZSkpO1xuICAgIH1cbn0pO1xudGhlbWVUb2dnbGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3QgbmV3VGhlbWUgPSBkb2NFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGFyaycpID8gJ2xpZ2h0JyA6ICdkYXJrJztcbiAgICBzZXRUaGVtZShuZXdUaGVtZSk7XG59KTtcblxuLy8g8J+agCAtLS0gRFlOQU1JQyBHUkFQSCBCVUlMREVSIC0tLSDwn5qAIC8vXG5cbi8vIC0tLSBTdGF0ZSBhbmQgVmFyaWFibGVzIC0tLVxubGV0IGludGVyYWN0aXZlTm9kZXMgPSBbXTtcbmxldCBpbnRlcmFjdGl2ZUVkZ2VzID0gW107XG5sZXQgY29uY3JldGVHcmFwaCA9IENvbmNyZXRlR3JhcGgubmV3XygpXG5sZXQgc2ltdWxhdGlvbiwgc3ZnLCBzdmdSb290LCBncmlkRywgem9vbWFibGVDb250YWluZXI7XG5sZXQgc2VsZWN0ZWRTb3VyY2VOb2RlID0gbnVsbDtcbmxldCBjdXJyZW50VHJhbnNmb3JtID0gZDMuem9vbUlkZW50aXR5O1xubGV0IHRlbXBOb2RlQ29vcmRzID0geyB4OiAwLCB5OiAwIH07XG5sZXQgcGVuZGluZ0VkZ2UgPSBudWxsO1xubGV0IGN1cnJlbnRUcmFjZURvdHMgPSBbXTtcbmxldCByYXdDdXJyZW50VHJhY2VEb3RzID0gW107XG5sZXQgY3VycmVudFRyYWNlSW5kZXggPSAwO1xubGV0IHRyYWNlR3JhcGh2aXo7XG5cbi8vIC0tLSBET00gUmVmZXJlbmNlcyAtLS1cbmNvbnN0IG9wZXJhdGlvblNlbGVjdG9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29wZXJhdGlvbi1zZWxlY3RvcicpO1xuY29uc3Qgb3BlcmF0aW9uSW5wdXRzQ29udGFpbmVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ29wZXJhdGlvbi1pbnB1dHMnKTtcbmNvbnN0IGFkZE5vZGVJbnB1dEJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhZGQtbm9kZS1pbnB1dC1idG4nKTtcbmNvbnN0IHJ1bk9wZXJhdGlvbkJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdydW4tb3BlcmF0aW9uLWJ0bicpO1xuY29uc3QgaW50ZXJhY3RpdmVHcmFwaENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdpbnRlcmFjdGl2ZS1ncmFwaC1jb250YWluZXInKTtcbmNvbnN0IG5vZGVNb2RhbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub2RlLW1vZGFsJyk7XG5jb25zdCBub2RlRm9ybSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdub2RlLWZvcm0nKTtcbmNvbnN0IGNhbmNlbE5vZGVCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FuY2VsLW5vZGUtYnRuJyk7XG5jb25zdCBub2RlTmFtZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vZGUtbmFtZScpO1xuY29uc3Qgbm9kZVZhbHVlSW5wdXQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbm9kZS12YWx1ZScpO1xuY29uc3QgZWRnZU1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkZ2UtbW9kYWwnKTtcbmNvbnN0IGVkZ2VGb3JtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkZ2UtZm9ybScpO1xuY29uc3QgY2FuY2VsRWRnZUJ0biA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYW5jZWwtZWRnZS1idG4nKTtcbmNvbnN0IGVkZ2VWYWx1ZUlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2VkZ2UtdmFsdWUnKTtcbmVkZ2VWYWx1ZUlucHV0LnJlcXVpcmVkID0gZmFsc2U7XG5cbmNvbnN0IHRyYWNlQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RyYWNlLWJveCcpO1xuY29uc3QgcHJldlRyYWNlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ByZXYtdHJhY2UtYnRuJyk7XG5jb25zdCBuZXh0VHJhY2VCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbmV4dC10cmFjZS1idG4nKTtcbmNvbnN0IHRyYWNlU3RlcEluZGljYXRvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFjZS1zdGVwLWluZGljYXRvcicpO1xuY29uc3QgdHJhY2VHcmFwaENvbnRhaW5lciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0cmFjZS1ncmFwaC1jb250YWluZXInKTtcbmxldCBpc1RyYWNlUmVuZGVyaW5nID0gZmFsc2U7XG5cbmNvbnN0IHJ1blNpbXVsYXRpb25CdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncnVuLXNpbXVsYXRpb24tYnRuJyk7XG5cbi8vIC0tLSBEZWxldGUgTm9kZSBFbGVtZW50cyBhbmQgTG9naWMgLS0tXG5jb25zdCBkZWxldGVOb2RlQnRuID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlbGV0ZS1ub2RlLWJ0bicpO1xuY29uc3QgZGVsZXRlQ29uZmlybU1vZGFsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlbGV0ZS1jb25maXJtLW1vZGFsJyk7XG5jb25zdCBjYW5jZWxEZWxldGVCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FuY2VsLWRlbGV0ZS1idG4nKTtcbmNvbnN0IGNvbmZpcm1EZWxldGVCdG4gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29uZmlybS1kZWxldGUtYnRuJyk7XG5cblxuLy8gLS0tIGF1dG8gY29tcGlsZSBpbnB1dCBhbmQgbG9naWNcblxuY29uc3QgYXV0b0NvbXBpbGVJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdhdXRvLWNvbXBpbGUtdGltZW91dCcpO1xuYXV0b0NvbXBpbGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgIGNvbnN0IG5ld1ZhbHVlID0gcGFyc2VJbnQoZS50YXJnZXQudmFsdWUsIDEwKTtcbiAgICBpZiAoaXNOYU4obmV3VmFsdWUpIHx8IG5ld1ZhbHVlIDwgMCkge1xuICAgICAgICBhbGVydChcIlBsZWFzZSBlbnRlciBhIHZhbGlkIHBvc2l0aXZlIG51bWJlciBmb3IgYXV0by1jb21waWxlIHRpbWVvdXQuXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIE1TX0JFVFdFRU5fQ09ERV9DSEFOR0VTID0gbmV3VmFsdWU7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dG9fY29tcGlsZV90aW1lb3V0JywgbmV3VmFsdWUpO1xufSk7XG5cbi8vIC0tLSBza2lwIGR1cGxpY2F0ZSB0cmFjZXMgaW5wdXRcbmNvbnN0IHNraXBEdXBsaWNhdGVUcmFjZXNJbnB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdza2lwLWR1cGxpY2F0ZS10cmFjZXMnKTtcbi8vIGl0J3MgYSBjaGVjayBidXR0b25cbnNraXBEdXBsaWNhdGVUcmFjZXNJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgIGNvbnN0IHNraXBEdXBsaWNhdGVzID0gZS50YXJnZXQuY2hlY2tlZDtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc2tpcF9kdXBsaWNhdGVfdHJhY2VzJywgc2tpcER1cGxpY2F0ZXMpO1xuICAgIC8vIGNoYW5nZSB0aGUgbGFiZWwgdGV4dCBhY2NvcmRpbmdseVxuICAgIGlmIChza2lwRHVwbGljYXRlcykge1xuICAgICAgICBjdXJyZW50VHJhY2VEb3RzID0gcmF3Q3VycmVudFRyYWNlRG90cy5maWx0ZXIoKGRvdCwgaW5kZXgsIGFycikgPT4gaW5kZXggPT09IDAgfHwgZG90ICE9PSBhcnJbaW5kZXggLSAxXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFRyYWNlRG90cyA9IHJhd0N1cnJlbnRUcmFjZURvdHM7IC8vIFJlc2V0IHRvIHJhdyBpZiB1bmNoZWNrZWRcbiAgICB9XG4gICAgY3VycmVudFRyYWNlSW5kZXggPSBNYXRoLm1pbihjdXJyZW50VHJhY2VJbmRleCwgY3VycmVudFRyYWNlRG90cy5sZW5ndGggLSAxKTsgLy8gZG9udCBnbyBvdXQgb2YgYm91bmRzXG4gICAgLy8gcmVuZGVyIHRoZSB0cmFjZSBncmFwaCBhZ2FpblxuICAgIHJlbmRlclRyYWNlR3JhcGgoKTtcbn0pO1xuXG4vKipcbiAqIERlbGV0ZXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIGFuZCBpdHMgY29ubmVjdGVkIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBkZWxldGVTZWxlY3RlZE5vZGUoKSB7XG4gICAgaWYgKCFzZWxlY3RlZFNvdXJjZU5vZGUpIHJldHVybjtcblxuICAgIC8vIFJlbW92ZSBmcm9tIHRoZSB1bmRlcmx5aW5nIGdyYXBoIHJlcHJlc2VudGF0aW9uXG4gICAgY29uY3JldGVHcmFwaC5kZWxldGVOb2RlKHNlbGVjdGVkU291cmNlTm9kZS5ub2RlS2V5KTtcblxuICAgIC8vIEZpbHRlciBvdXQgdGhlIG5vZGUgYW5kIGl0cyBlZGdlcyBmcm9tIHRoZSBEMyBkYXRhIGFycmF5c1xuICAgIGludGVyYWN0aXZlTm9kZXMgPSBpbnRlcmFjdGl2ZU5vZGVzLmZpbHRlcihuID0+IG4uaWQgIT09IHNlbGVjdGVkU291cmNlTm9kZS5pZCk7XG4gICAgaW50ZXJhY3RpdmVFZGdlcyA9IGludGVyYWN0aXZlRWRnZXMuZmlsdGVyKGUgPT4gZS5zb3VyY2UuaWQgIT09IHNlbGVjdGVkU291cmNlTm9kZS5pZCAmJiBlLnRhcmdldC5pZCAhPT0gc2VsZWN0ZWRTb3VyY2VOb2RlLmlkKTtcblxuICAgIC8vIFJlc2V0IHNlbGVjdGlvbiBzdGF0ZVxuICAgIHNlbGVjdGVkU291cmNlTm9kZSA9IG51bGw7XG4gICAgZGVsZXRlTm9kZUJ0bi5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcblxuICAgIC8vIFJlLXJlbmRlciB0aGUgZ3JhcGggYW5kIGNsb3NlIHRoZSBtb2RhbFxuICAgIHVwZGF0ZUludGVyYWN0aXZlR3JhcGgoKTtcbiAgICBkZWxldGVDb25maXJtTW9kYWwuY2xvc2UoKTtcbn1cblxuXG4vLyAtLS0gQ29yZSBEMyBGdW5jdGlvbnMgLS0tXG5cbmZ1bmN0aW9uIHVwZGF0ZUludGVyYWN0aXZlR3JhcGgoKSB7XG4gICAgaWYgKCFzdmcpIHJldHVybjtcbiAgICBjb25zdCBpc0RhcmsgPSBkb2NFbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGFyaycpO1xuICAgIGNvbnN0IG5vZGVTdHJva2VDb2xvciA9IGlzRGFyayA/IFwiI0EwQUVDMFwiIDogXCIjNEE1NTY4XCI7XG4gICAgY29uc3Qgbm9kZVRleHRDb2xvciA9IGlzRGFyayA/IFwiI0Y3RkFGQ1wiIDogXCIjMUEyMDJDXCI7XG4gICAgY29uc3QgZWRnZUNvbG9yID0gaXNEYXJrID8gXCIjNzE4MDk2XCIgOiBcIiM0QTU1NjhcIjtcblxuICAgIC8vIEVkZ2VzXG4gICAgY29uc3QgZWRnZSA9IHN2Zy5zZWxlY3QoXCIubGlua3NcIikuc2VsZWN0QWxsKFwiZy5lZGdlLWdyb3VwXCIpLmRhdGEoaW50ZXJhY3RpdmVFZGdlcywgZCA9PiBgJHtkLnNvdXJjZS5pZH0tJHtkLnRhcmdldC5pZH1gKTtcbiAgICBlZGdlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBjb25zdCBlZGdlRW50ZXIgPSBlZGdlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJlZGdlLWdyb3VwXCIpO1xuICAgIGVkZ2VFbnRlci5hcHBlbmQoXCJsaW5lXCIpLmF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMikuYXR0cihcIm1hcmtlci1lbmRcIiwgXCJ1cmwoI2Fycm93KVwiKTtcbiAgICBlZGdlRW50ZXIuYXBwZW5kKFwidGV4dFwiKS5hdHRyKFwiY2xhc3NcIiwgXCJlZGdlLWxhYmVsXCIpLmF0dHIoXCJ0ZXh0LWFuY2hvclwiLCBcIm1pZGRsZVwiKS5hdHRyKFwiZHlcIiwgLTUpLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICBjb25zdCBlZGdlVXBkYXRlID0gZWRnZUVudGVyLm1lcmdlKGVkZ2UpO1xuICAgIGVkZ2VVcGRhdGUuc2VsZWN0KFwibGluZVwiKS5hdHRyKFwic3Ryb2tlXCIsIGVkZ2VDb2xvcik7XG4gICAgZWRnZVVwZGF0ZS5zZWxlY3QoXCJ0ZXh0XCIpLnRleHQoZCA9PiBkLnZhbHVlKS5hdHRyKFwiZmlsbFwiLCBub2RlVGV4dENvbG9yKTtcblxuICAgIC8vIE5vZGVzXG4gICAgY29uc3Qgbm9kZSA9IHN2Zy5zZWxlY3QoXCIubm9kZXNcIikuc2VsZWN0QWxsKFwiZy5ub2RlXCIpLmRhdGEoaW50ZXJhY3RpdmVOb2RlcywgZCA9PiBkLmlkKTtcbiAgICBub2RlLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBjb25zdCBub2RlRW50ZXIgPSBub2RlLmVudGVyKCkuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2RlXCIpLmNhbGwoZDMuZHJhZygpLm9uKFwic3RhcnRcIiwgZHJhZ3N0YXJ0ZWQpLm9uKFwiZHJhZ1wiLCBkcmFnZ2VkKS5vbihcImVuZFwiLCBkcmFnZW5kZWQpKTtcbiAgICBub2RlRW50ZXIuYXBwZW5kKFwiY2lyY2xlXCIpLmF0dHIoXCJyXCIsIDI1KS5hdHRyKFwic3Ryb2tlLXdpZHRoXCIsIDMpO1xuICAgIG5vZGVFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtdmFsdWVcIikuYXR0cihcInRleHQtYW5jaG9yXCIsIFwibWlkZGxlXCIpLmF0dHIoXCJkeVwiLCBcIi4zZW1cIikuc3R5bGUoXCJmb250LXNpemVcIiwgXCIxNHB4XCIpLnN0eWxlKFwiZm9udC13ZWlnaHRcIiwgXCJib2xkXCIpLnN0eWxlKFwicG9pbnRlci1ldmVudHNcIiwgXCJub25lXCIpO1xuICAgIG5vZGVFbnRlci5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJjbGFzc1wiLCBcIm5vZGUtbmFtZVwiKS5hdHRyKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIikuYXR0cihcInlcIiwgNDApLnN0eWxlKFwiZm9udC1zaXplXCIsIFwiMTJweFwiKS5zdHlsZShcInBvaW50ZXItZXZlbnRzXCIsIFwibm9uZVwiKTtcbiAgICBjb25zdCBub2RlVXBkYXRlID0gbm9kZUVudGVyLm1lcmdlKG5vZGUpO1xuICAgIG5vZGVVcGRhdGUuc2VsZWN0KFwiY2lyY2xlXCIpLmF0dHIoXCJmaWxsXCIsIGQgPT4gZC5pZCA9PT0gc2VsZWN0ZWRTb3VyY2VOb2RlPy5pZCA/IFwiIzYzQjNFRFwiIDogKGlzRGFyayA/IFwiIzJEMzc0OFwiIDogXCIjRTJFOEYwXCIpKS5hdHRyKFwic3Ryb2tlXCIsIG5vZGVTdHJva2VDb2xvcik7XG4gICAgbm9kZVVwZGF0ZS5zZWxlY3QoXCIubm9kZS12YWx1ZVwiKS50ZXh0KGQgPT4gZC52YWx1ZSkuYXR0cihcImZpbGxcIiwgbm9kZVRleHRDb2xvcik7XG4gICAgbm9kZVVwZGF0ZS5zZWxlY3QoXCIubm9kZS1uYW1lXCIpLnRleHQoZCA9PiBkLm5hbWUpLmF0dHIoXCJmaWxsXCIsIG5vZGVUZXh0Q29sb3IpO1xuICAgIG5vZGVVcGRhdGUub24oXCJjbGlja1wiLCAoZXZlbnQsIGQpID0+IHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGlmICghc2VsZWN0ZWRTb3VyY2VOb2RlKSB7XG4gICAgICAgICAgICBzZWxlY3RlZFNvdXJjZU5vZGUgPSBkO1xuICAgICAgICAgICAgZGVsZXRlTm9kZUJ0bi5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTsgLy8gU2hvdyBkZWxldGUgYnV0dG9uXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWRTb3VyY2VOb2RlLmlkICE9PSBkLmlkKSB7XG4gICAgICAgICAgICAgICAgcGVuZGluZ0VkZ2UgPSB7IHNvdXJjZTogc2VsZWN0ZWRTb3VyY2VOb2RlLCB0YXJnZXQ6IGQgfTtcbiAgICAgICAgICAgICAgICBlZGdlVmFsdWVJbnB1dC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgZWRnZU1vZGFsLnNob3dNb2RhbCgpO1xuICAgICAgICAgICAgICAgIGVkZ2VWYWx1ZUlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxlY3RlZFNvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgZGVsZXRlTm9kZUJ0bi5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTsgLy8gSGlkZSBkZWxldGUgYnV0dG9uXG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIH0pO1xuXG4gICAgc2ltdWxhdGlvbi5ub2RlcyhpbnRlcmFjdGl2ZU5vZGVzKS5vbihcInRpY2tcIiwgdGlja2VkKTtcbiAgICBzaW11bGF0aW9uLmZvcmNlKFwibGlua1wiKS5saW5rcyhpbnRlcmFjdGl2ZUVkZ2VzKS5pZChkID0+IGQuaWQpO1xuICAgIHNpbXVsYXRpb24uYWxwaGEoMC4zKS5yZXN0YXJ0KCk7XG5cbiAgICBmdW5jdGlvbiB0aWNrZWQoKSB7XG4gICAgICAgIGVkZ2VVcGRhdGUuc2VsZWN0KFwibGluZVwiKS5hdHRyKFwieDFcIiwgZCA9PiBkLnNvdXJjZS54KS5hdHRyKFwieTFcIiwgZCA9PiBkLnNvdXJjZS55KS5hdHRyKFwieDJcIiwgZCA9PiBkLnRhcmdldC54KS5hdHRyKFwieTJcIiwgZCA9PiBkLnRhcmdldC55KTtcbiAgICAgICAgZWRnZVVwZGF0ZS5zZWxlY3QoXCJ0ZXh0XCIpLmF0dHIoXCJ4XCIsIGQgPT4gKGQuc291cmNlLnggKyBkLnRhcmdldC54KSAvIDIpLmF0dHIoXCJ5XCIsIGQgPT4gKGQuc291cmNlLnkgKyBkLnRhcmdldC55KSAvIDIpO1xuICAgICAgICBub2RlVXBkYXRlLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgZCA9PiBgdHJhbnNsYXRlKCR7ZC54fSwke2QueX0pYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYWdzdGFydGVkKGV2ZW50LCBkKSB7IGlmICghZXZlbnQuYWN0aXZlKSBzaW11bGF0aW9uLmFscGhhVGFyZ2V0KDAuMykucmVzdGFydCgpOyBkLmZ4ID0gZC54OyBkLmZ5ID0gZC55OyB9XG4gICAgZnVuY3Rpb24gZHJhZ2dlZChldmVudCwgZCkgeyBkLmZ4ID0gZXZlbnQueDsgZC5meSA9IGV2ZW50Lnk7IH1cbiAgICBmdW5jdGlvbiBkcmFnZW5kZWQoZXZlbnQsIGQpIHsgaWYgKCFldmVudC5hY3RpdmUpIHNpbXVsYXRpb24uYWxwaGFUYXJnZXQoMCk7IGQuZnggPSBudWxsOyBkLmZ5ID0gbnVsbDsgfVxufVxuXG4vKipcbiAqIERyYXdzIGEgc21vb3RoLCBwYW5uYWJsZSwgYW5kIHpvb21hYmxlIGdyaWQgYmFja2dyb3VuZC5cbiAqL1xuZnVuY3Rpb24gZHJhd0dyaWQoZ3JpZEcsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGlzRGFyayA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2RhcmsnKTtcbiAgICBjb25zdCBncmlkQ29sb3IgPSBpc0RhcmsgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xKVwiIDogXCJyZ2JhKDAsIDAsIDAsIDAuMSlcIjtcbiAgICBjb25zdCBncmlkU3BhY2luZyA9IDUwO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBzcGFjaW5nIGFuZCBvZmZzZXQgZm9yIGxpbmVzIGJhc2VkIG9uIHRoZSBjdXJyZW50IHpvb20gbGV2ZWwuXG4gICAgLy8gVGhpcyBjcmVhdGVzIHRoZSB2aXN1YWwgZWZmZWN0IG9mIGFuIGluZmluaXRlIGdyaWQuXG4gICAgY29uc3QgbGluZVNwYWNpbmcgPSBncmlkU3BhY2luZyAqIHRyYW5zZm9ybS5rO1xuICAgIGNvbnN0IG9mZnNldFggPSB0cmFuc2Zvcm0ueCAlIGxpbmVTcGFjaW5nO1xuICAgIGNvbnN0IG9mZnNldFkgPSB0cmFuc2Zvcm0ueSAlIGxpbmVTcGFjaW5nO1xuXG4gICAgLy8gQ2xlYXIgYW55IHByZXZpb3VzIGdyaWQgbGluZXMgdG8gcmVkcmF3IHRoZW0uXG4gICAgZ3JpZEcuc2VsZWN0QWxsKFwiKlwiKS5yZW1vdmUoKTtcblxuICAgIC8vIEdlbmVyYXRlIHRoZSBkYXRhIGZvciB0aGUgbmV3IGxpbmUgcG9zaXRpb25zLlxuICAgIGNvbnN0IHhMaW5lcyA9IGQzLnJhbmdlKG9mZnNldFgsIHdpZHRoICsgMSwgbGluZVNwYWNpbmcpO1xuICAgIGNvbnN0IHlMaW5lcyA9IGQzLnJhbmdlKG9mZnNldFksIGhlaWdodCArIDEsIGxpbmVTcGFjaW5nKTtcbiAgICBncmlkRy5zZWxlY3RBbGwoXCIuZ3JpZC1saW5lLXZcIikuZGF0YSh4TGluZXMpLmVudGVyKCkuYXBwZW5kKFwibGluZVwiKS5hdHRyKFwieDFcIiwgZCA9PiBkKS5hdHRyKFwieTFcIiwgMCkuYXR0cihcIngyXCIsIGQgPT4gZCkuYXR0cihcInkyXCIsIGhlaWdodCk7XG4gICAgZ3JpZEcuc2VsZWN0QWxsKFwiLmdyaWQtbGluZS1oXCIpLmRhdGEoeUxpbmVzKS5lbnRlcigpLmFwcGVuZChcImxpbmVcIikuYXR0cihcIngxXCIsIDApLmF0dHIoXCJ5MVwiLCBkID0+IGQpLmF0dHIoXCJ4MlwiLCB3aWR0aCkuYXR0cihcInkyXCIsIGQgPT4gZCk7XG4gICAgZ3JpZEcuc2VsZWN0QWxsKFwibGluZVwiKS5hdHRyKFwic3Ryb2tlXCIsIGdyaWRDb2xvcikuYXR0cihcInN0cm9rZS13aWR0aFwiLCAxKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlUmVzaXplKCkge1xuICAgIGlmICghaW50ZXJhY3RpdmVHcmFwaENvbnRhaW5lciB8fCAhc3ZnUm9vdCB8fCAhZ3JpZEcpIHJldHVybjtcblxuICAgIGNvbnN0IHdpZHRoID0gaW50ZXJhY3RpdmVHcmFwaENvbnRhaW5lci5jbGllbnRXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbnRlcmFjdGl2ZUdyYXBoQ29udGFpbmVyLmNsaWVudEhlaWdodDtcblxuICAgIHN2Z1Jvb3QuYXR0cihcIndpZHRoXCIsIHdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgZHJhd0dyaWQoZ3JpZEcsIHdpZHRoLCBoZWlnaHQsIGN1cnJlbnRUcmFuc2Zvcm0pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUaGVtZUZvckdyYXBoKCkge1xuICAgIGlmICghc3ZnKSByZXR1cm47XG4gICAgY29uc3QgaXNEYXJrID0gZG9jRWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2RhcmsnKTtcbiAgICBjb25zdCBhcnJvd2hlYWRDb2xvciA9IGlzRGFyayA/IFwiIzcxODA5NlwiIDogXCIjNEE1NTY4XCI7XG4gICAgZDMuc2VsZWN0KFwiI2Fycm93IHBhdGhcIikuc3R5bGUoXCJmaWxsXCIsIGFycm93aGVhZENvbG9yKTtcbiAgICB1cGRhdGVJbnRlcmFjdGl2ZUdyYXBoKCk7XG4gICAgY29uc3Qgd2lkdGggPSBpbnRlcmFjdGl2ZUdyYXBoQ29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGludGVyYWN0aXZlR3JhcGhDb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIGRyYXdHcmlkKGdyaWRHLCB3aWR0aCwgaGVpZ2h0LCBjdXJyZW50VHJhbnNmb3JtKTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVyYWN0aXZlR3JhcGgoKSB7XG4gICAgY29uc3Qgd2lkdGggPSBpbnRlcmFjdGl2ZUdyYXBoQ29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGludGVyYWN0aXZlR3JhcGhDb250YWluZXIuY2xpZW50SGVpZ2h0O1xuXG4gICAgc3ZnUm9vdCA9IGQzLnNlbGVjdChpbnRlcmFjdGl2ZUdyYXBoQ29udGFpbmVyKS5hcHBlbmQoXCJzdmdcIikuYXR0cihcIndpZHRoXCIsIHdpZHRoKS5hdHRyKFwiaGVpZ2h0XCIsIGhlaWdodClcbiAgICAgICAgLm9uKFwiZGJsY2xpY2tcIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY29uc3QgW214LCBteV0gPSBkMy5wb2ludGVyKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHRlbXBOb2RlQ29vcmRzQXJyID0gY3VycmVudFRyYW5zZm9ybS5pbnZlcnQoW214LCBteV0pO1xuICAgICAgICAgICAgdGVtcE5vZGVDb29yZHMueCA9IHRlbXBOb2RlQ29vcmRzQXJyWzBdO1xuICAgICAgICAgICAgdGVtcE5vZGVDb29yZHMueSA9IHRlbXBOb2RlQ29vcmRzQXJyWzFdO1xuICAgICAgICAgICAgbm9kZU5hbWVJbnB1dC52YWx1ZSA9IGBub2RlJHtpbnRlcmFjdGl2ZU5vZGVzLmxlbmd0aCArIDF9YDtcbiAgICAgICAgICAgIG5vZGVWYWx1ZUlucHV0LnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgIG5vZGVNb2RhbC5zaG93TW9kYWwoKTtcbiAgICAgICAgICAgIG5vZGVWYWx1ZUlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBub2RlVmFsdWVJbnB1dC5zZWxlY3QoKTtcbiAgICAgICAgICAgIC8vIGRpc2FsbG93IGJyb3dzZXIgZHJvcGRvd24gZm9yIG5vZGUgdmFsdWVzXG4gICAgICAgICAgICBub2RlVmFsdWVJbnB1dC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29tcGxldGVcIiwgXCJvZmZcIik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZFNvdXJjZU5vZGUpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZFNvdXJjZU5vZGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGRlbGV0ZU5vZGVCdG4uY2xhc3NMaXN0LmFkZCgnaGlkZGVuJyk7IC8vIEhpZGUgb24gZGVzZWxlY3RcbiAgICAgICAgICAgICAgICB1cGRhdGVJbnRlcmFjdGl2ZUdyYXBoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgc3ZnUm9vdC5hcHBlbmQoXCJkZWZzXCIpLmFwcGVuZChcIm1hcmtlclwiKS5hdHRyKFwiaWRcIiwgXCJhcnJvd1wiKS5hdHRyKFwidmlld0JveFwiLCBcIjAgLTUgMTAgMTBcIikuYXR0cihcInJlZlhcIiwgMzMpLmF0dHIoXCJyZWZZXCIsIDApLmF0dHIoXCJtYXJrZXJXaWR0aFwiLCA2KS5hdHRyKFwibWFya2VySGVpZ2h0XCIsIDYpLmF0dHIoXCJvcmllbnRcIiwgXCJhdXRvXCIpLmFwcGVuZChcInBhdGhcIikuYXR0cihcImRcIiwgXCJNMCwtNUwxMCwwTDAsNVwiKS5hdHRyKFwiY2xhc3NcIiwgXCJhcnJvd2hlYWRcIik7XG5cbiAgICBncmlkRyA9IHN2Z1Jvb3QuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpO1xuXG4gICAgem9vbWFibGVDb250YWluZXIgPSBzdmdSb290LmFwcGVuZChcImdcIik7XG4gICAgc3ZnID0gem9vbWFibGVDb250YWluZXI7IC8vIE1haW4gY29udGFpbmVyIGZvciBub2RlcyBhbmQgbGlua3NcbiAgICBzdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJsaW5rc1wiKTtcbiAgICBzdmcuYXBwZW5kKFwiZ1wiKS5hdHRyKFwiY2xhc3NcIiwgXCJub2Rlc1wiKTtcblxuICAgIGNvbnN0IHpvb21CZWhhdmlvciA9IGQzLnpvb20oKS5zY2FsZUV4dGVudChbMC4xLCA4XSkub24oXCJ6b29tXCIsIChldmVudCkgPT4ge1xuICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gZXZlbnQudHJhbnNmb3JtO1xuICAgICAgICB6b29tYWJsZUNvbnRhaW5lci5hdHRyKFwidHJhbnNmb3JtXCIsIGN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgICAgICBkcmF3R3JpZChncmlkRywgaW50ZXJhY3RpdmVHcmFwaENvbnRhaW5lci5jbGllbnRXaWR0aCwgaW50ZXJhY3RpdmVHcmFwaENvbnRhaW5lci5jbGllbnRIZWlnaHQsIGN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIH0pO1xuICAgIHN2Z1Jvb3QuY2FsbCh6b29tQmVoYXZpb3IpLm9uKFwiZGJsY2xpY2suem9vbVwiLCBudWxsKTtcblxuICAgIGRyYXdHcmlkKGdyaWRHLCB3aWR0aCwgaGVpZ2h0LCBjdXJyZW50VHJhbnNmb3JtKTtcblxuICAgIHNpbXVsYXRpb24gPSBkMy5mb3JjZVNpbXVsYXRpb24oaW50ZXJhY3RpdmVOb2RlcylcbiAgICAgICAgLmZvcmNlKFwibGlua1wiLCBkMy5mb3JjZUxpbmsoaW50ZXJhY3RpdmVFZGdlcykuaWQoZCA9PiBkLmlkKS5kaXN0YW5jZSgxNTApLnN0cmVuZ3RoKDAuNikpXG4gICAgICAgIC5mb3JjZShcImNoYXJnZVwiLCBkMy5mb3JjZU1hbnlCb2R5KCkuc3RyZW5ndGgoLTgwMCkpXG4gICAgICAgIC5mb3JjZShcInBvc2l0aW9uWFwiLCBkMy5mb3JjZVgoMzAwKSlcbiAgICAgICAgLmZvcmNlKFwicG9zaXRpb25ZXCIsIGQzLmZvcmNlWSgzMDApKTtcblxuICAgIHVwZGF0ZVRoZW1lRm9yR3JhcGgoKTtcbn1cblxuLy8gLS0tIEV2ZW50IEhhbmRsZXJzIGZvciBVSSAtLS1cblxubm9kZUZvcm0uYWRkRXZlbnRMaXN0ZW5lcignc3VibWl0JywgKCkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBub2RlTmFtZUlucHV0LnZhbHVlLnRyaW0oKTtcbiAgICBjb25zdCB2YWx1ZSA9IG5vZGVWYWx1ZUlucHV0LnZhbHVlLnRyaW0oKTtcbiAgICBpZiAobmFtZSAmJiBpbnRlcmFjdGl2ZU5vZGVzLmZpbmQobiA9PiBuLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgIGFsZXJ0KFwiQSBub2RlIHdpdGggdGhpcyBuYW1lIGFscmVhZHkgZXhpc3RzLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgbm9kZUtleSA9IGNvbmNyZXRlR3JhcGguYWRkTm9kZSh2YWx1ZSk7XG4gICAgY29uc3QgbmV3Tm9kZSA9IHsgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksIG5hbWUsIHZhbHVlLCB4OiB0ZW1wTm9kZUNvb3Jkcy54LCB5OiB0ZW1wTm9kZUNvb3Jkcy55LCBub2RlS2V5OiBub2RlS2V5LCBmeDogdGVtcE5vZGVDb29yZHMueCwgZnk6IHRlbXBOb2RlQ29vcmRzLnkgfTtcbiAgICBpbnRlcmFjdGl2ZU5vZGVzLnB1c2gobmV3Tm9kZSk7XG4gICAgdXBkYXRlSW50ZXJhY3RpdmVHcmFwaCgpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4geyBuZXdOb2RlLmZ4ID0gbnVsbDsgbmV3Tm9kZS5meSA9IG51bGw7IH0sIDE1MCk7XG59KTtcbmNhbmNlbE5vZGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiBub2RlTW9kYWwuY2xvc2UoKSk7XG5cbmVkZ2VGb3JtLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsICgpID0+IHtcbiAgICBpZiAoIXBlbmRpbmdFZGdlKSByZXR1cm47XG4gICAgLy8gaWYgaW50ZXJhY3RpdmVFZGdlcyBhbHJlYWR5IGNvbnRhaW5zIHRoaXMgZWRnZSwgcmVtb3ZlIGl0IGZpcnN0XG4gICAgY29uc3QgZXhpc3RpbmdFZGdlSW5kZXggPSBpbnRlcmFjdGl2ZUVkZ2VzLmZpbmRJbmRleChlID0+IGUuc291cmNlLmlkID09PSBwZW5kaW5nRWRnZS5zb3VyY2UuaWQgJiYgZS50YXJnZXQuaWQgPT09IHBlbmRpbmdFZGdlLnRhcmdldC5pZCk7XG4gICAgaWYgKGV4aXN0aW5nRWRnZUluZGV4ICE9PSAtMSkge1xuICAgICAgICBpbnRlcmFjdGl2ZUVkZ2VzLnNwbGljZShleGlzdGluZ0VkZ2VJbmRleCwgMSk7XG4gICAgfVxuICAgIGludGVyYWN0aXZlRWRnZXMucHVzaCh7IHNvdXJjZTogcGVuZGluZ0VkZ2Uuc291cmNlLCB0YXJnZXQ6IHBlbmRpbmdFZGdlLnRhcmdldCwgdmFsdWU6IGVkZ2VWYWx1ZUlucHV0LnZhbHVlLnRyaW0oKSB9KTtcbiAgICBjb25jcmV0ZUdyYXBoLmFkZEVkZ2UocGVuZGluZ0VkZ2Uuc291cmNlLm5vZGVLZXksIHBlbmRpbmdFZGdlLnRhcmdldC5ub2RlS2V5LCBlZGdlVmFsdWVJbnB1dC52YWx1ZS50cmltKCkpO1xuICAgIHBlbmRpbmdFZGdlID0gbnVsbDtcbiAgICB1cGRhdGVJbnRlcmFjdGl2ZUdyYXBoKCk7XG59KTtcbmNhbmNlbEVkZ2VCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7IHBlbmRpbmdFZGdlID0gbnVsbDsgZWRnZU1vZGFsLmNsb3NlKCk7IH0pO1xuXG5hZGROb2RlSW5wdXRCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3QgaW5wdXRDb3VudCA9IG9wZXJhdGlvbklucHV0c0NvbnRhaW5lci5jaGlsZHJlbi5sZW5ndGg7XG4gICAgY29uc3QgaW5wdXRXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW5wdXRXcmFwcGVyLmNsYXNzTmFtZSA9ICdyZWxhdGl2ZSc7XG4gICAgY29uc3QgbmV3SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIG5ld0lucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgbmV3SW5wdXQucGxhY2Vob2xkZXIgPSBgSW5wdXQgJHtpbnB1dENvdW50ICsgMX1gO1xuICAgIG5ld0lucHV0LmNsYXNzTmFtZSA9ICdiZy1ncmF5LTEwMCBkYXJrOmJnLWdyYXktNzAwIGJvcmRlciBib3JkZXItZ3JheS0zMDAgZGFyazpib3JkZXItZ3JheS02MDAgcm91bmRlZC1tZCBwLTIgcGwtMyB3LTMyIGZvY3VzOnJpbmctMiBmb2N1czpyaW5nLWJsdWUtNTAwIGZvY3VzOm91dGxpbmUtbm9uZSc7XG4gICAgY29uc3QgcmVtb3ZlQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgcmVtb3ZlQnRuLmlubmVySFRNTCA9ICcmdGltZXM7JztcbiAgICByZW1vdmVCdG4uY2xhc3NOYW1lID0gJ2Fic29sdXRlIHJpZ2h0LTEgdG9wLTEvMiAtdHJhbnNsYXRlLXktMS8yIHRleHQtZ3JheS00MDAgaG92ZXI6dGV4dC1yZWQtNTAwIGZvbnQtYm9sZCBwLTEgbGVhZGluZy1ub25lJztcbiAgICByZW1vdmVCdG4ub25jbGljayA9ICgpID0+IHtcbiAgICAgICAgaW5wdXRXcmFwcGVyLnJlbW92ZSgpO1xuICAgICAgICBBcnJheS5mcm9tKG9wZXJhdGlvbklucHV0c0NvbnRhaW5lci5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCcpKS5mb3JFYWNoKChpbnAsIGkpID0+IHsgaW5wLnBsYWNlaG9sZGVyID0gYElucHV0ICR7aSArIDF9YDsgfSk7XG4gICAgfTtcbiAgICBpbnB1dFdyYXBwZXIuYXBwZW5kQ2hpbGQobmV3SW5wdXQpO1xuICAgIGlucHV0V3JhcHBlci5hcHBlbmRDaGlsZChyZW1vdmVCdG4pO1xuICAgIG9wZXJhdGlvbklucHV0c0NvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dFdyYXBwZXIpO1xuICAgIHJldHVybiByZW1vdmVCdG4ub25jbGljaztcbn0pO1xuXG5ydW5PcGVyYXRpb25CdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgY29uc3Qgb3BlcmF0aW9uTmFtZSA9IG9wZXJhdGlvblNlbGVjdG9yLnZhbHVlO1xuICAgIGlmICghb3BlcmF0aW9uTmFtZSkgeyBhbGVydChcIlBsZWFzZSBzZWxlY3QgYW4gb3BlcmF0aW9uIHRvIHJ1bi5cIik7IHJldHVybjsgfVxuICAgIGNvbnN0IGlucHV0Tm9kZU5hbWVzID0gQXJyYXkuZnJvbShvcGVyYXRpb25JbnB1dHNDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSkubWFwKGlucHV0ID0+IGlucHV0LnZhbHVlLnRyaW0oKSkuZmlsdGVyKG5hbWUgPT4gbmFtZSAhPT0gXCJcIik7XG4gICAgZXhlY3V0ZU9wZXJhdGlvbihvcGVyYXRpb25OYW1lLCBpbnB1dE5vZGVOYW1lcyk7XG59KTtcblxucnVuU2ltdWxhdGlvbkJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBzaW11bGF0aW9uLnRpY2soMTAwKTtcbiAgICB1cGRhdGVJbnRlcmFjdGl2ZUdyYXBoKCk7XG59KVxuXG4vLyAtLS0gRGVsZXRlIE5vZGUgRXZlbnQgTGlzdGVuZXJzIC0tLVxuZGVsZXRlTm9kZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICBpZiAoc2VsZWN0ZWRTb3VyY2VOb2RlKSB7XG4gICAgICAgIGRlbGV0ZUNvbmZpcm1Nb2RhbC5zaG93TW9kYWwoKTtcbiAgICB9XG59KTtcbmNhbmNlbERlbGV0ZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGRlbGV0ZUNvbmZpcm1Nb2RhbC5jbG9zZSgpKTtcbmNvbmZpcm1EZWxldGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBkZWxldGVTZWxlY3RlZE5vZGUpO1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChlKSA9PiB7XG4gICAgaWYgKChlLmtleSA9PT0gJ0RlbGV0ZScgfHwgZS5rZXkgPT09ICdCYWNrc3BhY2UnKSAmJiBzZWxlY3RlZFNvdXJjZU5vZGUpIHtcbiAgICAgICAgLy8gUHJldmVudCB0eXBpbmcgJ0JhY2tzcGFjZScgaW4gYW4gaW5wdXQgZmllbGQgZnJvbSB0cmlnZ2VyaW5nIGRlbGV0aW9uXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50LnRhZ05hbWUgPT09ICdJTlBVVCcgfHwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC50YWdOYW1lID09PSAnVEVYVEFSRUEnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBkZWxldGVDb25maXJtTW9kYWwuc2hvd01vZGFsKCk7XG4gICAgfVxufSk7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgaGFuZGxlUmVzaXplKTtcblxuXG4vLyAtLS0gVXNlci1BZGFwdGFibGUgRnVuY3Rpb25zIC0tLVxuXG4vKipcbiAqIFBvcHVsYXRlcyB0aGUgb3BlcmF0aW9uIHNlbGVjdG9yIGRyb3Bkb3duLlxuICovXG5mdW5jdGlvbiBwb3B1bGF0ZU9wZXJhdGlvblNlbGVjdG9yKHJlcykge1xuICAgIG9wZXJhdGlvblNlbGVjdG9yLmlubmVySFRNTCA9ICcnO1xuICAgIGNvbnN0IG9wTmFtZXMgPSBbLi4ucmVzLmxpc3RPcGVyYXRpb25zKCldLm1hcChvcCA9PiBvcC50b1N0cmluZygpKTtcblxuICAgIGlmIChvcE5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBvcGVyYXRpb25TZWxlY3Rvci5hZGQobmV3IE9wdGlvbignTm8gb3BlcmF0aW9ucyBmb3VuZCcsICcnLCB0cnVlLCB0cnVlKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3BOYW1lcy5mb3JFYWNoKG5hbWUgPT4gb3BlcmF0aW9uU2VsZWN0b3IuYWRkKG5ldyBPcHRpb24obmFtZSwgbmFtZSkpKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoZSBcIlJ1blwiIGJ1dHRvbiBpcyBjbGlja2VkLiBZb3UgaGF2ZSBhY2Nlc3MgdG8gYGludGVyYWN0aXZlTm9kZXNgIGFuZCBgaW50ZXJhY3RpdmVFZGdlc2AuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVPcGVyYXRpb24ob3BlcmF0aW9uTmFtZSwgaW5wdXROb2RlTmFtZXMpIHtcbiAgICBjb25zb2xlLmxvZyhcIkV4ZWN1dGluZyBvcGVyYXRpb246XCIsIG9wZXJhdGlvbk5hbWUsIFwid2l0aCBpbnB1dHM6XCIsIGlucHV0Tm9kZU5hbWVzKTtcbiAgICBjb25zdCBpbnB1dE5vZGVzID0gaW5wdXROb2RlTmFtZXMubWFwKG5hbWUgPT4gaW50ZXJhY3RpdmVOb2Rlcy5maW5kKG5vZGUgPT4gbm9kZS5uYW1lID09PSBuYW1lKSkuZmlsdGVyKEJvb2xlYW4pO1xuXG4gICAgaWYgKGlucHV0Tm9kZXMubGVuZ3RoICE9PSBpbnB1dE5vZGVOYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgYWxlcnQoXCJPbmUgb3IgbW9yZSBpbnB1dCBub2RlcyBjb3VsZCBub3QgYmUgZm91bmQgaW4gdGhlIGdyYXBoLlwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBpbnB1dEtleXMgPSBpbnB1dE5vZGVzLm1hcChub2RlID0+IG5vZGUubm9kZUtleSk7XG5cbiAgICB0cnkge1xuICAgICAgICBsZXQgcmVzID0gY3VycmVudF9yZXMucnVuT3BlcmF0aW9uKGNvbmNyZXRlR3JhcGgsIG9wZXJhdGlvbk5hbWUsIGlucHV0S2V5cyk7XG4gICAgICAgIGxldCB0cmFjZURvdHNSYXcgPSByZXMuY2hhaW5lZERvdFRyYWNlKCk7XG5cbiAgICAgICAgaWYgKHRyYWNlRG90c1JhdyAmJiB0cmFjZURvdHNSYXcudHJpbSgpICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBjdXJyZW50VHJhY2VEb3RzID0gdHJhY2VEb3RzUmF3LnNwbGl0KCctLS0nKS5tYXAoZG90ID0+IGRvdC50cmltKCkpLmZpbHRlcihkb3QgPT4gZG90KTtcbiAgICAgICAgICAgIHJhd0N1cnJlbnRUcmFjZURvdHMgPSBjdXJyZW50VHJhY2VEb3RzOyAvLyBLZWVwIHRoZSByYXcgdHJhY2UgZG90cyBmb3IgcmVmZXJlbmNlXG4gICAgICAgICAgICBpZiAoc2tpcER1cGxpY2F0ZVRyYWNlc0lucHV0LmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBkZWR1cGxpY2F0ZSBjb25zZWN1dGl2ZSBpZGVudGljYWwgdHJhY2UgZG90c1xuICAgICAgICAgICAgICAgIGN1cnJlbnRUcmFjZURvdHMgPSBjdXJyZW50VHJhY2VEb3RzLmZpbHRlcigoZG90LCBpbmRleCwgYXJyKSA9PiBpbmRleCA9PT0gMCB8fCBkb3QgIT09IGFycltpbmRleCAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRlZHVwbGljYXRlIGNvbnNlY3V0aXZlIGlkZW50aWNhbCB0cmFjZSBkb3RzXG4gICAgICAgICAgICAvLyBub3RlOiB3ZSdyZSBkZWR1cGluZyBub3cgd2l0aCBza2lwRHVwbGljYXRlVHJhY2VzSW5wdXRcbiAgICAgICAgICAgIC8vIGN1cnJlbnRUcmFjZURvdHMgPSBjdXJyZW50VHJhY2VEb3RzLmZpbHRlcigoZG90LCBpbmRleCwgYXJyKSA9PiBpbmRleCA9PT0gMCB8fCBkb3QgIT09IGFycltpbmRleCAtIDFdKTtcbiAgICAgICAgICAgIGN1cnJlbnRUcmFjZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHRyYWNlQm94LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgcmVuZGVyVHJhY2VHcmFwaCgpO1xuICAgICAgICAgICAgdHJhY2VCb3guc2Nyb2xsSW50b1ZpZXcoeyBiZWhhdmlvcjogJ3Ntb290aCcgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50VHJhY2VEb3RzID0gW107XG4gICAgICAgICAgICB0cmFjZUJveC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXZnWCA9IGlucHV0Tm9kZXMucmVkdWNlKChzdW0sIG4pID0+IHN1bSArIChuLnggfHwgMCksIDApIC8gaW5wdXROb2Rlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGF2Z1kgPSBpbnB1dE5vZGVzLnJlZHVjZSgoc3VtLCBuKSA9PiBzdW0gKyAobi55IHx8IDApLCAwKSAvIGlucHV0Tm9kZXMubGVuZ3RoO1xuXG4gICAgICAgIC8vIG5vdyBtYWtlIHRoZSBjdXJyZW50IGludGVyYWN0aXZlRWRnZXMgYW5kIGludGVyYWN0aXZlTm9kZXMgc3luY2hyb25pemVkIHdpdGggY29uY3JldGVHcmFwaFxuICAgICAgICBsZXQgbmV3SW50ZXJhY3RpdmVOb2RlcyA9IFtdO1xuICAgICAgICBsZXQgbmV3SW50ZXJhY3RpdmVFZGdlcyA9IFtdO1xuXG4gICAgICAgIGNvbnN0IGFkZE5vZGUgPSAoa2V5LCBuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgbGV0IHRoaXNYID0gYXZnWCArIE1hdGgucmFuZG9tKCkgKiA1MDsgLy8gUmFuZG9tbHkgb2Zmc2V0IHRvIGF2b2lkIG92ZXJsYXBcbiAgICAgICAgICAgIGxldCB0aGlzWSA9IGF2Z1kgKyBNYXRoLnJhbmRvbSgpICogNTA7IC8vIFJhbmRvbWx5IG9mZnNldCB0byBhdm9pZCBvdmVybGFwXG4gICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgbmFtZSBhbHJlYWR5IGV4aXN0cywgaWYgc28sIGFwcGVuZCBhIG51bWJlciB0byBpdFxuICAgICAgICAgICAgbGV0IGZvdW5kTmFtZSA9IGludGVyYWN0aXZlTm9kZXMuZmluZChuID0+IG4ubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICB3aGlsZSAoZm91bmROYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydHMgPSBuYW1lLm1hdGNoKC9eKC4qPykoXFxkKyk/JC8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2VOYW1lID0gcGFydHNbMV07XG4gICAgICAgICAgICAgICAgY29uc3QgbnVtID0gcGFydHNbMl0gPyBwYXJzZUludChwYXJ0c1syXSkgKyAxIDogMTtcbiAgICAgICAgICAgICAgICBuYW1lID0gYCR7YmFzZU5hbWV9JHtudW19YDtcbiAgICAgICAgICAgICAgICBmb3VuZE5hbWUgPSBpbnRlcmFjdGl2ZU5vZGVzLmZpbmQobiA9PiBuLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SW50ZXJhY3RpdmVOb2Rlcy5wdXNoKHsgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksIG5hbWUsIHZhbHVlLCB4OiB0aGlzWCwgeTogdGhpc1ksIG5vZGVLZXk6IGtleSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga25vd25OZXdOb2RlIG9mIHJlcykge1xuICAgICAgICAgICAgbGV0IG5vZGVLZXkgPSBrbm93bk5ld05vZGUua2V5KCk7XG4gICAgICAgICAgICBsZXQgbmFtZSA9IGtub3duTmV3Tm9kZS5uYW1lKCk7XG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBrbm93bk5ld05vZGUudmFsdWUoKTtcbiAgICAgICAgICAgIC8vIGlmIFwibmV3IG5vZGVcIiBpcyBhY3R1YWxseSBhbiBleGlzdGluZywgc2hhcGUgbWF0Y2hlZCBub2RlLCB0aGVuIHdlIG5lZWQgdG8ganVzdCB1cGRhdGUgaXRzIG5hbWVcbiAgICAgICAgICAgIC8vIE5PVEU6IHRoaXMgaXMgYSBzcGVjaWFsIGNhc2Ugd2Ugb25seSBuZWVkIHRvIGhhbmRsZSBoZXJlLCBpbiB0aGUgX2NvbmNyZXRlXyBzZXR0aW5nLFxuICAgICAgICAgICAgLy8gIHNpbmNlIGFic3RyYWN0bHkgYSByZXR1cm5lZCBub2RlIGNhbiBuZXZlciBhbHJlYWR5IGV4aXN0IGluIHRoZSBhYnN0cmFjdCBncmFwaC5cbiAgICAgICAgICAgIGxldCBleGlzdGluZ05vZGUgPSBpbnRlcmFjdGl2ZU5vZGVzLmZpbmQobiA9PiBuLm5vZGVLZXkgPT09IG5vZGVLZXkpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nTm9kZSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nTm9kZS5uYW1lID0gbmFtZTsgLy9VcGRhdGUgbmFtZSBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgICAgICBleGlzdGluZ05vZGUudmFsdWUgPSB2YWx1ZTsgLy8gVXBkYXRlIHZhbHVlIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIG5ld0ludGVyYWN0aXZlTm9kZXMucHVzaChleGlzdGluZ05vZGUpOyAvLyBLZWVwIGV4aXN0aW5nIG5vZGVzXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZE5vZGUobm9kZUtleSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgY29uY3JldGVHcmFwaC5nZXROb2RlcygpKSB7XG4gICAgICAgICAgICBsZXQga2V5ID0gbm9kZS5rZXkoKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IG5vZGUudmFsdWUoKTtcblxuICAgICAgICAgICAgbGV0IGFscmVhZHlFeGlzdHMgPSBuZXdJbnRlcmFjdGl2ZU5vZGVzLmZpbmQobiA9PiBuLm5vZGVLZXkgPT09IGtleSk7XG4gICAgICAgICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICAgICAgICAgIC8vIHdlIGFkZGVkIHRoaXMgYWxyZWFkeSB3aXRoIGEgcHJvcGVyIG5hbWVcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGV4aXN0aW5nTm9kZSA9IGludGVyYWN0aXZlTm9kZXMuZmluZChuID0+IG4ubm9kZUtleSA9PT0ga2V5KTtcbiAgICAgICAgICAgIGlmICghZXhpc3RpbmdOb2RlKSB7XG4gICAgICAgICAgICAgICAgYWRkTm9kZShrZXksIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ05vZGUudmFsdWUgPSB2YWx1ZTsgLy8gVXBkYXRlIHZhbHVlIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIG5ld0ludGVyYWN0aXZlTm9kZXMucHVzaChleGlzdGluZ05vZGUpOyAvLyBLZWVwIGV4aXN0aW5nIG5vZGVzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlZGdlIG9mIGNvbmNyZXRlR3JhcGguZ2V0RWRnZXMoKSkge1xuICAgICAgICAgICAgbGV0IHNvdXJjZUtleSA9IGVkZ2Uuc3JjKCk7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0S2V5ID0gZWRnZS5kc3QoKTtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGVkZ2Uud2VpZ2h0KCk7XG5cbiAgICAgICAgICAgIGxldCBzb3VyY2VOb2RlID0gbmV3SW50ZXJhY3RpdmVOb2Rlcy5maW5kKG4gPT4gbi5ub2RlS2V5ID09PSBzb3VyY2VLZXkpO1xuICAgICAgICAgICAgbGV0IHRhcmdldE5vZGUgPSBuZXdJbnRlcmFjdGl2ZU5vZGVzLmZpbmQobiA9PiBuLm5vZGVLZXkgPT09IHRhcmdldEtleSk7XG5cbiAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlICYmIHRhcmdldE5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgZWRnZSBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgIGxldCBleGlzdGluZ0VkZ2UgPSBpbnRlcmFjdGl2ZUVkZ2VzLmZpbmQoZSA9PiBlLnNvdXJjZS5ub2RlS2V5ID09PSBzb3VyY2VLZXkgJiYgZS50YXJnZXQubm9kZUtleSA9PT0gdGFyZ2V0S2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIWV4aXN0aW5nRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICBuZXdJbnRlcmFjdGl2ZUVkZ2VzLnB1c2goeyBzb3VyY2U6IHNvdXJjZU5vZGUsIHRhcmdldDogdGFyZ2V0Tm9kZSwgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgZXhpc3RpbmcgZWRnZSBpZiBpdCBhbHJlYWR5IGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0VkZ2UudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyB1cGRhdGUgdGhlIHNvdXJjZSBhbmQgdGFyZ2V0IG5vZGVzXG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRWRnZS5zb3VyY2UgPSBzb3VyY2VOb2RlO1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0VkZ2UudGFyZ2V0ID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgbmV3SW50ZXJhY3RpdmVFZGdlcy5wdXNoKGV4aXN0aW5nRWRnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgaW50ZXJhY3RpdmUgbm9kZXMgYW5kIGVkZ2VzXG4gICAgICAgIGludGVyYWN0aXZlTm9kZXMgPSBuZXdJbnRlcmFjdGl2ZU5vZGVzO1xuICAgICAgICBpbnRlcmFjdGl2ZUVkZ2VzID0gbmV3SW50ZXJhY3RpdmVFZGdlcztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxldCBlcnJvck1lc3NhZ2UgPSBlLmNhdXNlID8gZS5jYXVzZS50b1N0cmluZygpIDogZS50b1N0cmluZygpO1xuICAgICAgICBhbGVydChlcnJvck1lc3NhZ2UpO1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcnVubmluZyBvcGVyYXRpb246XCIsIGUpO1xuICAgIH1cblxuICAgIHVwZGF0ZUludGVyYWN0aXZlR3JhcGgoKTsgLy8gUmVmcmVzaCB0aGUgZ3JhcGggdG8gc2hvdyBjaGFuZ2VzXG59XG5cbmZ1bmN0aW9uIHJlbmRlclRyYWNlR3JhcGgoKSB7XG4gICAgaWYgKGN1cnJlbnRUcmFjZURvdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRyYWNlQm94LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cmFjZUJveC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBjb25zdCBkb3QgPSBjdXJyZW50VHJhY2VEb3RzW2N1cnJlbnRUcmFjZUluZGV4XTtcbiAgICBjb25zb2xlLmxvZyhcIlJlbmRlcmluZyB0cmFjZSBncmFwaCBmb3IgaW5kZXg6XCIsIGN1cnJlbnRUcmFjZUluZGV4LCBcIndpdGggRE9UOlxcblwiLCBkb3QpO1xuXG4gICAgLy8gQXBwbHkgdGhlbWUgYWRqdXN0bWVudHMgdG8gdGhlIERPVCBzdHJpbmdcbiAgICAvLyBsZXQgdGhlbWVkRG90ID0gZG90LnJlcGxhY2UoL2ZpbGw9XCJ3aGl0ZVwiL2csICdmaWxsPVwibm9uZVwiJyk7XG4gICAgLy8gdGhlbWVkRG90ID0gdGhlbWVkRG90LnJlcGxhY2UoLzx0ZXh0IC9nLCAnPHRleHQgZmlsbD1cIndoaXRlXCIgJyk7XG4gICAgLy8gaWYgKGRvY0VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkYXJrJykpIHtcbiAgICAvLyAgICAgdGhlbWVkRG90ID0gdGhlbWVkRG90LnJlcGxhY2UoL3N0cm9rZT1cImJsYWNrXCIvZywgJ3N0cm9rZT1cIndoaXRlXCInKTtcbiAgICAvLyAgICAgdGhlbWVkRG90ID0gdGhlbWVkRG90LnJlcGxhY2UoLzx0ZXh0IGZpbGw9XCJibGFja1wiL2csICc8dGV4dCBmaWxsPVwid2hpdGVcIicpO1xuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICAgIHRoZW1lZERvdCA9IHRoZW1lZERvdC5yZXBsYWNlKC9zdHJva2U9XCJ3aGl0ZVwiL2csICdzdHJva2U9XCJibGFja1wiJyk7XG4gICAgLy8gICAgIHRoZW1lZERvdCA9IHRoZW1lZERvdC5yZXBsYWNlKC88dGV4dCBmaWxsPVwid2hpdGVcIi9nLCAnPHRleHQgZmlsbD1cImJsYWNrXCInKTtcbiAgICAvLyB9XG5cbiAgICBsZXQgdGhlbWVkRG90ID0gZG90O1xuICAgIGlzVHJhY2VSZW5kZXJpbmcgPSB0cnVlOyAvLyBQcmV2ZW50IGZ1cnRoZXIgaW50ZXJhY3Rpb25zIGR1cmluZyByZW5kZXJpbmdcbiAgICB0cmFjZUdyYXBodml6XG4gICAgICAgIC50cmFuc2l0aW9uKCgpID0+IGQzLnRyYW5zaXRpb24oKS5kdXJhdGlvbigzMDApLmVhc2UoZDMuZWFzZUxpbmVhcikpXG4gICAgICAgIC5yZW5kZXJEb3QodGhlbWVkRG90KVxuICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gLy8gYWRqdXN0IHRoZSBzdmcgaW5zaWRlIHRyYWNlLWdyYXBoLWNvbnRhaW5lciB0byBiZSBmdWxsIHdpZHRoIGFuZCBoZWlnaHQ6XG4gICAgICAgICAgICAvLyBjb25zdCB0cmFjZUdyYXBoU3ZnID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0cmFjZS1ncmFwaC1jb250YWluZXIgc3ZnXCIpO1xuICAgICAgICAgICAgLy8gaWYgKHRyYWNlR3JhcGhTdmcpIHtcbiAgICAgICAgICAgIC8vICAgICAvLyB0cmFjZUdyYXBoU3ZnLnN0eWxlLndpZHRoID0gXCIxMDAlXCI7XG4gICAgICAgICAgICAvLyAgICAgLy8gdHJhY2VHcmFwaFN2Zy5zdHlsZS5oZWlnaHQgPSBcIjEwMCVcIjtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIHNjcm9sbCB0byB0aGUgYm90dG9tIG9mIHRoZSB0cmFjZSBib3hcbiAgICAgICAgICAgIC8vIHRyYWNlQm94LnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6ICdzbW9vdGgnIH0pO1xuICAgICAgICAgICAgaXNUcmFjZVJlbmRlcmluZyA9IGZhbHNlOyAvLyBBbGxvdyBmdXJ0aGVyIGludGVyYWN0aW9ucyBhZnRlciByZW5kZXJpbmdcbiAgICAgICAgfSk7XG5cbiAgICBsZXQgdHJhY2VDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3RyYWNlLWdyYXBoLWNvbnRhaW5lclwiKTtcbiAgICAvLyBkaXNhYmxlIG1vdmluZyBhcm91bmQgdmlhIGRyYWcgYW5kIGRyb3BcbiAgICBpZiAodHJhY2VDb250YWluZXIpIHtcbiAgICAgICAgdHJhY2VDb250YWluZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJzsgLy8gRGlzYWJsZSBwb2ludGVyIGV2ZW50cyB0byBwcmV2ZW50IGRyYWdnaW5nXG4gICAgfVxuXG5cbiAgICB0cmFjZVN0ZXBJbmRpY2F0b3IudGV4dENvbnRlbnQgPSBgJHtjdXJyZW50VHJhY2VJbmRleCArIDF9IC8gJHtjdXJyZW50VHJhY2VEb3RzLmxlbmd0aH1gO1xuICAgIHByZXZUcmFjZUJ0bi5kaXNhYmxlZCA9IGN1cnJlbnRUcmFjZUluZGV4ID09PSAwO1xuICAgIG5leHRUcmFjZUJ0bi5kaXNhYmxlZCA9IGN1cnJlbnRUcmFjZUluZGV4ID09PSBjdXJyZW50VHJhY2VEb3RzLmxlbmd0aCAtIDE7XG59XG5cblxuLy8gLS0tIEluaXRpYWwgTG9hZCAtLS1cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBwYW5pYyBob29rc1xuICAgIENvbnRleHQuaW5pdCgpO1xuICAgIC8vIExvYWQgR3JhcGh2aXogV0FTTSBtb2R1bGVcbiAgICBvdXRwdXRQcmUuaW5uZXJUZXh0ID0gXCJMb2FkaW5nIEdyYXBodml6IFdBU00gbW9kdWxlLi4uXCI7XG4gICAgZ3JhcGh2aXogPSBhd2FpdCBHcmFwaHZpei5sb2FkKCk7XG5cbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJ0aGVtZVwiKSkge1xuICAgICAgICBzZXRUaGVtZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcInRoZW1lXCIpKTtcbiAgICB9XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYXV0b19jb21waWxlX3RpbWVvdXRcIikpIHtcbiAgICAgICAgTVNfQkVUV0VFTl9DT0RFX0NIQU5HRVMgPSBwYXJzZUludChsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImF1dG9fY29tcGlsZV90aW1lb3V0XCIpLCAxMCk7XG4gICAgICAgIGF1dG9Db21waWxlSW5wdXQudmFsdWUgPSBNU19CRVRXRUVOX0NPREVfQ0hBTkdFUztcbiAgICB9XG4gICAgaWYgKGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic2tpcF9kdXBsaWNhdGVfdHJhY2VzXCIpKSB7XG4gICAgICAgIHNraXBEdXBsaWNhdGVUcmFjZXNJbnB1dC5jaGVja2VkID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJza2lwX2R1cGxpY2F0ZV90cmFjZXNcIikgPT09ICd0cnVlJztcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGluaXRpYWwgY29tcGlsYXRpb25cbiAgICBvbkNvZGVDaGFuZ2VkKCk7XG4gICAgaW5pdEludGVyYWN0aXZlR3JhcGgoKTsgLy8g8J+agFxuICAgIGluaXRUcmFjZVZpZXdlcigpO1xuXG4gICAgLy8gYWRkIGEgQ3RybC1TIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBtb25hY28gZWRpdG9yIHRoYXQgaW1tZWRpYXRlbHkgcnVucyBvbkNvZGVDaGFuZ2VkSW5uZXIoKVxuICAgIGVkaXRvci5hZGRDb21tYW5kKG1vbmFjby5LZXlNb2QuQ3RybENtZCB8IG1vbmFjby5LZXlDb2RlLktleVMsICgpID0+IHtcbiAgICAgICAgb25Db2RlQ2hhbmdlZElubmVyKCk7XG4gICAgfSk7XG59XG5cbi8vLyBBZHZhbmNlcyB0aGUgY3VycmVudCB0cmFjZSBpbmRleCBieSByZXNwZWN0aW5nIHRoZSB2YWx1ZSBvZlxuZnVuY3Rpb24gYWR2YW5jZVRyYWNlKCkge1xuICAgIGN1cnJlbnRUcmFjZUluZGV4Kys7XG4gICAgcmV0dXJuO1xuICAgIC8vIG5vdGU6IHdlJ3JlIGhhbmRsaW5nIHdpdGggcmF3Q3VycmVudFRyYWNlRG90cyBub3dcbiAgICAvLyBsZXQgZG9Ta2lwID0gc2tpcER1cGxpY2F0ZVRyYWNlc0lucHV0LmNoZWNrZWQ7XG4gICAgLy8gaWYgKGRvU2tpcCkge1xuICAgIC8vICAgICAvLyBza2lwIHRvIHRoZSBuZXh0IHVuaXF1ZSB0cmFjZSBkb3RcbiAgICAvLyAgICAgd2hpbGUgKGN1cnJlbnRUcmFjZUluZGV4IDwgY3VycmVudFRyYWNlRG90cy5sZW5ndGggLSAxICYmIGN1cnJlbnRUcmFjZURvdHNbY3VycmVudFRyYWNlSW5kZXhdID09PSBjdXJyZW50VHJhY2VEb3RzW2N1cnJlbnRUcmFjZUluZGV4ICsgMV0pIHtcbiAgICAvLyAgICAgICAgIGN1cnJlbnRUcmFjZUluZGV4Kys7XG4gICAgLy8gICAgIH1cbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgICAvLyBqdXN0IGluY3JlbWVudCB0aGUgaW5kZXhcbiAgICAvLyAgICAgaWYgKGN1cnJlbnRUcmFjZUluZGV4IDwgY3VycmVudFRyYWNlRG90cy5sZW5ndGggLSAxKSB7XG4gICAgLy8gICAgICAgICBjdXJyZW50VHJhY2VJbmRleCsrO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxufVxuXG5mdW5jdGlvbiBwcmV2aW91c1RyYWNlKCkge1xuICAgIGN1cnJlbnRUcmFjZUluZGV4LS07XG4gICAgcmV0dXJuO1xuICAgIC8vIG5vdGU6IHdlJ3JlIGhhbmRsaW5nIHdpdGggcmF3Q3VycmVudFRyYWNlRG90cyBub3dcbiAgICAvLyBsZXQgZG9Ta2lwID0gc2tpcER1cGxpY2F0ZVRyYWNlc0lucHV0LmNoZWNrZWQ7XG4gICAgLy8gaWYgKGRvU2tpcCkge1xuICAgIC8vICAgICAvLyBza2lwIHRvIHRoZSBwcmV2aW91cyB1bmlxdWUgdHJhY2UgZG90XG4gICAgLy8gICAgIHdoaWxlIChjdXJyZW50VHJhY2VJbmRleCA+IDAgJiYgY3VycmVudFRyYWNlRG90c1tjdXJyZW50VHJhY2VJbmRleF0gPT09IGN1cnJlbnRUcmFjZURvdHNbY3VycmVudFRyYWNlSW5kZXggLSAxXSkge1xuICAgIC8vICAgICAgICAgY3VycmVudFRyYWNlSW5kZXgtLTtcbiAgICAvLyAgICAgfVxuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICAgIC8vIGp1c3QgZGVjcmVtZW50IHRoZSBpbmRleFxuICAgIC8vICAgICBpZiAoY3VycmVudFRyYWNlSW5kZXggPiAwKSB7XG4gICAgLy8gICAgICAgICBjdXJyZW50VHJhY2VJbmRleC0tO1xuICAgIC8vICAgICB9XG4gICAgLy8gfVxufVxuXG5mdW5jdGlvbiBpbml0VHJhY2VWaWV3ZXIoKSB7XG4gICAgdHJhY2VHcmFwaHZpeiA9IGQzLnNlbGVjdChcIiN0cmFjZS1ncmFwaC1jb250YWluZXJcIikuZ3JhcGh2aXooe1xuICAgICAgICB1c2VXb3JrZXI6IGZhbHNlLFxuICAgICAgICBmaXQ6IHRydWUsXG4gICAgfSk7XG5cbiAgICAvLyBhZGQgY2hpbGQgdG8gdHJhY2VHcmFwaENvbnRhaW5lciB0byBwcm92aWRlIHNvbWUgYnVmZmVyXG4gICAgaWYgKHRyYWNlR3JhcGhDb250YWluZXIpIHtcbiAgICAgICAgbGV0IGRpdkNoaWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGRpdkNoaWxkLmNsYXNzTmFtZSA9IFwiaC1bMTAwdmhdIGJnLXdoaXRlXCI7XG4gICAgICAgIHRyYWNlR3JhcGhDb250YWluZXIuYXBwZW5kQ2hpbGQoZGl2Q2hpbGQpO1xuICAgIH1cblxuICAgIHByZXZUcmFjZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgaWYgKGlzVHJhY2VSZW5kZXJpbmcpIHJldHVybjsgLy8gUHJldmVudCBuYXZpZ2F0aW9uIHdoaWxlIHJlbmRlcmluZ1xuICAgICAgICBpZiAoY3VycmVudFRyYWNlSW5kZXggPiAwKSB7XG4gICAgICAgICAgICBwcmV2aW91c1RyYWNlKCk7XG4gICAgICAgICAgICByZW5kZXJUcmFjZUdyYXBoKCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIG5leHRUcmFjZUJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgaWYgKGlzVHJhY2VSZW5kZXJpbmcpIHJldHVybjsgLy8gUHJldmVudCBuYXZpZ2F0aW9uIHdoaWxlIHJlbmRlcmluZ1xuICAgICAgICBpZiAoY3VycmVudFRyYWNlSW5kZXggPCBjdXJyZW50VHJhY2VEb3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGFkdmFuY2VUcmFjZSgpO1xuICAgICAgICAgICAgcmVuZGVyVHJhY2VHcmFwaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhZGQgbGVmdCBhbmQgcmlnaHQgYXJyb3cga2V5IGxpc3RlbmVycyB0byBuYXZpZ2F0ZSB0aGUgdHJhY2VcbiAgICB0cmFjZUJveC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGUpID0+IHtcbiAgICAgICAgaWYgKGlzVHJhY2VSZW5kZXJpbmcpIHJldHVybjsgLy8gUHJldmVudCBuYXZpZ2F0aW9uIHdoaWxlIHJlbmRlcmluZ1xuICAgICAgICBpZiAoZS5rZXkgPT09ICdBcnJvd0xlZnQnICYmIGN1cnJlbnRUcmFjZUluZGV4ID4gMCkge1xuICAgICAgICAgICAgcHJldmlvdXNUcmFjZSgpO1xuICAgICAgICAgICAgcmVuZGVyVHJhY2VHcmFwaCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGUua2V5ID09PSAnQXJyb3dSaWdodCcgJiYgY3VycmVudFRyYWNlSW5kZXggPCBjdXJyZW50VHJhY2VEb3RzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGFkdmFuY2VUcmFjZSgpO1xuICAgICAgICAgICAgcmVuZGVyVHJhY2VHcmFwaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmF3YWl0IG1haW4oKTtcbiIsInZhciBtYXAgPSB7XG5cdFwiLi9zaW1wbGVXb3JrZXJcIjogXCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi93b3JrZXIvc2ltcGxlV29ya2VyLmpzXCIsXG5cdFwiLi9zaW1wbGVXb3JrZXIuanNcIjogXCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9iYXNlL2NvbW1vbi93b3JrZXIvc2ltcGxlV29ya2VyLmpzXCJcbn07XG5cbmZ1bmN0aW9uIHdlYnBhY2tBc3luY0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdFx0dmFyIGUgPSBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInXCIpO1xuXHRcdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdFx0dGhyb3cgZTtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSBtYXBbcmVxXTtcblx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG5cdH0pO1xufVxud2VicGFja0FzeW5jQ29udGV4dC5rZXlzID0gKCkgPT4gKE9iamVjdC5rZXlzKG1hcCkpO1xud2VicGFja0FzeW5jQ29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvYmFzZS9jb21tb24vd29ya2VyIGxhenkgcmVjdXJzaXZlIF4uKiRcIjtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0FzeW5jQ29udGV4dDsiLCJ2YXIgbWFwID0ge1xuXHRcIi4vZWRpdG9yQmFzZUFwaVwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvckJhc2VBcGkuanNcIlxuXHRdLFxuXHRcIi4vZWRpdG9yQmFzZUFwaS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvckJhc2VBcGkuanNcIlxuXHRdLFxuXHRcIi4vZWRpdG9yU2ltcGxlV29ya2VyXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yU2ltcGxlV29ya2VyLmpzXCJcblx0XSxcblx0XCIuL2VkaXRvclNpbXBsZVdvcmtlci5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2VkaXRvclNpbXBsZVdvcmtlci5qc1wiXG5cdF0sXG5cdFwiLi9lZGl0b3JXb3JrZXJcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JXb3JrZXIuanNcIlxuXHRdLFxuXHRcIi4vZWRpdG9yV29ya2VyLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvZWRpdG9yV29ya2VyLmpzXCJcblx0XSxcblx0XCIuL2VkaXRvcldvcmtlckhvc3RcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JXb3JrZXJIb3N0LmpzXCJcblx0XSxcblx0XCIuL2VkaXRvcldvcmtlckhvc3QuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9lZGl0b3JXb3JrZXJIb3N0LmpzXCJcblx0XSxcblx0XCIuL2ZpbmRTZWN0aW9uSGVhZGVyc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2ZpbmRTZWN0aW9uSGVhZGVycy5qc1wiXG5cdF0sXG5cdFwiLi9maW5kU2VjdGlvbkhlYWRlcnMuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9maW5kU2VjdGlvbkhlYWRlcnMuanNcIlxuXHRdLFxuXHRcIi4vZ2V0SWNvbkNsYXNzZXNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9nZXRJY29uQ2xhc3Nlcy5qc1wiXG5cdF0sXG5cdFwiLi9nZXRJY29uQ2xhc3Nlcy5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2dldEljb25DbGFzc2VzLmpzXCJcblx0XSxcblx0XCIuL2xhbmd1YWdlRmVhdHVyZURlYm91bmNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VGZWF0dXJlRGVib3VuY2UuanNcIlxuXHRdLFxuXHRcIi4vbGFuZ3VhZ2VGZWF0dXJlRGVib3VuY2UuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9sYW5ndWFnZUZlYXR1cmVEZWJvdW5jZS5qc1wiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZUZlYXR1cmVzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VGZWF0dXJlcy5qc1wiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZUZlYXR1cmVzLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VGZWF0dXJlcy5qc1wiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZUZlYXR1cmVzU2VydmljZVwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2xhbmd1YWdlRmVhdHVyZXNTZXJ2aWNlLmpzXCJcblx0XSxcblx0XCIuL2xhbmd1YWdlRmVhdHVyZXNTZXJ2aWNlLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VGZWF0dXJlc1NlcnZpY2UuanNcIlxuXHRdLFxuXHRcIi4vbGFuZ3VhZ2VTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VTZXJ2aWNlLmpzXCJcblx0XSxcblx0XCIuL2xhbmd1YWdlU2VydmljZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL2xhbmd1YWdlU2VydmljZS5qc1wiXG5cdF0sXG5cdFwiLi9sYW5ndWFnZXNBc3NvY2lhdGlvbnNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9sYW5ndWFnZXNBc3NvY2lhdGlvbnMuanNcIlxuXHRdLFxuXHRcIi4vbGFuZ3VhZ2VzQXNzb2NpYXRpb25zLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VzQXNzb2NpYXRpb25zLmpzXCJcblx0XSxcblx0XCIuL2xhbmd1YWdlc1JlZ2lzdHJ5XCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbGFuZ3VhZ2VzUmVnaXN0cnkuanNcIlxuXHRdLFxuXHRcIi4vbGFuZ3VhZ2VzUmVnaXN0cnkuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9sYW5ndWFnZXNSZWdpc3RyeS5qc1wiXG5cdF0sXG5cdFwiLi9tYXJrZXJEZWNvcmF0aW9uc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL21hcmtlckRlY29yYXRpb25zLmpzXCJcblx0XSxcblx0XCIuL21hcmtlckRlY29yYXRpb25zLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbWFya2VyRGVjb3JhdGlvbnMuanNcIlxuXHRdLFxuXHRcIi4vbWFya2VyRGVjb3JhdGlvbnNTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbWFya2VyRGVjb3JhdGlvbnNTZXJ2aWNlLmpzXCJcblx0XSxcblx0XCIuL21hcmtlckRlY29yYXRpb25zU2VydmljZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL21hcmtlckRlY29yYXRpb25zU2VydmljZS5qc1wiXG5cdF0sXG5cdFwiLi9tb2RlbFwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL21vZGVsLmpzXCJcblx0XSxcblx0XCIuL21vZGVsLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbW9kZWwuanNcIlxuXHRdLFxuXHRcIi4vbW9kZWxTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvbW9kZWxTZXJ2aWNlLmpzXCJcblx0XSxcblx0XCIuL21vZGVsU2VydmljZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL21vZGVsU2VydmljZS5qc1wiXG5cdF0sXG5cdFwiLi9yZXNvbHZlclNlcnZpY2VcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9yZXNvbHZlclNlcnZpY2UuanNcIlxuXHRdLFxuXHRcIi4vcmVzb2x2ZXJTZXJ2aWNlLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvcmVzb2x2ZXJTZXJ2aWNlLmpzXCJcblx0XSxcblx0XCIuL3NlbWFudGljVG9rZW5zRHRvXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvc2VtYW50aWNUb2tlbnNEdG8uanNcIlxuXHRdLFxuXHRcIi4vc2VtYW50aWNUb2tlbnNEdG8uanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy9zZW1hbnRpY1Rva2Vuc0R0by5qc1wiXG5cdF0sXG5cdFwiLi9zZW1hbnRpY1Rva2Vuc1Byb3ZpZGVyU3R5bGluZ1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3NlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nLmpzXCJcblx0XSxcblx0XCIuL3NlbWFudGljVG9rZW5zUHJvdmlkZXJTdHlsaW5nLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvc2VtYW50aWNUb2tlbnNQcm92aWRlclN0eWxpbmcuanNcIlxuXHRdLFxuXHRcIi4vc2VtYW50aWNUb2tlbnNTdHlsaW5nXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvc2VtYW50aWNUb2tlbnNTdHlsaW5nLmpzXCJcblx0XSxcblx0XCIuL3NlbWFudGljVG9rZW5zU3R5bGluZy5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3NlbWFudGljVG9rZW5zU3R5bGluZy5qc1wiXG5cdF0sXG5cdFwiLi9zZW1hbnRpY1Rva2Vuc1N0eWxpbmdTZXJ2aWNlXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvc2VtYW50aWNUb2tlbnNTdHlsaW5nU2VydmljZS5qc1wiXG5cdF0sXG5cdFwiLi9zZW1hbnRpY1Rva2Vuc1N0eWxpbmdTZXJ2aWNlLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvc2VtYW50aWNUb2tlbnNTdHlsaW5nU2VydmljZS5qc1wiXG5cdF0sXG5cdFwiLi90ZXh0TW9kZWxTeW5jL3RleHRNb2RlbFN5bmMuaW1wbFwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RleHRNb2RlbFN5bmMvdGV4dE1vZGVsU3luYy5pbXBsLmpzXCJcblx0XSxcblx0XCIuL3RleHRNb2RlbFN5bmMvdGV4dE1vZGVsU3luYy5pbXBsLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdGV4dE1vZGVsU3luYy90ZXh0TW9kZWxTeW5jLmltcGwuanNcIlxuXHRdLFxuXHRcIi4vdGV4dE1vZGVsU3luYy90ZXh0TW9kZWxTeW5jLnByb3RvY29sXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdGV4dE1vZGVsU3luYy90ZXh0TW9kZWxTeW5jLnByb3RvY29sLmpzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc190ZXh0TW9kZWxTeW5jX3RleHRNb2RlbFN5bmNfcHJvdG9jb2xfanNcIlxuXHRdLFxuXHRcIi4vdGV4dE1vZGVsU3luYy90ZXh0TW9kZWxTeW5jLnByb3RvY29sLmpzXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdGV4dE1vZGVsU3luYy90ZXh0TW9kZWxTeW5jLnByb3RvY29sLmpzXCIsXG5cdFx0XCJub2RlX21vZHVsZXNfbW9uYWNvLWVkaXRvcl9lc21fdnNfZWRpdG9yX2NvbW1vbl9zZXJ2aWNlc190ZXh0TW9kZWxTeW5jX3RleHRNb2RlbFN5bmNfcHJvdG9jb2xfanNcIlxuXHRdLFxuXHRcIi4vdGV4dFJlc291cmNlQ29uZmlndXJhdGlvblwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RleHRSZXNvdXJjZUNvbmZpZ3VyYXRpb24uanNcIlxuXHRdLFxuXHRcIi4vdGV4dFJlc291cmNlQ29uZmlndXJhdGlvbi5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RleHRSZXNvdXJjZUNvbmZpZ3VyYXRpb24uanNcIlxuXHRdLFxuXHRcIi4vdHJlZVNpdHRlclBhcnNlclNlcnZpY2VcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy90cmVlU2l0dGVyUGFyc2VyU2VydmljZS5qc1wiXG5cdF0sXG5cdFwiLi90cmVlU2l0dGVyUGFyc2VyU2VydmljZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RyZWVTaXR0ZXJQYXJzZXJTZXJ2aWNlLmpzXCJcblx0XSxcblx0XCIuL3RyZWVWaWV3c0RuZFwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RyZWVWaWV3c0RuZC5qc1wiXG5cdF0sXG5cdFwiLi90cmVlVmlld3NEbmQuanNcIjogW1xuXHRcdFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcy90cmVlVmlld3NEbmQuanNcIlxuXHRdLFxuXHRcIi4vdHJlZVZpZXdzRG5kU2VydmljZVwiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RyZWVWaWV3c0RuZFNlcnZpY2UuanNcIlxuXHRdLFxuXHRcIi4vdHJlZVZpZXdzRG5kU2VydmljZS5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3RyZWVWaWV3c0RuZFNlcnZpY2UuanNcIlxuXHRdLFxuXHRcIi4vdW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyXCI6IFtcblx0XHRcIi4vbm9kZV9tb2R1bGVzL21vbmFjby1lZGl0b3IvZXNtL3ZzL2VkaXRvci9jb21tb24vc2VydmljZXMvdW5pY29kZVRleHRNb2RlbEhpZ2hsaWdodGVyLmpzXCJcblx0XSxcblx0XCIuL3VuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlci5qc1wiOiBbXG5cdFx0XCIuL25vZGVfbW9kdWxlcy9tb25hY28tZWRpdG9yL2VzbS92cy9lZGl0b3IvY29tbW9uL3NlcnZpY2VzL3VuaWNvZGVUZXh0TW9kZWxIaWdobGlnaHRlci5qc1wiXG5cdF1cbn07XG5mdW5jdGlvbiB3ZWJwYWNrQXN5bmNDb250ZXh0KHJlcSkge1xuXHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKG1hcCwgcmVxKSkge1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcblx0XHRcdHZhciBlID0gbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIiArIHJlcSArIFwiJ1wiKTtcblx0XHRcdGUuY29kZSA9ICdNT0RVTEVfTk9UX0ZPVU5EJztcblx0XHRcdHRocm93IGU7XG5cdFx0fSk7XG5cdH1cblxuXHR2YXIgaWRzID0gbWFwW3JlcV0sIGlkID0gaWRzWzBdO1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwoaWRzLnNsaWNlKDEpLm1hcChfX3dlYnBhY2tfcmVxdWlyZV9fLmUpKS50aGVuKCgpID0+IHtcblx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhpZCk7XG5cdH0pO1xufVxud2VicGFja0FzeW5jQ29udGV4dC5rZXlzID0gKCkgPT4gKE9iamVjdC5rZXlzKG1hcCkpO1xud2VicGFja0FzeW5jQ29udGV4dC5pZCA9IFwiLi9ub2RlX21vZHVsZXMvbW9uYWNvLWVkaXRvci9lc20vdnMvZWRpdG9yL2NvbW1vbi9zZXJ2aWNlcyBsYXp5IHJlY3Vyc2l2ZSBeLiokXCI7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tBc3luY0NvbnRleHQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9