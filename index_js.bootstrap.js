"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcreate_wasm_app"] = self["webpackChunkcreate_wasm_app"] || []).push([["index_js"],{

/***/ "../online-syntax-js/api/Context.mjs":
/*!*******************************************!*\
  !*** ../online-syntax-js/api/Context.mjs ***!
  \*******************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Context: () => (/* binding */ Context)\n/* harmony export */ });\n/* harmony import */ var _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./diplomat-wasm.mjs */ \"../online-syntax-js/api/diplomat-wasm.mjs\");\n/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ \"../online-syntax-js/api/diplomat-runtime.mjs\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__]);\n_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n// generated by diplomat-tool\n\n\n\n\n\nclass Context {\n    #i;\n    get i() {\n        return this.#i;\n    }\n    set i(value){\n        this.#i = value;\n    }\n    /** @internal */\n    static fromFields(structObj) {\n        return new Context(structObj);\n    }\n\n    #internalConstructor(structObj) {\n        if (typeof structObj !== \"object\") {\n            throw new Error(\"Context's constructor takes an object of Context's fields.\");\n        }\n\n        if (\"i\" in structObj) {\n            this.#i = structObj.i;\n        } else {\n            throw new Error(\"Missing required field i.\");\n        }\n\n        return this;\n    }\n\n    // Return this struct in FFI function friendly format.\n    // Returns an array that can be expanded with spread syntax (...)\n    _intoFFI(\n        functionCleanupArena,\n        appendArrayMap\n    ) {\n        return [this.#i]\n    }\n\n    static _fromSuppliedValue(internalConstructor, obj) {\n        if (internalConstructor !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {\n            throw new Error(\"_fromSuppliedValue cannot be called externally.\");\n        }\n\n        if (obj instanceof Context) {\n            return obj;\n        }\n\n        return Context.fromFields(obj);\n    }\n\n    _writeToArrayBuffer(\n        arrayBuffer,\n        offset,\n        functionCleanupArena,\n        appendArrayMap\n    ) {\n        _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.writeToArrayBuffer(arrayBuffer, offset + 0, this.#i, Int32Array);\n    }\n\n    // This struct contains borrowed fields, so this takes in a list of\n    // \"edges\" corresponding to where each lifetime's data may have been borrowed from\n    // and passes it down to individual fields containing the borrow.\n    // This method does not attempt to handle any dependencies between lifetimes, the caller\n    // should handle this when constructing edge arrays.\n    static _fromFFI(internalConstructor, primitiveValue) {\n        if (internalConstructor !== _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.internalConstructor) {\n            throw new Error(\"Context._fromFFI is not meant to be called externally. Please use the default constructor.\");\n        }\n        let structObj = {};\n        structObj.i = primitiveValue;\n\n        return new Context(structObj);\n    }\n\n\n    static init() {\n    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Context_init();\n\n        try {}\n\n        finally {\n        }\n    }\n\n    static parse(src) {\n        let functionCleanupArena = new _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.CleanupArena();\n\n        const srcSlice = _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.DiplomatBuf.str8(_diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"], src);\n    _diplomat_wasm_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Context_parse(...srcSlice.splat());\n\n        try {}\n\n        finally {\n            functionCleanupArena.free();\n\n        }\n    }\n\n    constructor(structObj) {\n        return this.#internalConstructor(...arguments)\n    }\n}\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://create-wasm-app/../online-syntax-js/api/Context.mjs?");

/***/ }),

/***/ "../online-syntax-js/api/diplomat-runtime.mjs":
/*!****************************************************!*\
  !*** ../online-syntax-js/api/diplomat-runtime.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CleanupArena: () => (/* binding */ CleanupArena),\n/* harmony export */   DiplomatBuf: () => (/* binding */ DiplomatBuf),\n/* harmony export */   DiplomatReceiveBuf: () => (/* binding */ DiplomatReceiveBuf),\n/* harmony export */   DiplomatSlice: () => (/* binding */ DiplomatSlice),\n/* harmony export */   DiplomatSlicePrimitive: () => (/* binding */ DiplomatSlicePrimitive),\n/* harmony export */   DiplomatSliceStr: () => (/* binding */ DiplomatSliceStr),\n/* harmony export */   DiplomatSliceStrings: () => (/* binding */ DiplomatSliceStrings),\n/* harmony export */   DiplomatWriteBuf: () => (/* binding */ DiplomatWriteBuf),\n/* harmony export */   GarbageCollectorGrip: () => (/* binding */ GarbageCollectorGrip),\n/* harmony export */   OwnedSliceLeaker: () => (/* binding */ OwnedSliceLeaker),\n/* harmony export */   enumDiscriminant: () => (/* binding */ enumDiscriminant),\n/* harmony export */   exposeConstructor: () => (/* binding */ exposeConstructor),\n/* harmony export */   internalConstructor: () => (/* binding */ internalConstructor),\n/* harmony export */   maybePaddingFields: () => (/* binding */ maybePaddingFields),\n/* harmony export */   optionToArgsForCalling: () => (/* binding */ optionToArgsForCalling),\n/* harmony export */   optionToBufferForCalling: () => (/* binding */ optionToBufferForCalling),\n/* harmony export */   ptrRead: () => (/* binding */ ptrRead),\n/* harmony export */   readOption: () => (/* binding */ readOption),\n/* harmony export */   readString16: () => (/* binding */ readString16),\n/* harmony export */   readString8: () => (/* binding */ readString8),\n/* harmony export */   resultFlag: () => (/* binding */ resultFlag),\n/* harmony export */   withDiplomatWrite: () => (/* binding */ withDiplomatWrite),\n/* harmony export */   writeOptionToArrayBuffer: () => (/* binding */ writeOptionToArrayBuffer),\n/* harmony export */   writeToArrayBuffer: () => (/* binding */ writeToArrayBuffer)\n/* harmony export */ });\n/** For internal Diplomat use when constructing opaques or out structs.\n * This is for when we're handling items that we don't want the user to touch, like an structure that's only meant to be output, or de-referencing a pointer we're handed from WASM.\n */\nconst internalConstructor = Symbol(\"constructor\");\n/** For internal Diplomat use when accessing a from-fields/from-value constructor that's been overridden by a default constructor.\n * If we want to pass in arguments without also passing in internalConstructor to avoid triggering some logic we don't want, we use exposeConstructor.\n */\nconst exposeConstructor = Symbol(\"exposeConstructor\");\n\nfunction readString8(wasm, ptr, len) {\n    const buf = new Uint8Array(wasm.memory.buffer, ptr, len);\n    return (new TextDecoder(\"utf-8\")).decode(buf)\n}\n\nfunction readString16(wasm, ptr, len) {\n    const buf = new Uint16Array(wasm.memory.buffer, ptr, len);\n    return String.fromCharCode.apply(null, buf)\n}\n\nfunction withDiplomatWrite(wasm, callback) {\n    const write = wasm.diplomat_buffer_write_create(0);\n    try {\n    callback(write);\n    const outStringPtr = wasm.diplomat_buffer_write_get_bytes(write);\n    if (outStringPtr === null) {\n        throw Error(\"Out of memory\");\n    }\n    const outStringLen = wasm.diplomat_buffer_write_len(write);\n    return readString8(wasm, outStringPtr, outStringLen);\n    } finally {\n    wasm.diplomat_buffer_write_destroy(write);\n    }\n}\n\n/**\n * Get the pointer returned by an FFI function.\n *\n * It's tempting to call `(new Uint32Array(wasm.memory.buffer, FFI_func(), 1))[0]`.\n * However, there's a chance that `wasm.memory.buffer` will be resized between\n * the time it's accessed and the time it's used, invalidating the view.\n * This function ensures that the view into wasm memory is fresh.\n *\n * This is used for methods that return multiple types into a wasm buffer, where\n * one of those types is another ptr. Call this method to get access to the returned\n * ptr, so the return buffer can be freed.\n * @param {WebAssembly.Exports} wasm Provided by diplomat generated files.\n * @param {number} ptr Pointer of a pointer, to be read.\n * @returns {number} The underlying pointer.\n */\nfunction ptrRead(wasm, ptr) {\n    return (new Uint32Array(wasm.memory.buffer, ptr, 1))[0];\n}\n\n/**\n * Get the flag of a result type.\n */\nfunction resultFlag(wasm, ptr, offset) {\n    return (new Uint8Array(wasm.memory.buffer, ptr + offset, 1))[0];\n}\n\n/**\n * Get the discriminant of a Rust enum.\n*/\nfunction enumDiscriminant(wasm, ptr) {\n    return (new Int32Array(wasm.memory.buffer, ptr, 1))[0]\n}\n\n/**\n * Return an array of paddingCount zeroes to be spread into a function call\n * if needsPaddingFields is true, else empty\n */\nfunction maybePaddingFields(needsPaddingFields, paddingCount) {\n    if (needsPaddingFields) {\n        return Array(paddingCount).fill(0);\n    } else {\n        return [];\n    }\n}\n\n/**\n* Write a value of width `width` to a an ArrayBuffer `arrayBuffer`\n* at byte offset `offset`, treating it as a buffer of kind `typedArrayKind`\n* (which is a `TypedArray` variant like `Uint8Array` or `Int16Array`)\n*/\nfunction writeToArrayBuffer(arrayBuffer, offset, value, typedArrayKind) {\n    let buffer = new typedArrayKind(arrayBuffer, offset);\n    buffer[0] = value;\n}\n\n/**\n* Take `jsValue` and write it to arrayBuffer at offset `offset` if it is non-null\n* calling `writeToArrayBufferCallback(arrayBuffer, offset, jsValue)` to write to the buffer,\n* also writing a tag bit.\n*\n* `size` and `align` are the size and alignment of T, not of Option<T>\n*/\nfunction writeOptionToArrayBuffer(arrayBuffer, offset, jsValue, size, align, writeToArrayBufferCallback) {\n    // perform a nullish check, not a null check,\n    // we want identical behavior for undefined\n    if (jsValue != null) {\n        writeToArrayBufferCallback(arrayBuffer, offset, jsValue);\n        writeToArrayBuffer(arrayBuffer, offset + size, 1, Uint8Array);\n    }\n}\n\n/**\n* For Option<T> of given size/align (of T, not the overall option type),\n* return an array of fields suitable for passing down to a parameter list.\n*\n* Calls writeToArrayBufferCallback(arrayBuffer, offset, jsValue) for non-null jsValues\n*\n* This array will have size<T>/align<T> elements for the actual T, then one element\n* for the is_ok bool, and then align<T> - 1 elements for padding.\n*\n* See wasm_abi_quirks.md's section on Unions for understanding this ABI.\n*/\nfunction optionToArgsForCalling(jsValue, size, align, writeToArrayBufferCallback) {\n    let args;\n    // perform a nullish check, not a null check,\n    // we want identical behavior for undefined\n    if (jsValue != null) {\n        let buffer;\n        // We need our originator array to be properly aligned\n        if (align == 8) {\n            buffer = new BigUint64Array(size / align);\n        } else if (align == 4) {\n            buffer = new Uint32Array(size / align);\n        } else if (align == 2) {\n            buffer = new Uint16Array(size / align);\n        } else {\n            buffer = new Uint8Array(size / align);\n        }\n\n\n        writeToArrayBufferCallback(buffer.buffer, 0, jsValue);\n        args = Array.from(buffer);\n        args.push(1);\n    } else {\n        args = Array(size / align).fill(0);\n        args.push(0);\n    }\n\n    // Unconditionally add padding\n    args = args.concat(Array(align - 1).fill(0));\n    return args;\n}\n\nfunction optionToBufferForCalling(wasm, jsValue, size, align, allocator, writeToArrayBufferCallback) {\n    let buf = DiplomatBuf.struct(wasm, size, align);\n\n    let buffer;\n    // Add 1 to the size since we're also accounting for the 0 or 1 is_ok field:\n    if (align == 8) {\n        buffer = new BigUint64Array(wasm.memory.buffer, buf, size / align + 1);\n    } else if (align == 4) {\n        buffer = new Uint32Array(wasm.memory.buffer, buf, size / align + 1);\n    } else if (align == 2) {\n        buffer = new Uint16Array(wasm.memory.buffer, buf, size / align + 1);\n    } else {\n        buffer = new Uint8Array(wasm.memory.buffer, buf, size / align + 1);\n    }\n\n    buffer.fill(0);\n\n    if (jsValue != null) {\n        writeToArrayBufferCallback(buffer.buffer, 0, jsValue);\n        buffer[buffer.length - 1] = 1;\n    }\n\n    allocator.alloc(buf);\n}\n\n\n/**\n* Given `ptr` in Wasm memory, treat it as an Option<T> with size for type T,\n* and return the converted T (converted using `readCallback(wasm, ptr)`) if the Option is Some\n* else None.\n*/\nfunction readOption(wasm, ptr, size, readCallback) {\n    // Don't need the alignment: diplomat types don't have overridden alignment,\n    // so the flag will immediately be after the inner struct.\n    let flag = resultFlag(wasm, ptr, size);\n    if (flag) {\n        return readCallback(wasm, ptr);\n    } else {\n        return null;\n    }\n}\n\n/**\n * A wrapper around a slice of WASM memory that can be freed manually or\n * automatically by the garbage collector.\n *\n * This type is necessary for Rust functions that take a `&str` or `&[T]`, since\n * they can create an edge to this object if they borrow from the str/slice,\n * or we can manually free the WASM memory if they don't.\n */\nclass DiplomatBuf {\n    static str8 = (wasm, string) => {\n    var utf8Length = 0;\n    for (const codepointString of string) {\n        let codepoint = codepointString.codePointAt(0);\n        if (codepoint < 0x80) {\n        utf8Length += 1\n        } else if (codepoint < 0x800) {\n        utf8Length += 2\n        } else if (codepoint < 0x10000) {\n        utf8Length += 3\n        } else {\n        utf8Length += 4\n        }\n    }\n\n    const ptr = wasm.diplomat_alloc(utf8Length, 1);\n\n    const result = (new TextEncoder()).encodeInto(string, new Uint8Array(wasm.memory.buffer, ptr, utf8Length));\n    console.assert(string.length === result.read && utf8Length === result.written, \"UTF-8 write error\");\n\n    return new DiplomatBuf(ptr, utf8Length, () => wasm.diplomat_free(ptr, utf8Length, 1));\n    }\n\n    static str16 = (wasm, string) => {\n    const byteLength = string.length * 2;\n    const ptr = wasm.diplomat_alloc(byteLength, 2);\n\n    const destination = new Uint16Array(wasm.memory.buffer, ptr, string.length);\n    for (let i = 0; i < string.length; i++) {\n        destination[i] = string.charCodeAt(i);\n    }\n\n    return new DiplomatBuf(ptr, string.length, () => wasm.diplomat_free(ptr, byteLength, 2));\n    }\n\n    static sliceWrapper = (wasm, buf) => {\n        const ptr = wasm.diplomat_alloc(8, 4);\n        let dst = new Uint32Array(wasm.memory.buffer, ptr, 2);\n\n        dst[0] = buf.ptr;\n        dst[1] = buf.size;\n        return new DiplomatBuf(ptr, 8, () => {\n            wasm.diplomat_free(ptr, 8, 4);\n            buf.free();\n        });\n    }\n\n    static slice = (wasm, list, rustType) => {\n    const elementSize = rustType === \"u8\" || rustType === \"i8\" || rustType === \"boolean\" ? 1 :\n        rustType === \"u16\" || rustType === \"i16\" ? 2 :\n        rustType === \"u64\" || rustType === \"i64\" || rustType === \"f64\" ? 8 :\n            4;\n\n    const byteLength = list.length * elementSize;\n    const ptr = wasm.diplomat_alloc(byteLength, elementSize);\n\n    /**\n     * Create an array view of the buffer. This gives us the `set` method which correctly handles untyped values\n     */\n    const destination =\n        rustType === \"u8\" || rustType === \"boolean\" ? new Uint8Array(wasm.memory.buffer, ptr, byteLength) :\n        rustType === \"i8\" ? new Int8Array(wasm.memory.buffer, ptr, byteLength) :\n            rustType === \"u16\" ? new Uint16Array(wasm.memory.buffer, ptr, byteLength) :\n            rustType === \"i16\" ? new Int16Array(wasm.memory.buffer, ptr, byteLength) :\n                rustType === \"i32\" ? new Int32Array(wasm.memory.buffer, ptr, byteLength) :\n                rustType === \"u64\" ? new BigUint64Array(wasm.memory.buffer, ptr, byteLength) :\n                    rustType === \"i64\" ? new BigInt64Array(wasm.memory.buffer, ptr, byteLength) :\n                    rustType === \"f32\" ? new Float32Array(wasm.memory.buffer, ptr, byteLength) :\n                        rustType === \"f64\" ? new Float64Array(wasm.memory.buffer, ptr, byteLength) :\n                        new Uint32Array(wasm.memory.buffer, ptr, byteLength);\n    destination.set(list);\n\n    return new DiplomatBuf(ptr, list.length, () => wasm.diplomat_free(ptr, byteLength, elementSize));\n    }\n\n    static strs = (wasm, strings, encoding) => {\n        let encodeStr = (encoding === \"string16\") ? DiplomatBuf.str16 : DiplomatBuf.str8;\n\n        const byteLength = strings.length * 4 * 2;\n\n        const ptr = wasm.diplomat_alloc(byteLength, 4);\n\n        const destination = new Uint32Array(wasm.memory.buffer, ptr, byteLength);\n\n        const stringsAlloc = [];\n\n        for (let i = 0; i < strings.length; i++) {\n            stringsAlloc.push(encodeStr(wasm, strings[i]));\n\n            destination[2 * i] = stringsAlloc[i].ptr;\n            destination[(2 * i) + 1] = stringsAlloc[i].size;\n        }\n\n        return new DiplomatBuf(ptr, strings.length, () => {\n            wasm.diplomat_free(ptr, byteLength, 4);\n            for (let i = 0; i < stringsAlloc.length; i++) {\n                stringsAlloc[i].free();\n            }\n        });\n    }\n\n    static struct = (wasm, size, align) => {\n        const ptr = wasm.diplomat_alloc(size, align);\n\n        return new DiplomatBuf(ptr, size, () => {\n            wasm.diplomat_free(ptr, size, align);\n        });\n    }\n\n    /**\n     * Generated code calls one of methods these for each allocation, to either\n     * free directly after the FFI call, to leak (to create a &'static), or to\n     * register the buffer with the garbage collector (to create a &'a).\n     */\n    free;\n\n    constructor(ptr, size, free) {\n        this.ptr = ptr;\n        this.size = size;\n        this.free = free;\n        this.leak = () => { };\n        this.releaseToGarbageCollector = () => DiplomatBufferFinalizer.register(this, this.free);\n    }\n\n    splat() {\n        return [this.ptr, this.size];\n    }\n\n    /**\n     * Write the (ptr, len) pair to an array buffer at byte offset `offset`\n     */\n    writePtrLenToArrayBuffer(arrayBuffer, offset) {\n        writeToArrayBuffer(arrayBuffer, offset, this.ptr, Uint32Array);\n        writeToArrayBuffer(arrayBuffer, offset + 4, this.size, Uint32Array);\n    }\n}\n\n/**\n * Helper class for creating and managing `diplomat_buffer_write`.\n * Meant to minimize direct calls to `wasm`.\n */\nclass DiplomatWriteBuf {\n    leak;\n\n    #wasm;\n    #buffer;\n\n    constructor(wasm) {\n        this.#wasm = wasm;\n        this.#buffer = this.#wasm.diplomat_buffer_write_create(0);\n\n        this.leak = () => { };\n    }\n\n    free() {\n        this.#wasm.diplomat_buffer_write_destroy(this.#buffer);\n    }\n\n    releaseToGarbageCollector() {\n        DiplomatBufferFinalizer.register(this, this.free);\n    }\n\n    readString8() {\n        return readString8(this.#wasm, this.ptr, this.size);\n    }\n\n    get buffer() {\n        return this.#buffer;\n    }\n\n    get ptr() {\n        return this.#wasm.diplomat_buffer_write_get_bytes(this.#buffer);\n    }\n\n    get size() {\n        return this.#wasm.diplomat_buffer_write_len(this.#buffer);\n    }\n}\n\n/**\n * Represents an underlying slice that we've grabbed from WebAssembly.\n * You can treat this in JS as a regular slice of primitives, but it handles additional data for you behind the scenes.\n */\nclass DiplomatSlice {\n    #wasm;\n\n    #bufferType;\n    get bufferType() {\n        return this.#bufferType;\n    }\n\n    #buffer;\n    get buffer() {\n        return this.#buffer;\n    }\n\n    #lifetimeEdges;\n\n    constructor(wasm, buffer, bufferType, lifetimeEdges) {\n        this.#wasm = wasm;\n\n        const [ptr, size] = new Uint32Array(this.#wasm.memory.buffer, buffer, 2);\n\n        this.#buffer = new bufferType(this.#wasm.memory.buffer, ptr, size);\n        this.#bufferType = bufferType;\n\n        this.#lifetimeEdges = lifetimeEdges;\n    }\n\n    getValue() {\n        return this.#buffer;\n    }\n\n    [Symbol.toPrimitive]() {\n        return this.getValue();\n    }\n\n    valueOf() {\n        return this.getValue();\n    }\n}\n\nclass DiplomatSlicePrimitive extends DiplomatSlice {\n    constructor(wasm, buffer, sliceType, lifetimeEdges) {\n        const [ptr, size] = new Uint32Array(wasm.memory.buffer, buffer, 2);\n\n        let arrayType;\n        switch (sliceType) {\n            case \"u8\":\n            case \"boolean\":\n                arrayType = Uint8Array;\n                break;\n            case \"i8\":\n                arrayType = Int8Array;\n                break;\n            case \"u16\":\n                arrayType = Uint16Array;\n                break;\n            case \"i16\":\n                arrayType = Int16Array;\n                break;\n            case \"i32\":\n                arrayType = Int32Array;\n                break;\n            case \"u32\":\n                arrayType = Uint32Array;\n                break;\n            case \"i64\":\n                arrayType = BigInt64Array;\n                break;\n            case \"u64\":\n                arrayType = BigUint64Array;\n                break;\n            case \"f32\":\n                arrayType = Float32Array;\n                break;\n            case \"f64\":\n                arrayType = Float64Array;\n                break;\n            default:\n                console.error(\"Unrecognized bufferType \", bufferType);\n        }\n\n        super(wasm, buffer, arrayType, lifetimeEdges);\n    }\n}\n\nclass DiplomatSliceStr extends DiplomatSlice {\n    #decoder;\n\n    constructor(wasm, buffer, stringEncoding, lifetimeEdges) {\n        let encoding;\n        switch (stringEncoding) {\n            case \"string8\":\n                encoding = Uint8Array;\n                break;\n            case \"string16\":\n                encoding = Uint16Array;\n                break;\n            default:\n                console.error(\"Unrecognized stringEncoding \", stringEncoding);\n                break;\n        }\n        super(wasm, buffer, encoding, lifetimeEdges);\n\n        if (stringEncoding === \"string8\") {\n            this.#decoder = new TextDecoder('utf-8');\n        }\n    }\n\n    getValue() {\n        switch (this.bufferType) {\n            case Uint8Array:\n                return this.#decoder.decode(super.getValue());\n            case Uint16Array:\n                return String.fromCharCode.apply(null, super.getValue());\n            default:\n                return null;\n        }\n    }\n\n    toString() {\n        return this.getValue();\n    }\n}\n\nclass DiplomatSliceStrings extends DiplomatSlice {\n    #strings = [];\n    constructor(wasm, buffer, stringEncoding, lifetimeEdges) {\n        super(wasm, buffer, Uint32Array, lifetimeEdges);\n\n        for (let i = this.buffer.byteOffset; i < this.buffer.byteLength; i += this.buffer.BYTES_PER_ELEMENT * 2) {\n            this.#strings.push(new DiplomatSliceStr(wasm, i, stringEncoding, lifetimeEdges));\n        }\n    }\n\n    getValue() {\n        return this.#strings;\n    }\n}\n\n/**\n * A number of Rust functions in WebAssembly require a buffer to populate struct, slice, Option<> or Result<> types with information.\n * {@link DiplomatReceiveBuf} allocates a buffer in WebAssembly, which can then be passed into functions with the {@link DiplomatReceiveBuf.buffer}\n * property.\n */\nclass DiplomatReceiveBuf {\n    #wasm;\n\n    #size;\n    #align;\n\n    #hasResult;\n\n    #buffer;\n\n    constructor(wasm, size, align, hasResult) {\n        this.#wasm = wasm;\n\n        this.#size = size;\n        this.#align = align;\n\n        this.#hasResult = hasResult;\n\n        this.#buffer = this.#wasm.diplomat_alloc(this.#size, this.#align);\n\n        this.leak = () => { };\n    }\n\n    free() {\n        this.#wasm.diplomat_free(this.#buffer, this.#size, this.#align);\n    }\n\n    get buffer() {\n        return this.#buffer;\n    }\n\n    /**\n     * Only for when a DiplomatReceiveBuf is allocating a buffer for an `Option<>` or a `Result<>` type.\n     *\n     * This just checks the last byte for a successful result (assuming that Rust's compiler does not change).\n     */\n    get resultFlag() {\n        if (this.#hasResult) {\n            return resultFlag(this.#wasm, this.#buffer, this.#size - 1);\n        } else {\n            return true;\n        }\n    }\n}\n\n/**\n * For preallocating owned slices\n *\n * Doesn't actually do anything, but helps code readability of generated code\n */\nclass OwnedSliceLeaker {\n    constructor() {\n    }\n\n    /**\n     * Leak an item\n     * @param {DiplomatBuf} item\n     * @returns {DiplomatBuf}\n     */\n    static alloc(item) {\n        item.leak();\n        return item;\n    }\n}\n\n/**\n * For cleaning up slices inside struct _intoFFI functions.\n * Based somewhat on how the Dart backend handles slice cleanup.\n *\n * We want to ensure a slice only lasts as long as its struct, so we have a `functionCleanupArena` CleanupArena that we use in each method for any slice that needs to be cleaned up. It lasts only as long as the function is called for.\n *\n * Then we have `createWith`, which is meant for longer lasting slices. It takes an array of edges and will last as long as those edges do. Cleanup is only called later.\n */\nclass CleanupArena {\n    #items = [];\n\n    constructor() {\n    }\n\n    /**\n     * When this arena is freed, call .free() on the given item.\n     * @param {DiplomatBuf} item\n     * @returns {DiplomatBuf}\n     */\n    alloc(item) {\n        this.#items.push(item);\n        return item;\n    }\n    /**\n     * Create a new CleanupArena, append it to any edge arrays passed down, and return it.\n     * @param {Array} edgeArrays\n     * @returns {CleanupArena}\n     */\n    static createWith(...edgeArrays) {\n        let self = new CleanupArena();\n        for (let edgeArray of edgeArrays) {\n            if (edgeArray != null) {\n                edgeArray.push(self);\n            }\n        }\n        DiplomatBufferFinalizer.register(self, self.free);\n        return self;\n    }\n\n    /**\n     * If given edge arrays, create a new CleanupArena, append it to any edge arrays passed down, and return it.\n     * Else return the function-local cleanup arena\n     * @param {CleanupArena} functionCleanupArena\n     * @param {Array} edgeArrays\n     * @returns {DiplomatBuf}\n     */\n    static maybeCreateWith(functionCleanupArena, ...edgeArrays) {\n        if (edgeArrays.length > 0) {\n            return CleanupArena.createWith(...edgeArrays);\n        } else {\n            return functionCleanupArena\n        }\n    }\n\n    free() {\n        this.#items.forEach((i) => {\n            i.free();\n        });\n\n        this.#items.length = 0;\n    }\n}\n\n/**\n * Similar to {@link CleanupArena}, but for holding on to slices until a method is called,\n * after which we rely on the GC to free them.\n *\n * This is when you may want to use a slice longer than the body of the method.\n *\n * At first glance this seems unnecessary, since we will be holding these slices in edge arrays anyway,\n * however, if an edge array ends up unused, then we do actually need something to hold it for the duration\n * of the method call.\n */\nclass GarbageCollectorGrip {\n    #items = [];\n\n    alloc(item) {\n        this.#items.push(item);\n        return item;\n    }\n\n    releaseToGarbageCollector() {\n        this.#items.forEach((i) => {\n            i.releaseToGarbageCollector();\n        });\n\n        this.#items.length = 0;\n    }\n}\n\nconst DiplomatBufferFinalizer = new FinalizationRegistry(free => free());\n\n\n//# sourceURL=webpack://create-wasm-app/../online-syntax-js/api/diplomat-runtime.mjs?");

/***/ }),

/***/ "../online-syntax-js/api/diplomat-wasm.mjs":
/*!*************************************************!*\
  !*** ../online-syntax-js/api/diplomat-wasm.mjs ***!
  \*************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _diplomat_config_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../diplomat.config.mjs */ \"../online-syntax-js/diplomat.config.mjs\");\n/* harmony import */ var _diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./diplomat-runtime.mjs */ \"../online-syntax-js/api/diplomat-runtime.mjs\");\n/* harmony import */ var _wbg_online_syntax_ffi_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../wbg/online_syntax_ffi.js */ \"../online-syntax-js/wbg/online_syntax_ffi.js\");\n\n\n\n\nconst imports = {\n    env: {\n        diplomat_console_debug_js(ptr, len) {\n            console.debug((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));\n        },\n        diplomat_console_error_js(ptr, len) {\n            console.error((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));\n        },\n        diplomat_console_info_js(ptr, len) {\n            console.info((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));\n        },\n        diplomat_console_log_js(ptr, len) {\n            console.log((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));\n        },\n        diplomat_console_warn_js(ptr, len) {\n            console.warn((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));\n        },\n        diplomat_throw_error_js(ptr, len) {\n            throw new Error((0,_diplomat_runtime_mjs__WEBPACK_IMPORTED_MODULE_1__.readString8)(wasm, ptr, len));\n        }\n    },\n    wbg: _wbg_online_syntax_ffi_js__WEBPACK_IMPORTED_MODULE_2__.__wbg_get_imports().wbg\n}\n\nlet wasm = await _wbg_online_syntax_ffi_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](imports)\n\nwasm.diplomat_init();\nif (_diplomat_config_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]['init'] !== undefined) {\n    _diplomat_config_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"]['init'](wasm);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (wasm);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } }, 1);\n\n//# sourceURL=webpack://create-wasm-app/../online-syntax-js/api/diplomat-wasm.mjs?");

/***/ }),

/***/ "../online-syntax-js/api/index.mjs":
/*!*****************************************!*\
  !*** ../online-syntax-js/api/index.mjs ***!
  \*****************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Context: () => (/* reexport safe */ _Context_mjs__WEBPACK_IMPORTED_MODULE_0__.Context)\n/* harmony export */ });\n/* harmony import */ var _Context_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Context.mjs */ \"../online-syntax-js/api/Context.mjs\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Context_mjs__WEBPACK_IMPORTED_MODULE_0__]);\n_Context_mjs__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://create-wasm-app/../online-syntax-js/api/index.mjs?");

/***/ }),

/***/ "../online-syntax-js/diplomat.config.mjs":
/*!***********************************************!*\
  !*** ../online-syntax-js/diplomat.config.mjs ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n});\n\n//# sourceURL=webpack://create-wasm-app/../online-syntax-js/diplomat.config.mjs?");

/***/ }),

/***/ "../online-syntax-js/wbg/online_syntax_ffi.js":
/*!****************************************************!*\
  !*** ../online-syntax-js/wbg/online_syntax_ffi.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __wbg_get_imports: () => (/* binding */ __wbg_get_imports),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   initSync: () => (/* binding */ initSync)\n/* harmony export */ });\n\nlet wasm;\n\nconst cachedTextDecoder = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );\n\nif (typeof TextDecoder !== 'undefined') { cachedTextDecoder.decode(); };\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nconst cachedTextEncoder = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length, 1) >>> 0;\n        getUint8ArrayMemory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len, 1) >>> 0;\n\n    const mem = getUint8ArrayMemory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;\n        const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n        ptr = realloc(ptr, len, offset, 1) >>> 0;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_error_7534b8e9a36f1ab4 = function(arg0, arg1) {\n        let deferred0_0;\n        let deferred0_1;\n        try {\n            deferred0_0 = arg0;\n            deferred0_1 = arg1;\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);\n        }\n    };\n    imports.wbg.__wbg_new_8a6f238a6ece86ea = function() {\n        const ret = new Error();\n        return ret;\n    };\n    imports.wbg.__wbg_stack_0ed75d68575b0f3c = function(arg0, arg1) {\n        const ret = arg1.stack;\n        const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        const len1 = WASM_VECTOR_LEN;\n        getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);\n        getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n        const table = wasm.__wbindgen_export_3;\n        const offset = table.grow(4);\n        table.set(0, undefined);\n        table.set(offset + 0, undefined);\n        table.set(offset + 1, null);\n        table.set(offset + 2, true);\n        table.set(offset + 3, false);\n        ;\n    };\n\n    return imports;\n}\n\nfunction __wbg_init_memory(imports, memory) {\n\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedDataViewMemory0 = null;\n    cachedUint8ArrayMemory0 = null;\n\n\n    wasm.__wbindgen_start();\n    return wasm;\n}\n\nfunction initSync(imports, module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n\n    __wbg_init_memory(imports);\n\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n\n    const instance = new WebAssembly.Instance(module, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(imports, module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL(/* asset import */ __webpack_require__(/*! online_syntax_ffi_bg.wasm */ \"../online-syntax-js/wbg/online_syntax_ffi_bg.wasm\"), __webpack_require__.b);\n    }\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    __wbg_init_memory(imports);\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__wbg_init);\n\n\n//# sourceURL=webpack://create-wasm-app/../online-syntax-js/wbg/online_syntax_ffi.js?");

/***/ }),

/***/ "../online-syntax-js/wbg/online_syntax_ffi_bg.wasm":
/*!*********************************************************!*\
  !*** ../online-syntax-js/wbg/online_syntax_ffi_bg.wasm ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__.p + \"474d899ca493feb78778.wasm\";\n\n//# sourceURL=webpack://create-wasm-app/../online-syntax-js/wbg/online_syntax_ffi_bg.wasm?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _hpcc_js_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hpcc-js/wasm */ \"./node_modules/@hpcc-js/wasm/dist/index.js\");\n/* harmony import */ var online_syntax_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! online-syntax-js */ \"../online-syntax-js/api/index.mjs\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([online_syntax_js__WEBPACK_IMPORTED_MODULE_1__]);\nonline_syntax_js__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nonline_syntax_js__WEBPACK_IMPORTED_MODULE_1__.Context.init()\n\nonline_syntax_js__WEBPACK_IMPORTED_MODULE_1__.Context.parse(\"fn hello() {}\")\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://create-wasm-app/./index.js?");

/***/ })

}]);